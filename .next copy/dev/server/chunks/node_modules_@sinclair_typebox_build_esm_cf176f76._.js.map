{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/symbols/symbols.mjs"],"sourcesContent":["/** Symbol key applied to transform types */\nexport const TransformKind = Symbol.for('TypeBox.Transform');\n/** Symbol key applied to readonly types */\nexport const ReadonlyKind = Symbol.for('TypeBox.Readonly');\n/** Symbol key applied to optional types */\nexport const OptionalKind = Symbol.for('TypeBox.Optional');\n/** Symbol key applied to types */\nexport const Hint = Symbol.for('TypeBox.Hint');\n/** Symbol key applied to types */\nexport const Kind = Symbol.for('TypeBox.Kind');\n"],"names":[],"mappings":"AAAA,0CAA0C;;;;;;;;;;;;AACnC,MAAM,gBAAgB,OAAO,GAAG,CAAC;AAEjC,MAAM,eAAe,OAAO,GAAG,CAAC;AAEhC,MAAM,eAAe,OAAO,GAAG,CAAC;AAEhC,MAAM,OAAO,OAAO,GAAG,CAAC;AAExB,MAAM,OAAO,OAAO,GAAG,CAAC","ignoreList":[0]}},
    {"offset": {"line": 25, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/type/type.mjs"],"sourcesContent":["// ------------------------------------------------------------------\n// Type: Module\n// ------------------------------------------------------------------\nexport { Any } from '../any/index.mjs';\nexport { Argument } from '../argument/index.mjs';\nexport { Array } from '../array/index.mjs';\nexport { AsyncIterator } from '../async-iterator/index.mjs';\nexport { Awaited } from '../awaited/index.mjs';\nexport { BigInt } from '../bigint/index.mjs';\nexport { Boolean } from '../boolean/index.mjs';\nexport { Composite } from '../composite/index.mjs';\nexport { Const } from '../const/index.mjs';\nexport { Constructor } from '../constructor/index.mjs';\nexport { ConstructorParameters } from '../constructor-parameters/index.mjs';\nexport { Date } from '../date/index.mjs';\nexport { Enum } from '../enum/index.mjs';\nexport { Exclude } from '../exclude/index.mjs';\nexport { Extends } from '../extends/index.mjs';\nexport { Extract } from '../extract/index.mjs';\nexport { Function } from '../function/index.mjs';\nexport { Index } from '../indexed/index.mjs';\nexport { InstanceType } from '../instance-type/index.mjs';\nexport { Instantiate } from '../instantiate/index.mjs';\nexport { Integer } from '../integer/index.mjs';\nexport { Intersect } from '../intersect/index.mjs';\nexport { Capitalize, Uncapitalize, Lowercase, Uppercase } from '../intrinsic/index.mjs';\nexport { Iterator } from '../iterator/index.mjs';\nexport { KeyOf } from '../keyof/index.mjs';\nexport { Literal } from '../literal/index.mjs';\nexport { Mapped } from '../mapped/index.mjs';\nexport { Module } from '../module/index.mjs';\nexport { Never } from '../never/index.mjs';\nexport { Not } from '../not/index.mjs';\nexport { Null } from '../null/index.mjs';\nexport { Number } from '../number/index.mjs';\nexport { Object } from '../object/index.mjs';\nexport { Omit } from '../omit/index.mjs';\nexport { Optional } from '../optional/index.mjs';\nexport { Parameters } from '../parameters/index.mjs';\nexport { Partial } from '../partial/index.mjs';\nexport { Pick } from '../pick/index.mjs';\nexport { Promise } from '../promise/index.mjs';\nexport { Readonly } from '../readonly/index.mjs';\nexport { ReadonlyOptional } from '../readonly-optional/index.mjs';\nexport { Record } from '../record/index.mjs';\nexport { Recursive } from '../recursive/index.mjs';\nexport { Ref } from '../ref/index.mjs';\nexport { RegExp } from '../regexp/index.mjs';\nexport { Required } from '../required/index.mjs';\nexport { Rest } from '../rest/index.mjs';\nexport { ReturnType } from '../return-type/index.mjs';\nexport { String } from '../string/index.mjs';\nexport { Symbol } from '../symbol/index.mjs';\nexport { TemplateLiteral } from '../template-literal/index.mjs';\nexport { Transform } from '../transform/index.mjs';\nexport { Tuple } from '../tuple/index.mjs';\nexport { Uint8Array } from '../uint8array/index.mjs';\nexport { Undefined } from '../undefined/index.mjs';\nexport { Union } from '../union/index.mjs';\nexport { Unknown } from '../unknown/index.mjs';\nexport { Unsafe } from '../unsafe/index.mjs';\nexport { Void } from '../void/index.mjs';\n"],"names":[],"mappings":"AAAA,qEAAqE;AACrE,eAAe;AACf,qEAAqE","ignoreList":[0]}},
    {"offset": {"line": 92, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/guard/guard.mjs"],"sourcesContent":["// --------------------------------------------------------------------------\n// Iterators\n// --------------------------------------------------------------------------\n/** Returns true if this value is an async iterator */\nexport function IsAsyncIterator(value) {\n    return IsObject(value) && globalThis.Symbol.asyncIterator in value;\n}\n/** Returns true if this value is an iterator */\nexport function IsIterator(value) {\n    return IsObject(value) && globalThis.Symbol.iterator in value;\n}\n// --------------------------------------------------------------------------\n// Object Instances\n// --------------------------------------------------------------------------\n/** Returns true if this value is not an instance of a class */\nexport function IsStandardObject(value) {\n    return IsObject(value) && (globalThis.Object.getPrototypeOf(value) === Object.prototype || globalThis.Object.getPrototypeOf(value) === null);\n}\n/** Returns true if this value is an instance of a class */\nexport function IsInstanceObject(value) {\n    return IsObject(value) && !IsArray(value) && IsFunction(value.constructor) && value.constructor.name !== 'Object';\n}\n// --------------------------------------------------------------------------\n// JavaScript\n// --------------------------------------------------------------------------\n/** Returns true if this value is a Promise */\nexport function IsPromise(value) {\n    return value instanceof globalThis.Promise;\n}\n/** Returns true if this value is a Date */\nexport function IsDate(value) {\n    return value instanceof Date && globalThis.Number.isFinite(value.getTime());\n}\n/** Returns true if this value is an instance of Map<K, T> */\nexport function IsMap(value) {\n    return value instanceof globalThis.Map;\n}\n/** Returns true if this value is an instance of Set<T> */\nexport function IsSet(value) {\n    return value instanceof globalThis.Set;\n}\n/** Returns true if this value is RegExp */\nexport function IsRegExp(value) {\n    return value instanceof globalThis.RegExp;\n}\n/** Returns true if this value is a typed array */\nexport function IsTypedArray(value) {\n    return globalThis.ArrayBuffer.isView(value);\n}\n/** Returns true if the value is a Int8Array */\nexport function IsInt8Array(value) {\n    return value instanceof globalThis.Int8Array;\n}\n/** Returns true if the value is a Uint8Array */\nexport function IsUint8Array(value) {\n    return value instanceof globalThis.Uint8Array;\n}\n/** Returns true if the value is a Uint8ClampedArray */\nexport function IsUint8ClampedArray(value) {\n    return value instanceof globalThis.Uint8ClampedArray;\n}\n/** Returns true if the value is a Int16Array */\nexport function IsInt16Array(value) {\n    return value instanceof globalThis.Int16Array;\n}\n/** Returns true if the value is a Uint16Array */\nexport function IsUint16Array(value) {\n    return value instanceof globalThis.Uint16Array;\n}\n/** Returns true if the value is a Int32Array */\nexport function IsInt32Array(value) {\n    return value instanceof globalThis.Int32Array;\n}\n/** Returns true if the value is a Uint32Array */\nexport function IsUint32Array(value) {\n    return value instanceof globalThis.Uint32Array;\n}\n/** Returns true if the value is a Float32Array */\nexport function IsFloat32Array(value) {\n    return value instanceof globalThis.Float32Array;\n}\n/** Returns true if the value is a Float64Array */\nexport function IsFloat64Array(value) {\n    return value instanceof globalThis.Float64Array;\n}\n/** Returns true if the value is a BigInt64Array */\nexport function IsBigInt64Array(value) {\n    return value instanceof globalThis.BigInt64Array;\n}\n/** Returns true if the value is a BigUint64Array */\nexport function IsBigUint64Array(value) {\n    return value instanceof globalThis.BigUint64Array;\n}\n// --------------------------------------------------------------------------\n// PropertyKey\n// --------------------------------------------------------------------------\n/** Returns true if this value has this property key */\nexport function HasPropertyKey(value, key) {\n    return key in value;\n}\n// --------------------------------------------------------------------------\n// Standard\n// --------------------------------------------------------------------------\n/** Returns true of this value is an object type */\nexport function IsObject(value) {\n    return value !== null && typeof value === 'object';\n}\n/** Returns true if this value is an array, but not a typed array */\nexport function IsArray(value) {\n    return globalThis.Array.isArray(value) && !globalThis.ArrayBuffer.isView(value);\n}\n/** Returns true if this value is an undefined */\nexport function IsUndefined(value) {\n    return value === undefined;\n}\n/** Returns true if this value is an null */\nexport function IsNull(value) {\n    return value === null;\n}\n/** Returns true if this value is an boolean */\nexport function IsBoolean(value) {\n    return typeof value === 'boolean';\n}\n/** Returns true if this value is an number */\nexport function IsNumber(value) {\n    return typeof value === 'number';\n}\n/** Returns true if this value is an integer */\nexport function IsInteger(value) {\n    return globalThis.Number.isInteger(value);\n}\n/** Returns true if this value is bigint */\nexport function IsBigInt(value) {\n    return typeof value === 'bigint';\n}\n/** Returns true if this value is string */\nexport function IsString(value) {\n    return typeof value === 'string';\n}\n/** Returns true if this value is a function */\nexport function IsFunction(value) {\n    return typeof value === 'function';\n}\n/** Returns true if this value is a symbol */\nexport function IsSymbol(value) {\n    return typeof value === 'symbol';\n}\n/** Returns true if this value is a value type such as number, string, boolean */\nexport function IsValueType(value) {\n    // prettier-ignore\n    return (IsBigInt(value) ||\n        IsBoolean(value) ||\n        IsNull(value) ||\n        IsNumber(value) ||\n        IsString(value) ||\n        IsSymbol(value) ||\n        IsUndefined(value));\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 272, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/system/policy.mjs"],"sourcesContent":["import { IsObject, IsArray, IsNumber, IsUndefined } from '../value/guard/index.mjs';\nexport var TypeSystemPolicy;\n(function (TypeSystemPolicy) {\n    // ------------------------------------------------------------------\n    // TypeSystemPolicy: Instancing\n    // ------------------------------------------------------------------\n    /**\n     * Configures the instantiation behavior of TypeBox types. The `default` option assigns raw JavaScript\n     * references for embedded types, which may cause side effects if type properties are explicitly updated\n     * outside the TypeBox type builder. The `clone` option creates copies of any shared types upon creation,\n     * preventing unintended side effects. The `freeze` option applies `Object.freeze()` to the type, making\n     * it fully readonly and immutable. Implementations should use `default` whenever possible, as it is the\n     * fastest way to instantiate types. The default setting is `default`.\n     */\n    TypeSystemPolicy.InstanceMode = 'default';\n    // ------------------------------------------------------------------\n    // TypeSystemPolicy: Checking\n    // ------------------------------------------------------------------\n    /** Sets whether TypeBox should assert optional properties using the TypeScript `exactOptionalPropertyTypes` assertion policy. The default is `false` */\n    TypeSystemPolicy.ExactOptionalPropertyTypes = false;\n    /** Sets whether arrays should be treated as a kind of objects. The default is `false` */\n    TypeSystemPolicy.AllowArrayObject = false;\n    /** Sets whether `NaN` or `Infinity` should be treated as valid numeric values. The default is `false` */\n    TypeSystemPolicy.AllowNaN = false;\n    /** Sets whether `null` should validate for void types. The default is `false` */\n    TypeSystemPolicy.AllowNullVoid = false;\n    /** Checks this value using the ExactOptionalPropertyTypes policy */\n    function IsExactOptionalProperty(value, key) {\n        return TypeSystemPolicy.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;\n    }\n    TypeSystemPolicy.IsExactOptionalProperty = IsExactOptionalProperty;\n    /** Checks this value using the AllowArrayObjects policy */\n    function IsObjectLike(value) {\n        const isObject = IsObject(value);\n        return TypeSystemPolicy.AllowArrayObject ? isObject : isObject && !IsArray(value);\n    }\n    TypeSystemPolicy.IsObjectLike = IsObjectLike;\n    /** Checks this value as a record using the AllowArrayObjects policy */\n    function IsRecordLike(value) {\n        return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);\n    }\n    TypeSystemPolicy.IsRecordLike = IsRecordLike;\n    /** Checks this value using the AllowNaN policy */\n    function IsNumberLike(value) {\n        return TypeSystemPolicy.AllowNaN ? IsNumber(value) : Number.isFinite(value);\n    }\n    TypeSystemPolicy.IsNumberLike = IsNumberLike;\n    /** Checks this value using the AllowVoidNull policy */\n    function IsVoidLike(value) {\n        const isUndefined = IsUndefined(value);\n        return TypeSystemPolicy.AllowNullVoid ? isUndefined || value === null : isUndefined;\n    }\n    TypeSystemPolicy.IsVoidLike = IsVoidLike;\n})(TypeSystemPolicy || (TypeSystemPolicy = {}));\n"],"names":[],"mappings":";;;;AAAA;;AACO,IAAI;AACX,CAAC,SAAU,gBAAgB;IACvB,qEAAqE;IACrE,+BAA+B;IAC/B,qEAAqE;IACrE;;;;;;;KAOC,GACD,iBAAiB,YAAY,GAAG;IAChC,qEAAqE;IACrE,6BAA6B;IAC7B,qEAAqE;IACrE,sJAAsJ,GACtJ,iBAAiB,0BAA0B,GAAG;IAC9C,uFAAuF,GACvF,iBAAiB,gBAAgB,GAAG;IACpC,uGAAuG,GACvG,iBAAiB,QAAQ,GAAG;IAC5B,+EAA+E,GAC/E,iBAAiB,aAAa,GAAG;IACjC,kEAAkE,GAClE,SAAS,wBAAwB,KAAK,EAAE,GAAG;QACvC,OAAO,iBAAiB,0BAA0B,GAAG,OAAO,QAAQ,KAAK,CAAC,IAAI,KAAK;IACvF;IACA,iBAAiB,uBAAuB,GAAG;IAC3C,yDAAyD,GACzD,SAAS,aAAa,KAAK;QACvB,MAAM,WAAW,IAAA,+LAAQ,EAAC;QAC1B,OAAO,iBAAiB,gBAAgB,GAAG,WAAW,YAAY,CAAC,IAAA,8LAAO,EAAC;IAC/E;IACA,iBAAiB,YAAY,GAAG;IAChC,qEAAqE,GACrE,SAAS,aAAa,KAAK;QACvB,OAAO,aAAa,UAAU,CAAC,CAAC,iBAAiB,IAAI,KAAK,CAAC,CAAC,iBAAiB,UAAU;IAC3F;IACA,iBAAiB,YAAY,GAAG;IAChC,gDAAgD,GAChD,SAAS,aAAa,KAAK;QACvB,OAAO,iBAAiB,QAAQ,GAAG,IAAA,+LAAQ,EAAC,SAAS,OAAO,QAAQ,CAAC;IACzE;IACA,iBAAiB,YAAY,GAAG;IAChC,qDAAqD,GACrD,SAAS,WAAW,KAAK;QACrB,MAAM,cAAc,IAAA,kMAAW,EAAC;QAChC,OAAO,iBAAiB,aAAa,GAAG,eAAe,UAAU,OAAO;IAC5E;IACA,iBAAiB,UAAU,GAAG;AAClC,CAAC,EAAE,oBAAoB,CAAC,mBAAmB,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 325, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/guard/value.mjs"],"sourcesContent":["// --------------------------------------------------------------------------\n// PropertyKey\n// --------------------------------------------------------------------------\n/** Returns true if this value has this property key */\nexport function HasPropertyKey(value, key) {\n    return key in value;\n}\n// --------------------------------------------------------------------------\n// Object Instances\n// --------------------------------------------------------------------------\n/** Returns true if this value is an async iterator */\nexport function IsAsyncIterator(value) {\n    return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;\n}\n/** Returns true if this value is an array */\nexport function IsArray(value) {\n    return Array.isArray(value);\n}\n/** Returns true if this value is bigint */\nexport function IsBigInt(value) {\n    return typeof value === 'bigint';\n}\n/** Returns true if this value is a boolean */\nexport function IsBoolean(value) {\n    return typeof value === 'boolean';\n}\n/** Returns true if this value is a Date object */\nexport function IsDate(value) {\n    return value instanceof globalThis.Date;\n}\n/** Returns true if this value is a function */\nexport function IsFunction(value) {\n    return typeof value === 'function';\n}\n/** Returns true if this value is an iterator */\nexport function IsIterator(value) {\n    return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;\n}\n/** Returns true if this value is null */\nexport function IsNull(value) {\n    return value === null;\n}\n/** Returns true if this value is number */\nexport function IsNumber(value) {\n    return typeof value === 'number';\n}\n/** Returns true if this value is an object */\nexport function IsObject(value) {\n    return typeof value === 'object' && value !== null;\n}\n/** Returns true if this value is RegExp */\nexport function IsRegExp(value) {\n    return value instanceof globalThis.RegExp;\n}\n/** Returns true if this value is string */\nexport function IsString(value) {\n    return typeof value === 'string';\n}\n/** Returns true if this value is symbol */\nexport function IsSymbol(value) {\n    return typeof value === 'symbol';\n}\n/** Returns true if this value is a Uint8Array */\nexport function IsUint8Array(value) {\n    return value instanceof globalThis.Uint8Array;\n}\n/** Returns true if this value is undefined */\nexport function IsUndefined(value) {\n    return value === undefined;\n}\n"],"names":[],"mappings":"AAAA,6EAA6E;AAC7E,cAAc;AACd,6EAA6E;AAC7E,qDAAqD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAC9C,SAAS,eAAe,KAAK,EAAE,GAAG;IACrC,OAAO,OAAO;AAClB;AAKO,SAAS,gBAAgB,KAAK;IACjC,OAAO,SAAS,UAAU,CAAC,QAAQ,UAAU,CAAC,aAAa,UAAU,OAAO,aAAa,IAAI;AACjG;AAEO,SAAS,QAAQ,KAAK;IACzB,OAAO,MAAM,OAAO,CAAC;AACzB;AAEO,SAAS,SAAS,KAAK;IAC1B,OAAO,OAAO,UAAU;AAC5B;AAEO,SAAS,UAAU,KAAK;IAC3B,OAAO,OAAO,UAAU;AAC5B;AAEO,SAAS,OAAO,KAAK;IACxB,OAAO,iBAAiB,WAAW,IAAI;AAC3C;AAEO,SAAS,WAAW,KAAK;IAC5B,OAAO,OAAO,UAAU;AAC5B;AAEO,SAAS,WAAW,KAAK;IAC5B,OAAO,SAAS,UAAU,CAAC,QAAQ,UAAU,CAAC,aAAa,UAAU,OAAO,QAAQ,IAAI;AAC5F;AAEO,SAAS,OAAO,KAAK;IACxB,OAAO,UAAU;AACrB;AAEO,SAAS,SAAS,KAAK;IAC1B,OAAO,OAAO,UAAU;AAC5B;AAEO,SAAS,SAAS,KAAK;IAC1B,OAAO,OAAO,UAAU,YAAY,UAAU;AAClD;AAEO,SAAS,SAAS,KAAK;IAC1B,OAAO,iBAAiB,WAAW,MAAM;AAC7C;AAEO,SAAS,SAAS,KAAK;IAC1B,OAAO,OAAO,UAAU;AAC5B;AAEO,SAAS,SAAS,KAAK;IAC1B,OAAO,OAAO,UAAU;AAC5B;AAEO,SAAS,aAAa,KAAK;IAC9B,OAAO,iBAAiB,WAAW,UAAU;AACjD;AAEO,SAAS,YAAY,KAAK;IAC7B,OAAO,UAAU;AACrB","ignoreList":[0]}},
    {"offset": {"line": 414, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/create/immutable.mjs"],"sourcesContent":["import * as ValueGuard from '../guard/value.mjs';\nfunction ImmutableArray(value) {\n    return globalThis.Object.freeze(value).map((value) => Immutable(value));\n}\nfunction ImmutableDate(value) {\n    return value;\n}\nfunction ImmutableUint8Array(value) {\n    return value;\n}\nfunction ImmutableRegExp(value) {\n    return value;\n}\nfunction ImmutableObject(value) {\n    const result = {};\n    for (const key of Object.getOwnPropertyNames(value)) {\n        result[key] = Immutable(value[key]);\n    }\n    for (const key of Object.getOwnPropertySymbols(value)) {\n        result[key] = Immutable(value[key]);\n    }\n    return globalThis.Object.freeze(result);\n}\n/** Specialized deep immutable value. Applies freeze recursively to the given value */\n// prettier-ignore\nexport function Immutable(value) {\n    return (ValueGuard.IsArray(value) ? ImmutableArray(value) :\n        ValueGuard.IsDate(value) ? ImmutableDate(value) :\n            ValueGuard.IsUint8Array(value) ? ImmutableUint8Array(value) :\n                ValueGuard.IsRegExp(value) ? ImmutableRegExp(value) :\n                    ValueGuard.IsObject(value) ? ImmutableObject(value) :\n                        value);\n}\n"],"names":[],"mappings":";;;;AAAA;;AACA,SAAS,eAAe,KAAK;IACzB,OAAO,WAAW,MAAM,CAAC,MAAM,CAAC,OAAO,GAAG,CAAC,CAAC,QAAU,UAAU;AACpE;AACA,SAAS,cAAc,KAAK;IACxB,OAAO;AACX;AACA,SAAS,oBAAoB,KAAK;IAC9B,OAAO;AACX;AACA,SAAS,gBAAgB,KAAK;IAC1B,OAAO;AACX;AACA,SAAS,gBAAgB,KAAK;IAC1B,MAAM,SAAS,CAAC;IAChB,KAAK,MAAM,OAAO,OAAO,mBAAmB,CAAC,OAAQ;QACjD,MAAM,CAAC,IAAI,GAAG,UAAU,KAAK,CAAC,IAAI;IACtC;IACA,KAAK,MAAM,OAAO,OAAO,qBAAqB,CAAC,OAAQ;QACnD,MAAM,CAAC,IAAI,GAAG,UAAU,KAAK,CAAC,IAAI;IACtC;IACA,OAAO,WAAW,MAAM,CAAC,MAAM,CAAC;AACpC;AAGO,SAAS,UAAU,KAAK;IAC3B,OAAQ,6LAAkB,CAAC,SAAS,eAAe,SAC/C,4LAAiB,CAAC,SAAS,cAAc,SACrC,kMAAuB,CAAC,SAAS,oBAAoB,SACjD,8LAAmB,CAAC,SAAS,gBAAgB,SACzC,8LAAmB,CAAC,SAAS,gBAAgB,SACzC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 449, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/clone/value.mjs"],"sourcesContent":["import * as ValueGuard from '../guard/value.mjs';\nfunction ArrayType(value) {\n    return value.map((value) => Visit(value));\n}\nfunction DateType(value) {\n    return new Date(value.getTime());\n}\nfunction Uint8ArrayType(value) {\n    return new Uint8Array(value);\n}\nfunction RegExpType(value) {\n    return new RegExp(value.source, value.flags);\n}\nfunction ObjectType(value) {\n    const result = {};\n    for (const key of Object.getOwnPropertyNames(value)) {\n        result[key] = Visit(value[key]);\n    }\n    for (const key of Object.getOwnPropertySymbols(value)) {\n        result[key] = Visit(value[key]);\n    }\n    return result;\n}\n// prettier-ignore\nfunction Visit(value) {\n    return (ValueGuard.IsArray(value) ? ArrayType(value) :\n        ValueGuard.IsDate(value) ? DateType(value) :\n            ValueGuard.IsUint8Array(value) ? Uint8ArrayType(value) :\n                ValueGuard.IsRegExp(value) ? RegExpType(value) :\n                    ValueGuard.IsObject(value) ? ObjectType(value) :\n                        value);\n}\n/** Clones a value */\nexport function Clone(value) {\n    return Visit(value);\n}\n"],"names":[],"mappings":";;;;AAAA;;AACA,SAAS,UAAU,KAAK;IACpB,OAAO,MAAM,GAAG,CAAC,CAAC,QAAU,MAAM;AACtC;AACA,SAAS,SAAS,KAAK;IACnB,OAAO,IAAI,KAAK,MAAM,OAAO;AACjC;AACA,SAAS,eAAe,KAAK;IACzB,OAAO,IAAI,WAAW;AAC1B;AACA,SAAS,WAAW,KAAK;IACrB,OAAO,IAAI,OAAO,MAAM,MAAM,EAAE,MAAM,KAAK;AAC/C;AACA,SAAS,WAAW,KAAK;IACrB,MAAM,SAAS,CAAC;IAChB,KAAK,MAAM,OAAO,OAAO,mBAAmB,CAAC,OAAQ;QACjD,MAAM,CAAC,IAAI,GAAG,MAAM,KAAK,CAAC,IAAI;IAClC;IACA,KAAK,MAAM,OAAO,OAAO,qBAAqB,CAAC,OAAQ;QACnD,MAAM,CAAC,IAAI,GAAG,MAAM,KAAK,CAAC,IAAI;IAClC;IACA,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,MAAM,KAAK;IAChB,OAAQ,6LAAkB,CAAC,SAAS,UAAU,SAC1C,4LAAiB,CAAC,SAAS,SAAS,SAChC,kMAAuB,CAAC,SAAS,eAAe,SAC5C,8LAAmB,CAAC,SAAS,WAAW,SACpC,8LAAmB,CAAC,SAAS,WAAW,SACpC;AACxB;AAEO,SAAS,MAAM,KAAK;IACvB,OAAO,MAAM;AACjB","ignoreList":[0]}},
    {"offset": {"line": 488, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/create/type.mjs"],"sourcesContent":["import { TypeSystemPolicy } from '../../system/policy.mjs';\nimport { Immutable } from './immutable.mjs';\nimport { Clone } from '../clone/value.mjs';\n/** Creates TypeBox schematics using the configured InstanceMode */\nexport function CreateType(schema, options) {\n    const result = options !== undefined ? { ...options, ...schema } : schema;\n    switch (TypeSystemPolicy.InstanceMode) {\n        case 'freeze':\n            return Immutable(result);\n        case 'clone':\n            return Clone(result);\n        default:\n            return result;\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,SAAS,WAAW,MAAM,EAAE,OAAO;IACtC,MAAM,SAAS,YAAY,YAAY;QAAE,GAAG,OAAO;QAAE,GAAG,MAAM;IAAC,IAAI;IACnE,OAAQ,gMAAgB,CAAC,YAAY;QACjC,KAAK;YACD,OAAO,IAAA,oMAAS,EAAC;QACrB,KAAK;YACD,OAAO,IAAA,2LAAK,EAAC;QACjB;YACI,OAAO;IACf;AACJ","ignoreList":[0]}},
    {"offset": {"line": 516, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/any/any.mjs"],"sourcesContent":["import { CreateType } from '../create/index.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates an Any type */\nexport function Any(options) {\n    return CreateType({ [Kind]: 'Any' }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,IAAI,OAAO;IACvB,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;IAAM,GAAG;AACzC","ignoreList":[0]}},
    {"offset": {"line": 533, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/argument/argument.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates an Argument Type. */\nexport function Argument(index) {\n    return CreateType({ [Kind]: 'Argument', index });\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,SAAS,KAAK;IAC1B,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAY;IAAM;AAClD","ignoreList":[0]}},
    {"offset": {"line": 551, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/array/array.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates an Array type */\nexport function Array(items, options) {\n    return CreateType({ [Kind]: 'Array', type: 'array', items }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,MAAM,KAAK,EAAE,OAAO;IAChC,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAS,MAAM;QAAS;IAAM,GAAG;AACjE","ignoreList":[0]}},
    {"offset": {"line": 570, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs"],"sourcesContent":["import { Kind } from '../symbols/index.mjs';\nimport { CreateType } from '../create/type.mjs';\n/** `[JavaScript]` Creates a AsyncIterator type */\nexport function AsyncIterator(items, options) {\n    return CreateType({ [Kind]: 'AsyncIterator', type: 'AsyncIterator', items }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,cAAc,KAAK,EAAE,OAAO;IACxC,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAiB,MAAM;QAAiB;IAAM,GAAG;AACjF","ignoreList":[0]}},
    {"offset": {"line": 589, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/computed/computed.mjs"],"sourcesContent":["import { CreateType } from '../create/index.mjs';\nimport { Kind } from '../symbols/symbols.mjs';\n/** `[Internal]` Creates a deferred computed type. This type is used exclusively in modules to defer resolution of computable types that contain interior references  */\nexport function Computed(target, parameters, options) {\n    return CreateType({ [Kind]: 'Computed', target, parameters }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,SAAS,MAAM,EAAE,UAAU,EAAE,OAAO;IAChD,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAY;QAAQ;IAAW,GAAG;AAClE","ignoreList":[0]}},
    {"offset": {"line": 608, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/never/never.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Never type */\nexport function Never(options) {\n    return CreateType({ [Kind]: 'Never', not: {} }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,MAAM,OAAO;IACzB,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAS,KAAK,CAAC;IAAE,GAAG;AACpD","ignoreList":[0]}},
    {"offset": {"line": 626, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/guard/kind.mjs"],"sourcesContent":["import * as ValueGuard from './value.mjs';\nimport { Kind, Hint, TransformKind, ReadonlyKind, OptionalKind } from '../symbols/index.mjs';\n/** `[Kind-Only]` Returns true if this value has a Readonly symbol */\nexport function IsReadonly(value) {\n    return ValueGuard.IsObject(value) && value[ReadonlyKind] === 'Readonly';\n}\n/** `[Kind-Only]` Returns true if this value has a Optional symbol */\nexport function IsOptional(value) {\n    return ValueGuard.IsObject(value) && value[OptionalKind] === 'Optional';\n}\n/** `[Kind-Only]` Returns true if the given value is TAny */\nexport function IsAny(value) {\n    return IsKindOf(value, 'Any');\n}\n/** `[Kind-Only]` Returns true if the given value is TArgument */\nexport function IsArgument(value) {\n    return IsKindOf(value, 'Argument');\n}\n/** `[Kind-Only]` Returns true if the given value is TArray */\nexport function IsArray(value) {\n    return IsKindOf(value, 'Array');\n}\n/** `[Kind-Only]` Returns true if the given value is TAsyncIterator */\nexport function IsAsyncIterator(value) {\n    return IsKindOf(value, 'AsyncIterator');\n}\n/** `[Kind-Only]` Returns true if the given value is TBigInt */\nexport function IsBigInt(value) {\n    return IsKindOf(value, 'BigInt');\n}\n/** `[Kind-Only]` Returns true if the given value is TBoolean */\nexport function IsBoolean(value) {\n    return IsKindOf(value, 'Boolean');\n}\n/** `[Kind-Only]` Returns true if the given value is TComputed */\nexport function IsComputed(value) {\n    return IsKindOf(value, 'Computed');\n}\n/** `[Kind-Only]` Returns true if the given value is TConstructor */\nexport function IsConstructor(value) {\n    return IsKindOf(value, 'Constructor');\n}\n/** `[Kind-Only]` Returns true if the given value is TDate */\nexport function IsDate(value) {\n    return IsKindOf(value, 'Date');\n}\n/** `[Kind-Only]` Returns true if the given value is TFunction */\nexport function IsFunction(value) {\n    return IsKindOf(value, 'Function');\n}\n/** `[Kind-Only]` Returns true if the given value is TInteger */\nexport function IsImport(value) {\n    return IsKindOf(value, 'Import');\n}\n/** `[Kind-Only]` Returns true if the given value is TInteger */\nexport function IsInteger(value) {\n    return IsKindOf(value, 'Integer');\n}\n/** `[Kind-Only]` Returns true if the given schema is TProperties */\nexport function IsProperties(value) {\n    return ValueGuard.IsObject(value);\n}\n/** `[Kind-Only]` Returns true if the given value is TIntersect */\nexport function IsIntersect(value) {\n    return IsKindOf(value, 'Intersect');\n}\n/** `[Kind-Only]` Returns true if the given value is TIterator */\nexport function IsIterator(value) {\n    return IsKindOf(value, 'Iterator');\n}\n/** `[Kind-Only]` Returns true if the given value is a TKind with the given name. */\nexport function IsKindOf(value, kind) {\n    return ValueGuard.IsObject(value) && Kind in value && value[Kind] === kind;\n}\n/** `[Kind-Only]` Returns true if the given value is TLiteral<string> */\nexport function IsLiteralString(value) {\n    return IsLiteral(value) && ValueGuard.IsString(value.const);\n}\n/** `[Kind-Only]` Returns true if the given value is TLiteral<number> */\nexport function IsLiteralNumber(value) {\n    return IsLiteral(value) && ValueGuard.IsNumber(value.const);\n}\n/** `[Kind-Only]` Returns true if the given value is TLiteral<boolean> */\nexport function IsLiteralBoolean(value) {\n    return IsLiteral(value) && ValueGuard.IsBoolean(value.const);\n}\n/** `[Kind-Only]` Returns true if the given value is TLiteralValue */\nexport function IsLiteralValue(value) {\n    return ValueGuard.IsBoolean(value) || ValueGuard.IsNumber(value) || ValueGuard.IsString(value);\n}\n/** `[Kind-Only]` Returns true if the given value is TLiteral */\nexport function IsLiteral(value) {\n    return IsKindOf(value, 'Literal');\n}\n/** `[Kind-Only]` Returns true if the given value is a TMappedKey */\nexport function IsMappedKey(value) {\n    return IsKindOf(value, 'MappedKey');\n}\n/** `[Kind-Only]` Returns true if the given value is TMappedResult */\nexport function IsMappedResult(value) {\n    return IsKindOf(value, 'MappedResult');\n}\n/** `[Kind-Only]` Returns true if the given value is TNever */\nexport function IsNever(value) {\n    return IsKindOf(value, 'Never');\n}\n/** `[Kind-Only]` Returns true if the given value is TNot */\nexport function IsNot(value) {\n    return IsKindOf(value, 'Not');\n}\n/** `[Kind-Only]` Returns true if the given value is TNull */\nexport function IsNull(value) {\n    return IsKindOf(value, 'Null');\n}\n/** `[Kind-Only]` Returns true if the given value is TNumber */\nexport function IsNumber(value) {\n    return IsKindOf(value, 'Number');\n}\n/** `[Kind-Only]` Returns true if the given value is TObject */\nexport function IsObject(value) {\n    return IsKindOf(value, 'Object');\n}\n/** `[Kind-Only]` Returns true if the given value is TPromise */\nexport function IsPromise(value) {\n    return IsKindOf(value, 'Promise');\n}\n/** `[Kind-Only]` Returns true if the given value is TRecord */\nexport function IsRecord(value) {\n    return IsKindOf(value, 'Record');\n}\n/** `[Kind-Only]` Returns true if this value is TRecursive */\nexport function IsRecursive(value) {\n    return ValueGuard.IsObject(value) && Hint in value && value[Hint] === 'Recursive';\n}\n/** `[Kind-Only]` Returns true if the given value is TRef */\nexport function IsRef(value) {\n    return IsKindOf(value, 'Ref');\n}\n/** `[Kind-Only]` Returns true if the given value is TRegExp */\nexport function IsRegExp(value) {\n    return IsKindOf(value, 'RegExp');\n}\n/** `[Kind-Only]` Returns true if the given value is TString */\nexport function IsString(value) {\n    return IsKindOf(value, 'String');\n}\n/** `[Kind-Only]` Returns true if the given value is TSymbol */\nexport function IsSymbol(value) {\n    return IsKindOf(value, 'Symbol');\n}\n/** `[Kind-Only]` Returns true if the given value is TTemplateLiteral */\nexport function IsTemplateLiteral(value) {\n    return IsKindOf(value, 'TemplateLiteral');\n}\n/** `[Kind-Only]` Returns true if the given value is TThis */\nexport function IsThis(value) {\n    return IsKindOf(value, 'This');\n}\n/** `[Kind-Only]` Returns true of this value is TTransform */\nexport function IsTransform(value) {\n    return ValueGuard.IsObject(value) && TransformKind in value;\n}\n/** `[Kind-Only]` Returns true if the given value is TTuple */\nexport function IsTuple(value) {\n    return IsKindOf(value, 'Tuple');\n}\n/** `[Kind-Only]` Returns true if the given value is TUndefined */\nexport function IsUndefined(value) {\n    return IsKindOf(value, 'Undefined');\n}\n/** `[Kind-Only]` Returns true if the given value is TUnion */\nexport function IsUnion(value) {\n    return IsKindOf(value, 'Union');\n}\n/** `[Kind-Only]` Returns true if the given value is TUint8Array */\nexport function IsUint8Array(value) {\n    return IsKindOf(value, 'Uint8Array');\n}\n/** `[Kind-Only]` Returns true if the given value is TUnknown */\nexport function IsUnknown(value) {\n    return IsKindOf(value, 'Unknown');\n}\n/** `[Kind-Only]` Returns true if the given value is a raw TUnsafe */\nexport function IsUnsafe(value) {\n    return IsKindOf(value, 'Unsafe');\n}\n/** `[Kind-Only]` Returns true if the given value is TVoid */\nexport function IsVoid(value) {\n    return IsKindOf(value, 'Void');\n}\n/** `[Kind-Only]` Returns true if the given value is TKind */\nexport function IsKind(value) {\n    return ValueGuard.IsObject(value) && Kind in value && ValueGuard.IsString(value[Kind]);\n}\n/** `[Kind-Only]` Returns true if the given value is TSchema */\nexport function IsSchema(value) {\n    // prettier-ignore\n    return (IsAny(value) ||\n        IsArgument(value) ||\n        IsArray(value) ||\n        IsBoolean(value) ||\n        IsBigInt(value) ||\n        IsAsyncIterator(value) ||\n        IsComputed(value) ||\n        IsConstructor(value) ||\n        IsDate(value) ||\n        IsFunction(value) ||\n        IsInteger(value) ||\n        IsIntersect(value) ||\n        IsIterator(value) ||\n        IsLiteral(value) ||\n        IsMappedKey(value) ||\n        IsMappedResult(value) ||\n        IsNever(value) ||\n        IsNot(value) ||\n        IsNull(value) ||\n        IsNumber(value) ||\n        IsObject(value) ||\n        IsPromise(value) ||\n        IsRecord(value) ||\n        IsRef(value) ||\n        IsRegExp(value) ||\n        IsString(value) ||\n        IsSymbol(value) ||\n        IsTemplateLiteral(value) ||\n        IsThis(value) ||\n        IsTuple(value) ||\n        IsUndefined(value) ||\n        IsUnion(value) ||\n        IsUint8Array(value) ||\n        IsUnknown(value) ||\n        IsUnsafe(value) ||\n        IsVoid(value) ||\n        IsKind(value));\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 882, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/intersect/intersect-create.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsObject, IsSchema } from '../guard/kind.mjs';\n// ------------------------------------------------------------------\n// IntersectCreate\n// ------------------------------------------------------------------\n// prettier-ignore\nexport function IntersectCreate(T, options = {}) {\n    const allObjects = T.every((schema) => IsObject(schema));\n    const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties)\n        ? { unevaluatedProperties: options.unevaluatedProperties }\n        : {};\n    return CreateType((options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects\n        ? { ...clonedUnevaluatedProperties, [Kind]: 'Intersect', type: 'object', allOf: T }\n        : { ...clonedUnevaluatedProperties, [Kind]: 'Intersect', allOf: T }), options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;;AAKO,SAAS,gBAAgB,CAAC,EAAE,UAAU,CAAC,CAAC;IAC3C,MAAM,aAAa,EAAE,KAAK,CAAC,CAAC,SAAW,IAAA,6LAAQ,EAAC;IAChD,MAAM,8BAA8B,IAAA,6LAAQ,EAAC,QAAQ,qBAAqB,IACpE;QAAE,uBAAuB,QAAQ,qBAAqB;IAAC,IACvD,CAAC;IACP,OAAO,IAAA,gMAAU,EAAE,QAAQ,qBAAqB,KAAK,SAAS,IAAA,6LAAQ,EAAC,QAAQ,qBAAqB,KAAK,aACnG;QAAE,GAAG,2BAA2B;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAa,MAAM;QAAU,OAAO;IAAE,IAChF;QAAE,GAAG,2BAA2B;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAa,OAAO;IAAE,GAAI;AAC9E","ignoreList":[0]}},
    {"offset": {"line": 915, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/intersect/intersect.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Never } from '../never/index.mjs';\nimport { IntersectCreate } from './intersect-create.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsTransform } from '../guard/kind.mjs';\n/** `[Json]` Creates an evaluated Intersect type */\nexport function Intersect(types, options) {\n    if (types.length === 1)\n        return CreateType(types[0], options);\n    if (types.length === 0)\n        return Never(options);\n    if (types.some((schema) => IsTransform(schema)))\n        throw new Error('Cannot intersect transform types');\n    return IntersectCreate(types, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;;;AAEO,SAAS,UAAU,KAAK,EAAE,OAAO;IACpC,IAAI,MAAM,MAAM,KAAK,GACjB,OAAO,IAAA,gMAAU,EAAC,KAAK,CAAC,EAAE,EAAE;IAChC,IAAI,MAAM,MAAM,KAAK,GACjB,OAAO,IAAA,2LAAK,EAAC;IACjB,IAAI,MAAM,IAAI,CAAC,CAAC,SAAW,IAAA,gMAAW,EAAC,UACnC,MAAM,IAAI,MAAM;IACpB,OAAO,IAAA,uNAAe,EAAC,OAAO;AAClC","ignoreList":[0]}},
    {"offset": {"line": 940, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/union/union-create.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\nexport function UnionCreate(T, options) {\n    return CreateType({ [Kind]: 'Union', anyOf: T }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACO,SAAS,YAAY,CAAC,EAAE,OAAO;IAClC,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAS,OAAO;IAAE,GAAG;AACrD","ignoreList":[0]}},
    {"offset": {"line": 958, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/union/union.mjs"],"sourcesContent":["import { Never } from '../never/index.mjs';\nimport { CreateType } from '../create/type.mjs';\nimport { UnionCreate } from './union-create.mjs';\n/** `[Json]` Creates a Union type */\nexport function Union(types, options) {\n    // prettier-ignore\n    return (types.length === 0 ? Never(options) :\n        types.length === 1 ? CreateType(types[0], options) :\n            UnionCreate(types, options));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,SAAS,MAAM,KAAK,EAAE,OAAO;IAChC,kBAAkB;IAClB,OAAQ,MAAM,MAAM,KAAK,IAAI,IAAA,2LAAK,EAAC,WAC/B,MAAM,MAAM,KAAK,IAAI,IAAA,gMAAU,EAAC,KAAK,CAAC,EAAE,EAAE,WACtC,IAAA,2MAAW,EAAC,OAAO;AAC/B","ignoreList":[0]}},
    {"offset": {"line": 976, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/error/error.mjs"],"sourcesContent":["/** The base Error type thrown for all TypeBox exceptions  */\nexport class TypeBoxError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\n"],"names":[],"mappings":"AAAA,2DAA2D;;;;AACpD,MAAM,qBAAqB;IAC9B,YAAY,OAAO,CAAE;QACjB,KAAK,CAAC;IACV;AACJ","ignoreList":[0]}},
    {"offset": {"line": 989, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/ref/ref.mjs"],"sourcesContent":["import { TypeBoxError } from '../error/index.mjs';\nimport { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Ref type. The referenced type must contain a $id */\nexport function Ref(...args) {\n    const [$ref, options] = typeof args[0] === 'string' ? [args[0], args[1]] : [args[0].$id, args[1]];\n    if (typeof $ref !== 'string')\n        throw new TypeBoxError('Ref: $ref must be a string');\n    return CreateType({ [Kind]: 'Ref', $ref }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,SAAS,IAAI,GAAG,IAAI;IACvB,MAAM,CAAC,MAAM,QAAQ,GAAG,OAAO,IAAI,CAAC,EAAE,KAAK,WAAW;QAAC,IAAI,CAAC,EAAE;QAAE,IAAI,CAAC,EAAE;KAAC,GAAG;QAAC,IAAI,CAAC,EAAE,CAAC,GAAG;QAAE,IAAI,CAAC,EAAE;KAAC;IACjG,IAAI,OAAO,SAAS,UAChB,MAAM,IAAI,kMAAY,CAAC;IAC3B,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAO;IAAK,GAAG;AAC/C","ignoreList":[0]}},
    {"offset": {"line": 1017, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/awaited/awaited.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Computed } from '../computed/index.mjs';\nimport { Intersect } from '../intersect/index.mjs';\nimport { Union } from '../union/index.mjs';\nimport { Ref } from '../ref/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsIntersect, IsUnion, IsPromise, IsRef, IsComputed } from '../guard/kind.mjs';\n// prettier-ignore\nfunction FromComputed(target, parameters) {\n    return Computed('Awaited', [Computed(target, parameters)]);\n}\n// prettier-ignore\nfunction FromRef($ref) {\n    return Computed('Awaited', [Ref($ref)]);\n}\n// prettier-ignore\nfunction FromIntersect(types) {\n    return Intersect(FromRest(types));\n}\n// prettier-ignore\nfunction FromUnion(types) {\n    return Union(FromRest(types));\n}\n// prettier-ignore\nfunction FromPromise(type) {\n    return Awaited(type);\n}\n// prettier-ignore\nfunction FromRest(types) {\n    return types.map(type => Awaited(type));\n}\n/** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */\nexport function Awaited(type, options) {\n    return CreateType(IsComputed(type) ? FromComputed(type.target, type.parameters) : IsIntersect(type) ? FromIntersect(type.allOf) : IsUnion(type) ? FromUnion(type.anyOf) : IsPromise(type) ? FromPromise(type.item) : IsRef(type) ? FromRef(type.$ref) : type, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;;;;;AACA,kBAAkB;AAClB,SAAS,aAAa,MAAM,EAAE,UAAU;IACpC,OAAO,IAAA,oMAAQ,EAAC,WAAW;QAAC,IAAA,oMAAQ,EAAC,QAAQ;KAAY;AAC7D;AACA,kBAAkB;AAClB,SAAS,QAAQ,IAAI;IACjB,OAAO,IAAA,oMAAQ,EAAC,WAAW;QAAC,IAAA,qLAAG,EAAC;KAAM;AAC1C;AACA,kBAAkB;AAClB,SAAS,cAAc,KAAK;IACxB,OAAO,IAAA,uMAAS,EAAC,SAAS;AAC9B;AACA,kBAAkB;AAClB,SAAS,UAAU,KAAK;IACpB,OAAO,IAAA,2LAAK,EAAC,SAAS;AAC1B;AACA,kBAAkB;AAClB,SAAS,YAAY,IAAI;IACrB,OAAO,QAAQ;AACnB;AACA,kBAAkB;AAClB,SAAS,SAAS,KAAK;IACnB,OAAO,MAAM,GAAG,CAAC,CAAA,OAAQ,QAAQ;AACrC;AAEO,SAAS,QAAQ,IAAI,EAAE,OAAO;IACjC,OAAO,IAAA,gMAAU,EAAC,IAAA,+LAAU,EAAC,QAAQ,aAAa,KAAK,MAAM,EAAE,KAAK,UAAU,IAAI,IAAA,gMAAW,EAAC,QAAQ,cAAc,KAAK,KAAK,IAAI,IAAA,4LAAO,EAAC,QAAQ,UAAU,KAAK,KAAK,IAAI,IAAA,8LAAS,EAAC,QAAQ,YAAY,KAAK,IAAI,IAAI,IAAA,0LAAK,EAAC,QAAQ,QAAQ,KAAK,IAAI,IAAI,MAAM;AAClQ","ignoreList":[0]}},
    {"offset": {"line": 1071, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/bigint/bigint.mjs"],"sourcesContent":["import { Kind } from '../symbols/index.mjs';\nimport { CreateType } from '../create/index.mjs';\n/** `[JavaScript]` Creates a BigInt type */\nexport function BigInt(options) {\n    return CreateType({ [Kind]: 'BigInt', type: 'bigint' }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,OAAO,OAAO;IAC1B,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAU,MAAM;IAAS,GAAG;AAC5D","ignoreList":[0]}},
    {"offset": {"line": 1089, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/boolean/boolean.mjs"],"sourcesContent":["import { Kind } from '../symbols/index.mjs';\nimport { CreateType } from '../create/index.mjs';\n/** `[Json]` Creates a Boolean type */\nexport function Boolean(options) {\n    return CreateType({ [Kind]: 'Boolean', type: 'boolean' }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,QAAQ,OAAO;IAC3B,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAW,MAAM;IAAU,GAAG;AAC9D","ignoreList":[0]}},
    {"offset": {"line": 1107, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/discard/discard.mjs"],"sourcesContent":["function DiscardKey(value, key) {\n    const { [key]: _, ...rest } = value;\n    return rest;\n}\n/** Discards property keys from the given value. This function returns a shallow Clone. */\nexport function Discard(value, keys) {\n    return keys.reduce((acc, key) => DiscardKey(acc, key), value);\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,WAAW,KAAK,EAAE,GAAG;IAC1B,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,GAAG,MAAM,GAAG;IAC9B,OAAO;AACX;AAEO,SAAS,QAAQ,KAAK,EAAE,IAAI;IAC/B,OAAO,KAAK,MAAM,CAAC,CAAC,KAAK,MAAQ,WAAW,KAAK,MAAM;AAC3D","ignoreList":[0]}},
    {"offset": {"line": 1122, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/mapped/mapped-result.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n// prettier-ignore\nexport function MappedResult(properties) {\n    return CreateType({\n        [Kind]: 'MappedResult',\n        properties\n    });\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,aAAa,UAAU;IACnC,OAAO,IAAA,gMAAU,EAAC;QACd,CAAC,8LAAI,CAAC,EAAE;QACR;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1140, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs"],"sourcesContent":["import { MappedResult } from '../mapped/index.mjs';\nimport { Optional } from './optional.mjs';\n// prettier-ignore\nfunction FromProperties(P, F) {\n    const Acc = {};\n    for (const K2 of globalThis.Object.getOwnPropertyNames(P))\n        Acc[K2] = Optional(P[K2], F);\n    return Acc;\n}\n// prettier-ignore\nfunction FromMappedResult(R, F) {\n    return FromProperties(R.properties, F);\n}\n// prettier-ignore\nexport function OptionalFromMappedResult(R, F) {\n    const P = FromMappedResult(R, F);\n    return MappedResult(P);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACA,kBAAkB;AAClB,SAAS,eAAe,CAAC,EAAE,CAAC;IACxB,MAAM,MAAM,CAAC;IACb,KAAK,MAAM,MAAM,WAAW,MAAM,CAAC,mBAAmB,CAAC,GACnD,GAAG,CAAC,GAAG,GAAG,IAAA,oMAAQ,EAAC,CAAC,CAAC,GAAG,EAAE;IAC9B,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,iBAAiB,CAAC,EAAE,CAAC;IAC1B,OAAO,eAAe,EAAE,UAAU,EAAE;AACxC;AAEO,SAAS,yBAAyB,CAAC,EAAE,CAAC;IACzC,MAAM,IAAI,iBAAiB,GAAG;IAC9B,OAAO,IAAA,8MAAY,EAAC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 1166, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/optional/optional.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { OptionalKind } from '../symbols/index.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { OptionalFromMappedResult } from './optional-from-mapped-result.mjs';\nimport { IsMappedResult } from '../guard/kind.mjs';\nfunction RemoveOptional(schema) {\n    return CreateType(Discard(schema, [OptionalKind]));\n}\nfunction AddOptional(schema) {\n    return CreateType({ ...schema, [OptionalKind]: 'Optional' });\n}\n// prettier-ignore\nfunction OptionalWithFlag(schema, F) {\n    return (F === false\n        ? RemoveOptional(schema)\n        : AddOptional(schema));\n}\n/** `[Json]` Creates a Optional property */\nexport function Optional(schema, enable) {\n    const F = enable ?? true;\n    return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AACA,SAAS,eAAe,MAAM;IAC1B,OAAO,IAAA,gMAAU,EAAC,IAAA,iMAAO,EAAC,QAAQ;QAAC,sMAAY;KAAC;AACpD;AACA,SAAS,YAAY,MAAM;IACvB,OAAO,IAAA,gMAAU,EAAC;QAAE,GAAG,MAAM;QAAE,CAAC,sMAAY,CAAC,EAAE;IAAW;AAC9D;AACA,kBAAkB;AAClB,SAAS,iBAAiB,MAAM,EAAE,CAAC;IAC/B,OAAQ,MAAM,QACR,eAAe,UACf,YAAY;AACtB;AAEO,SAAS,SAAS,MAAM,EAAE,MAAM;IACnC,MAAM,IAAI,UAAU;IACpB,OAAO,IAAA,mMAAc,EAAC,UAAU,IAAA,gPAAwB,EAAC,QAAQ,KAAK,iBAAiB,QAAQ;AACnG","ignoreList":[0]}},
    {"offset": {"line": 1203, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs"],"sourcesContent":["import { OptionalKind } from '../symbols/index.mjs';\nimport { CreateType } from '../create/type.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport { Optional } from '../optional/index.mjs';\nimport { IntersectCreate } from './intersect-create.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsOptional, IsTransform } from '../guard/kind.mjs';\n// prettier-ignore\nfunction IsIntersectOptional(types) {\n    return types.every(left => IsOptional(left));\n}\n// prettier-ignore\nfunction RemoveOptionalFromType(type) {\n    return (Discard(type, [OptionalKind]));\n}\n// prettier-ignore\nfunction RemoveOptionalFromRest(types) {\n    return types.map(left => IsOptional(left) ? RemoveOptionalFromType(left) : left);\n}\n// prettier-ignore\nfunction ResolveIntersect(types, options) {\n    return (IsIntersectOptional(types)\n        ? Optional(IntersectCreate(RemoveOptionalFromRest(types), options))\n        : IntersectCreate(RemoveOptionalFromRest(types), options));\n}\n/** `[Json]` Creates an evaluated Intersect type */\nexport function IntersectEvaluated(types, options = {}) {\n    if (types.length === 1)\n        return CreateType(types[0], options);\n    if (types.length === 0)\n        return Never(options);\n    if (types.some((schema) => IsTransform(schema)))\n        throw new Error('Cannot intersect transform types');\n    return ResolveIntersect(types, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;;;;;;AACA,kBAAkB;AAClB,SAAS,oBAAoB,KAAK;IAC9B,OAAO,MAAM,KAAK,CAAC,CAAA,OAAQ,IAAA,+LAAU,EAAC;AAC1C;AACA,kBAAkB;AAClB,SAAS,uBAAuB,IAAI;IAChC,OAAQ,IAAA,iMAAO,EAAC,MAAM;QAAC,sMAAY;KAAC;AACxC;AACA,kBAAkB;AAClB,SAAS,uBAAuB,KAAK;IACjC,OAAO,MAAM,GAAG,CAAC,CAAA,OAAQ,IAAA,+LAAU,EAAC,QAAQ,uBAAuB,QAAQ;AAC/E;AACA,kBAAkB;AAClB,SAAS,iBAAiB,KAAK,EAAE,OAAO;IACpC,OAAQ,oBAAoB,SACtB,IAAA,oMAAQ,EAAC,IAAA,uNAAe,EAAC,uBAAuB,QAAQ,YACxD,IAAA,uNAAe,EAAC,uBAAuB,QAAQ;AACzD;AAEO,SAAS,mBAAmB,KAAK,EAAE,UAAU,CAAC,CAAC;IAClD,IAAI,MAAM,MAAM,KAAK,GACjB,OAAO,IAAA,gMAAU,EAAC,KAAK,CAAC,EAAE,EAAE;IAChC,IAAI,MAAM,MAAM,KAAK,GACjB,OAAO,IAAA,2LAAK,EAAC;IACjB,IAAI,MAAM,IAAI,CAAC,CAAC,SAAW,IAAA,gMAAW,EAAC,UACnC,MAAM,IAAI,MAAM;IACpB,OAAO,iBAAiB,OAAO;AACnC","ignoreList":[0]}},
    {"offset": {"line": 1252, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/union/union-evaluated.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { OptionalKind } from '../symbols/index.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport { Optional } from '../optional/index.mjs';\nimport { UnionCreate } from './union-create.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsOptional } from '../guard/kind.mjs';\n// prettier-ignore\nfunction IsUnionOptional(types) {\n    return types.some(type => IsOptional(type));\n}\n// prettier-ignore\nfunction RemoveOptionalFromRest(types) {\n    return types.map(left => IsOptional(left) ? RemoveOptionalFromType(left) : left);\n}\n// prettier-ignore\nfunction RemoveOptionalFromType(T) {\n    return (Discard(T, [OptionalKind]));\n}\n// prettier-ignore\nfunction ResolveUnion(types, options) {\n    const isOptional = IsUnionOptional(types);\n    return (isOptional\n        ? Optional(UnionCreate(RemoveOptionalFromRest(types), options))\n        : UnionCreate(RemoveOptionalFromRest(types), options));\n}\n/** `[Json]` Creates an evaluated Union type */\nexport function UnionEvaluated(T, options) {\n    // prettier-ignore\n    return (T.length === 1 ? CreateType(T[0], options) :\n        T.length === 0 ? Never(options) :\n            ResolveUnion(T, options));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;;;;;;AACA,kBAAkB;AAClB,SAAS,gBAAgB,KAAK;IAC1B,OAAO,MAAM,IAAI,CAAC,CAAA,OAAQ,IAAA,+LAAU,EAAC;AACzC;AACA,kBAAkB;AAClB,SAAS,uBAAuB,KAAK;IACjC,OAAO,MAAM,GAAG,CAAC,CAAA,OAAQ,IAAA,+LAAU,EAAC,QAAQ,uBAAuB,QAAQ;AAC/E;AACA,kBAAkB;AAClB,SAAS,uBAAuB,CAAC;IAC7B,OAAQ,IAAA,iMAAO,EAAC,GAAG;QAAC,sMAAY;KAAC;AACrC;AACA,kBAAkB;AAClB,SAAS,aAAa,KAAK,EAAE,OAAO;IAChC,MAAM,aAAa,gBAAgB;IACnC,OAAQ,aACF,IAAA,oMAAQ,EAAC,IAAA,2MAAW,EAAC,uBAAuB,QAAQ,YACpD,IAAA,2MAAW,EAAC,uBAAuB,QAAQ;AACrD;AAEO,SAAS,eAAe,CAAC,EAAE,OAAO;IACrC,kBAAkB;IAClB,OAAQ,EAAE,MAAM,KAAK,IAAI,IAAA,gMAAU,EAAC,CAAC,CAAC,EAAE,EAAE,WACtC,EAAE,MAAM,KAAK,IAAI,IAAA,2LAAK,EAAC,WACnB,aAAa,GAAG;AAC5B","ignoreList":[0]}},
    {"offset": {"line": 1300, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/template-literal/parse.mjs"],"sourcesContent":["import { TypeBoxError } from '../error/index.mjs';\n// ------------------------------------------------------------------\n// TemplateLiteralParserError\n// ------------------------------------------------------------------\nexport class TemplateLiteralParserError extends TypeBoxError {\n}\n// -------------------------------------------------------------------\n// Unescape\n//\n// Unescape for these control characters specifically. Note that this\n// function is only called on non union group content, and where we\n// still want to allow the user to embed control characters in that\n// content. For review.\n// -------------------------------------------------------------------\n// prettier-ignore\nfunction Unescape(pattern) {\n    return pattern\n        .replace(/\\\\\\$/g, '$')\n        .replace(/\\\\\\*/g, '*')\n        .replace(/\\\\\\^/g, '^')\n        .replace(/\\\\\\|/g, '|')\n        .replace(/\\\\\\(/g, '(')\n        .replace(/\\\\\\)/g, ')');\n}\n// -------------------------------------------------------------------\n// Control Characters\n// -------------------------------------------------------------------\nfunction IsNonEscaped(pattern, index, char) {\n    return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;\n}\nfunction IsOpenParen(pattern, index) {\n    return IsNonEscaped(pattern, index, '(');\n}\nfunction IsCloseParen(pattern, index) {\n    return IsNonEscaped(pattern, index, ')');\n}\nfunction IsSeparator(pattern, index) {\n    return IsNonEscaped(pattern, index, '|');\n}\n// -------------------------------------------------------------------\n// Control Groups\n// -------------------------------------------------------------------\nfunction IsGroup(pattern) {\n    if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))\n        return false;\n    let count = 0;\n    for (let index = 0; index < pattern.length; index++) {\n        if (IsOpenParen(pattern, index))\n            count += 1;\n        if (IsCloseParen(pattern, index))\n            count -= 1;\n        if (count === 0 && index !== pattern.length - 1)\n            return false;\n    }\n    return true;\n}\n// prettier-ignore\nfunction InGroup(pattern) {\n    return pattern.slice(1, pattern.length - 1);\n}\n// prettier-ignore\nfunction IsPrecedenceOr(pattern) {\n    let count = 0;\n    for (let index = 0; index < pattern.length; index++) {\n        if (IsOpenParen(pattern, index))\n            count += 1;\n        if (IsCloseParen(pattern, index))\n            count -= 1;\n        if (IsSeparator(pattern, index) && count === 0)\n            return true;\n    }\n    return false;\n}\n// prettier-ignore\nfunction IsPrecedenceAnd(pattern) {\n    for (let index = 0; index < pattern.length; index++) {\n        if (IsOpenParen(pattern, index))\n            return true;\n    }\n    return false;\n}\n// prettier-ignore\nfunction Or(pattern) {\n    let [count, start] = [0, 0];\n    const expressions = [];\n    for (let index = 0; index < pattern.length; index++) {\n        if (IsOpenParen(pattern, index))\n            count += 1;\n        if (IsCloseParen(pattern, index))\n            count -= 1;\n        if (IsSeparator(pattern, index) && count === 0) {\n            const range = pattern.slice(start, index);\n            if (range.length > 0)\n                expressions.push(TemplateLiteralParse(range));\n            start = index + 1;\n        }\n    }\n    const range = pattern.slice(start);\n    if (range.length > 0)\n        expressions.push(TemplateLiteralParse(range));\n    if (expressions.length === 0)\n        return { type: 'const', const: '' };\n    if (expressions.length === 1)\n        return expressions[0];\n    return { type: 'or', expr: expressions };\n}\n// prettier-ignore\nfunction And(pattern) {\n    function Group(value, index) {\n        if (!IsOpenParen(value, index))\n            throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);\n        let count = 0;\n        for (let scan = index; scan < value.length; scan++) {\n            if (IsOpenParen(value, scan))\n                count += 1;\n            if (IsCloseParen(value, scan))\n                count -= 1;\n            if (count === 0)\n                return [index, scan];\n        }\n        throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);\n    }\n    function Range(pattern, index) {\n        for (let scan = index; scan < pattern.length; scan++) {\n            if (IsOpenParen(pattern, scan))\n                return [index, scan];\n        }\n        return [index, pattern.length];\n    }\n    const expressions = [];\n    for (let index = 0; index < pattern.length; index++) {\n        if (IsOpenParen(pattern, index)) {\n            const [start, end] = Group(pattern, index);\n            const range = pattern.slice(start, end + 1);\n            expressions.push(TemplateLiteralParse(range));\n            index = end;\n        }\n        else {\n            const [start, end] = Range(pattern, index);\n            const range = pattern.slice(start, end);\n            if (range.length > 0)\n                expressions.push(TemplateLiteralParse(range));\n            index = end - 1;\n        }\n    }\n    return ((expressions.length === 0) ? { type: 'const', const: '' } :\n        (expressions.length === 1) ? expressions[0] :\n            { type: 'and', expr: expressions });\n}\n// ------------------------------------------------------------------\n// TemplateLiteralParse\n// ------------------------------------------------------------------\n/** Parses a pattern and returns an expression tree */\nexport function TemplateLiteralParse(pattern) {\n    // prettier-ignore\n    return (IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) :\n        IsPrecedenceOr(pattern) ? Or(pattern) :\n            IsPrecedenceAnd(pattern) ? And(pattern) :\n                { type: 'const', const: Unescape(pattern) });\n}\n// ------------------------------------------------------------------\n// TemplateLiteralParseExact\n// ------------------------------------------------------------------\n/** Parses a pattern and strips forward and trailing ^ and $ */\nexport function TemplateLiteralParseExact(pattern) {\n    return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1464, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/template-literal/finite.mjs"],"sourcesContent":["import { TemplateLiteralParseExact } from './parse.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\n// ------------------------------------------------------------------\n// TemplateLiteralFiniteError\n// ------------------------------------------------------------------\nexport class TemplateLiteralFiniteError extends TypeBoxError {\n}\n// ------------------------------------------------------------------\n// IsTemplateLiteralFiniteCheck\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsNumberExpression(expression) {\n    return (expression.type === 'or' &&\n        expression.expr.length === 2 &&\n        expression.expr[0].type === 'const' &&\n        expression.expr[0].const === '0' &&\n        expression.expr[1].type === 'const' &&\n        expression.expr[1].const === '[1-9][0-9]*');\n}\n// prettier-ignore\nfunction IsBooleanExpression(expression) {\n    return (expression.type === 'or' &&\n        expression.expr.length === 2 &&\n        expression.expr[0].type === 'const' &&\n        expression.expr[0].const === 'true' &&\n        expression.expr[1].type === 'const' &&\n        expression.expr[1].const === 'false');\n}\n// prettier-ignore\nfunction IsStringExpression(expression) {\n    return expression.type === 'const' && expression.const === '.*';\n}\n// ------------------------------------------------------------------\n// IsTemplateLiteralExpressionFinite\n// ------------------------------------------------------------------\n// prettier-ignore\nexport function IsTemplateLiteralExpressionFinite(expression) {\n    return (IsNumberExpression(expression) || IsStringExpression(expression) ? false :\n        IsBooleanExpression(expression) ? true :\n            (expression.type === 'and') ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) :\n                (expression.type === 'or') ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) :\n                    (expression.type === 'const') ? true :\n                        (() => { throw new TemplateLiteralFiniteError(`Unknown expression type`); })());\n}\n/** Returns true if this TemplateLiteral resolves to a finite set of values */\nexport function IsTemplateLiteralFinite(schema) {\n    const expression = TemplateLiteralParseExact(schema.pattern);\n    return IsTemplateLiteralExpressionFinite(expression);\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAIO,MAAM,mCAAmC,kMAAY;AAC5D;AACA,qEAAqE;AACrE,+BAA+B;AAC/B,qEAAqE;AACrE,kBAAkB;AAClB,SAAS,mBAAmB,UAAU;IAClC,OAAQ,WAAW,IAAI,KAAK,QACxB,WAAW,IAAI,CAAC,MAAM,KAAK,KAC3B,WAAW,IAAI,CAAC,EAAE,CAAC,IAAI,KAAK,WAC5B,WAAW,IAAI,CAAC,EAAE,CAAC,KAAK,KAAK,OAC7B,WAAW,IAAI,CAAC,EAAE,CAAC,IAAI,KAAK,WAC5B,WAAW,IAAI,CAAC,EAAE,CAAC,KAAK,KAAK;AACrC;AACA,kBAAkB;AAClB,SAAS,oBAAoB,UAAU;IACnC,OAAQ,WAAW,IAAI,KAAK,QACxB,WAAW,IAAI,CAAC,MAAM,KAAK,KAC3B,WAAW,IAAI,CAAC,EAAE,CAAC,IAAI,KAAK,WAC5B,WAAW,IAAI,CAAC,EAAE,CAAC,KAAK,KAAK,UAC7B,WAAW,IAAI,CAAC,EAAE,CAAC,IAAI,KAAK,WAC5B,WAAW,IAAI,CAAC,EAAE,CAAC,KAAK,KAAK;AACrC;AACA,kBAAkB;AAClB,SAAS,mBAAmB,UAAU;IAClC,OAAO,WAAW,IAAI,KAAK,WAAW,WAAW,KAAK,KAAK;AAC/D;AAKO,SAAS,kCAAkC,UAAU;IACxD,OAAQ,mBAAmB,eAAe,mBAAmB,cAAc,QACvE,oBAAoB,cAAc,OAC9B,AAAC,WAAW,IAAI,KAAK,QAAS,WAAW,IAAI,CAAC,KAAK,CAAC,CAAC,OAAS,kCAAkC,SAC5F,AAAC,WAAW,IAAI,KAAK,OAAQ,WAAW,IAAI,CAAC,KAAK,CAAC,CAAC,OAAS,kCAAkC,SAC3F,AAAC,WAAW,IAAI,KAAK,UAAW,OAC5B,CAAC;QAAQ,MAAM,IAAI,2BAA2B,CAAC,uBAAuB,CAAC;IAAG,CAAC;AACnG;AAEO,SAAS,wBAAwB,MAAM;IAC1C,MAAM,aAAa,IAAA,6NAAyB,EAAC,OAAO,OAAO;IAC3D,OAAO,kCAAkC;AAC7C","ignoreList":[0]}},
    {"offset": {"line": 1506, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/template-literal/generate.mjs"],"sourcesContent":["import { IsTemplateLiteralExpressionFinite } from './finite.mjs';\nimport { TemplateLiteralParseExact } from './parse.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\n// ------------------------------------------------------------------\n// TemplateLiteralGenerateError\n// ------------------------------------------------------------------\nexport class TemplateLiteralGenerateError extends TypeBoxError {\n}\n// ------------------------------------------------------------------\n// TemplateLiteralExpressionGenerate\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction* GenerateReduce(buffer) {\n    if (buffer.length === 1)\n        return yield* buffer[0];\n    for (const left of buffer[0]) {\n        for (const right of GenerateReduce(buffer.slice(1))) {\n            yield `${left}${right}`;\n        }\n    }\n}\n// prettier-ignore\nfunction* GenerateAnd(expression) {\n    return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));\n}\n// prettier-ignore\nfunction* GenerateOr(expression) {\n    for (const expr of expression.expr)\n        yield* TemplateLiteralExpressionGenerate(expr);\n}\n// prettier-ignore\nfunction* GenerateConst(expression) {\n    return yield expression.const;\n}\nexport function* TemplateLiteralExpressionGenerate(expression) {\n    return expression.type === 'and'\n        ? yield* GenerateAnd(expression)\n        : expression.type === 'or'\n            ? yield* GenerateOr(expression)\n            : expression.type === 'const'\n                ? yield* GenerateConst(expression)\n                : (() => {\n                    throw new TemplateLiteralGenerateError('Unknown expression');\n                })();\n}\n/** Generates a tuple of strings from the given TemplateLiteral. Returns an empty tuple if infinite. */\nexport function TemplateLiteralGenerate(schema) {\n    const expression = TemplateLiteralParseExact(schema.pattern);\n    // prettier-ignore\n    return (IsTemplateLiteralExpressionFinite(expression)\n        ? [...TemplateLiteralExpressionGenerate(expression)]\n        : []);\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;AAIO,MAAM,qCAAqC,kMAAY;AAC9D;AACA,qEAAqE;AACrE,oCAAoC;AACpC,qEAAqE;AACrE,kBAAkB;AAClB,UAAU,eAAe,MAAM;IAC3B,IAAI,OAAO,MAAM,KAAK,GAClB,OAAO,OAAO,MAAM,CAAC,EAAE;IAC3B,KAAK,MAAM,QAAQ,MAAM,CAAC,EAAE,CAAE;QAC1B,KAAK,MAAM,SAAS,eAAe,OAAO,KAAK,CAAC,IAAK;YACjD,MAAM,GAAG,OAAO,OAAO;QAC3B;IACJ;AACJ;AACA,kBAAkB;AAClB,UAAU,YAAY,UAAU;IAC5B,OAAO,OAAO,eAAe,WAAW,IAAI,CAAC,GAAG,CAAC,CAAC,OAAS;eAAI,kCAAkC;SAAM;AAC3G;AACA,kBAAkB;AAClB,UAAU,WAAW,UAAU;IAC3B,KAAK,MAAM,QAAQ,WAAW,IAAI,CAC9B,OAAO,kCAAkC;AACjD;AACA,kBAAkB;AAClB,UAAU,cAAc,UAAU;IAC9B,OAAO,MAAM,WAAW,KAAK;AACjC;AACO,UAAU,kCAAkC,UAAU;IACzD,OAAO,WAAW,IAAI,KAAK,QACrB,OAAO,YAAY,cACnB,WAAW,IAAI,KAAK,OAChB,OAAO,WAAW,cAClB,WAAW,IAAI,KAAK,UAChB,OAAO,cAAc,cACrB,CAAC;QACC,MAAM,IAAI,6BAA6B;IAC3C,CAAC;AACjB;AAEO,SAAS,wBAAwB,MAAM;IAC1C,MAAM,aAAa,IAAA,6NAAyB,EAAC,OAAO,OAAO;IAC3D,kBAAkB;IAClB,OAAQ,IAAA,sOAAiC,EAAC,cACpC;WAAI,kCAAkC;KAAY,GAClD,EAAE;AACZ","ignoreList":[0]}},
    {"offset": {"line": 1564, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs"],"sourcesContent":["import { TemplateLiteralGenerate } from '../template-literal/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsTemplateLiteral, IsUnion, IsLiteral, IsNumber, IsInteger } from '../guard/kind.mjs';\n// prettier-ignore\nfunction FromTemplateLiteral(templateLiteral) {\n    const keys = TemplateLiteralGenerate(templateLiteral);\n    return keys.map(key => key.toString());\n}\n// prettier-ignore\nfunction FromUnion(types) {\n    const result = [];\n    for (const type of types)\n        result.push(...IndexPropertyKeys(type));\n    return result;\n}\n// prettier-ignore\nfunction FromLiteral(literalValue) {\n    return ([literalValue.toString()] // TS 5.4 observes TLiteralValue as not having a toString()\n    );\n}\n/** Returns a tuple of PropertyKeys derived from the given TSchema */\n// prettier-ignore\nexport function IndexPropertyKeys(type) {\n    return [...new Set((IsTemplateLiteral(type) ? FromTemplateLiteral(type) :\n            IsUnion(type) ? FromUnion(type.anyOf) :\n                IsLiteral(type) ? FromLiteral(type.const) :\n                    IsNumber(type) ? ['[number]'] :\n                        IsInteger(type) ? ['[number]'] :\n                            []))];\n}\n"],"names":[],"mappings":";;;;AAAA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;AACA,kBAAkB;AAClB,SAAS,oBAAoB,eAAe;IACxC,MAAM,OAAO,IAAA,8NAAuB,EAAC;IACrC,OAAO,KAAK,GAAG,CAAC,CAAA,MAAO,IAAI,QAAQ;AACvC;AACA,kBAAkB;AAClB,SAAS,UAAU,KAAK;IACpB,MAAM,SAAS,EAAE;IACjB,KAAK,MAAM,QAAQ,MACf,OAAO,IAAI,IAAI,kBAAkB;IACrC,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,YAAY,YAAY;IAC7B,OAAQ;QAAC,aAAa,QAAQ;KAAG,CAAC,2DAA2D;;AAEjG;AAGO,SAAS,kBAAkB,IAAI;IAClC,OAAO;WAAI,IAAI,IAAK,IAAA,sMAAiB,EAAC,QAAQ,oBAAoB,QAC1D,IAAA,4LAAO,EAAC,QAAQ,UAAU,KAAK,KAAK,IAChC,IAAA,8LAAS,EAAC,QAAQ,YAAY,KAAK,KAAK,IACpC,IAAA,6LAAQ,EAAC,QAAQ;YAAC;SAAW,GACzB,IAAA,8LAAS,EAAC,QAAQ;YAAC;SAAW,GAC1B,EAAE;KAAG;AACjC","ignoreList":[0]}},
    {"offset": {"line": 1606, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs"],"sourcesContent":["import { Index } from './indexed.mjs';\nimport { MappedResult } from '../mapped/index.mjs';\nimport { Clone } from '../clone/value.mjs';\n// prettier-ignore\nfunction MappedIndexPropertyKey(type, key, options) {\n    return { [key]: Index(type, [key], Clone(options)) };\n}\n// prettier-ignore\nfunction MappedIndexPropertyKeys(type, propertyKeys, options) {\n    return propertyKeys.reduce((result, left) => {\n        return { ...result, ...MappedIndexPropertyKey(type, left, options) };\n    }, {});\n}\n// prettier-ignore\nfunction MappedIndexProperties(type, mappedKey, options) {\n    return MappedIndexPropertyKeys(type, mappedKey.keys, options);\n}\n// prettier-ignore\nexport function IndexFromMappedKey(type, mappedKey, options) {\n    const properties = MappedIndexProperties(type, mappedKey, options);\n    return MappedResult(properties);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACA,kBAAkB;AAClB,SAAS,uBAAuB,IAAI,EAAE,GAAG,EAAE,OAAO;IAC9C,OAAO;QAAE,CAAC,IAAI,EAAE,IAAA,+LAAK,EAAC,MAAM;YAAC;SAAI,EAAE,IAAA,2LAAK,EAAC;IAAU;AACvD;AACA,kBAAkB;AAClB,SAAS,wBAAwB,IAAI,EAAE,YAAY,EAAE,OAAO;IACxD,OAAO,aAAa,MAAM,CAAC,CAAC,QAAQ;QAChC,OAAO;YAAE,GAAG,MAAM;YAAE,GAAG,uBAAuB,MAAM,MAAM,QAAQ;QAAC;IACvE,GAAG,CAAC;AACR;AACA,kBAAkB;AAClB,SAAS,sBAAsB,IAAI,EAAE,SAAS,EAAE,OAAO;IACnD,OAAO,wBAAwB,MAAM,UAAU,IAAI,EAAE;AACzD;AAEO,SAAS,mBAAmB,IAAI,EAAE,SAAS,EAAE,OAAO;IACvD,MAAM,aAAa,sBAAsB,MAAM,WAAW;IAC1D,OAAO,IAAA,8MAAY,EAAC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 1645, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs"],"sourcesContent":["import { MappedResult } from '../mapped/index.mjs';\nimport { IndexPropertyKeys } from './indexed-property-keys.mjs';\nimport { Index } from './index.mjs';\n// prettier-ignore\nfunction FromProperties(type, properties, options) {\n    const result = {};\n    for (const K2 of Object.getOwnPropertyNames(properties)) {\n        result[K2] = Index(type, IndexPropertyKeys(properties[K2]), options);\n    }\n    return result;\n}\n// prettier-ignore\nfunction FromMappedResult(type, mappedResult, options) {\n    return FromProperties(type, mappedResult.properties, options);\n}\n// prettier-ignore\nexport function IndexFromMappedResult(type, mappedResult, options) {\n    const properties = FromMappedResult(type, mappedResult, options);\n    return MappedResult(properties);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACA,kBAAkB;AAClB,SAAS,eAAe,IAAI,EAAE,UAAU,EAAE,OAAO;IAC7C,MAAM,SAAS,CAAC;IAChB,KAAK,MAAM,MAAM,OAAO,mBAAmB,CAAC,YAAa;QACrD,MAAM,CAAC,GAAG,GAAG,IAAA,+LAAK,EAAC,MAAM,IAAA,+NAAiB,EAAC,UAAU,CAAC,GAAG,GAAG;IAChE;IACA,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,iBAAiB,IAAI,EAAE,YAAY,EAAE,OAAO;IACjD,OAAO,eAAe,MAAM,aAAa,UAAU,EAAE;AACzD;AAEO,SAAS,sBAAsB,IAAI,EAAE,YAAY,EAAE,OAAO;IAC7D,MAAM,aAAa,iBAAiB,MAAM,cAAc;IACxD,OAAO,IAAA,8MAAY,EAAC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 1675, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/indexed/indexed.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\nimport { Computed } from '../computed/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport { IntersectEvaluated } from '../intersect/index.mjs';\nimport { UnionEvaluated } from '../union/index.mjs';\nimport { IndexPropertyKeys } from './indexed-property-keys.mjs';\nimport { IndexFromMappedKey } from './indexed-from-mapped-key.mjs';\nimport { IndexFromMappedResult } from './indexed-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsIntersect, IsObject, IsMappedKey, IsMappedResult, IsNever, IsSchema, IsTuple, IsUnion, IsRef } from '../guard/kind.mjs';\n// prettier-ignore\nfunction FromRest(types, key) {\n    return types.map(type => IndexFromPropertyKey(type, key));\n}\n// prettier-ignore\nfunction FromIntersectRest(types) {\n    return types.filter(type => !IsNever(type));\n}\n// prettier-ignore\nfunction FromIntersect(types, key) {\n    return (IntersectEvaluated(FromIntersectRest(FromRest(types, key))));\n}\n// prettier-ignore\nfunction FromUnionRest(types) {\n    return (types.some(L => IsNever(L))\n        ? []\n        : types);\n}\n// prettier-ignore\nfunction FromUnion(types, key) {\n    return (UnionEvaluated(FromUnionRest(FromRest(types, key))));\n}\n// prettier-ignore\nfunction FromTuple(types, key) {\n    return (key in types ? types[key] :\n        key === '[number]' ? UnionEvaluated(types) :\n            Never());\n}\n// prettier-ignore\nfunction FromArray(type, key) {\n    return (key === '[number]'\n        ? type\n        : Never());\n}\n// prettier-ignore\nfunction FromProperty(properties, propertyKey) {\n    return (propertyKey in properties ? properties[propertyKey] : Never());\n}\n// prettier-ignore\nexport function IndexFromPropertyKey(type, propertyKey) {\n    return (IsIntersect(type) ? FromIntersect(type.allOf, propertyKey) :\n        IsUnion(type) ? FromUnion(type.anyOf, propertyKey) :\n            IsTuple(type) ? FromTuple(type.items ?? [], propertyKey) :\n                IsArray(type) ? FromArray(type.items, propertyKey) :\n                    IsObject(type) ? FromProperty(type.properties, propertyKey) :\n                        Never());\n}\n// prettier-ignore\nexport function IndexFromPropertyKeys(type, propertyKeys) {\n    return propertyKeys.map(propertyKey => IndexFromPropertyKey(type, propertyKey));\n}\n// prettier-ignore\nfunction FromSchema(type, propertyKeys) {\n    return (UnionEvaluated(IndexFromPropertyKeys(type, propertyKeys)));\n}\n// prettier-ignore\nexport function IndexFromComputed(type, key) {\n    return Computed('Index', [type, key]);\n}\n/** `[Json]` Returns an Indexed property type for the given keys */\nexport function Index(type, key, options) {\n    // computed-type\n    if (IsRef(type) || IsRef(key)) {\n        const error = `Index types using Ref parameters require both Type and Key to be of TSchema`;\n        if (!IsSchema(type) || !IsSchema(key))\n            throw new TypeBoxError(error);\n        return Computed('Index', [type, key]);\n    }\n    // mapped-types\n    if (IsMappedResult(key))\n        return IndexFromMappedResult(type, key, options);\n    if (IsMappedKey(key))\n        return IndexFromMappedKey(type, key, options);\n    // prettier-ignore\n    return CreateType(IsSchema(key)\n        ? FromSchema(type, IndexPropertyKeys(key))\n        : FromSchema(type, key), options);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1776, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/sets/set.mjs"],"sourcesContent":["/** Returns true if element right is in the set of left */\n// prettier-ignore\nexport function SetIncludes(T, S) {\n    return T.includes(S);\n}\n/** Returns true if left is a subset of right */\nexport function SetIsSubset(T, S) {\n    return T.every((L) => SetIncludes(S, L));\n}\n/** Returns a distinct set of elements */\nexport function SetDistinct(T) {\n    return [...new Set(T)];\n}\n/** Returns the Intersect of the given sets */\nexport function SetIntersect(T, S) {\n    return T.filter((L) => S.includes(L));\n}\n/** Returns the Union of the given sets */\nexport function SetUnion(T, S) {\n    return [...T, ...S];\n}\n/** Returns the Complement by omitting elements in T that are in S */\n// prettier-ignore\nexport function SetComplement(T, S) {\n    return T.filter(L => !S.includes(L));\n}\n// prettier-ignore\nfunction SetIntersectManyResolve(T, Init) {\n    return T.reduce((Acc, L) => {\n        return SetIntersect(Acc, L);\n    }, Init);\n}\n// prettier-ignore\nexport function SetIntersectMany(T) {\n    return (T.length === 1\n        ? T[0]\n        // Use left to initialize the accumulator for resolve\n        : T.length > 1\n            ? SetIntersectManyResolve(T.slice(1), T[0])\n            : []);\n}\n/** Returns the Union of multiple sets */\nexport function SetUnionMany(T) {\n    const Acc = [];\n    for (const L of T)\n        Acc.push(...L);\n    return Acc;\n}\n"],"names":[],"mappings":"AAAA,wDAAwD,GACxD,kBAAkB;;;;;;;;;;;;;;;;;;;AACX,SAAS,YAAY,CAAC,EAAE,CAAC;IAC5B,OAAO,EAAE,QAAQ,CAAC;AACtB;AAEO,SAAS,YAAY,CAAC,EAAE,CAAC;IAC5B,OAAO,EAAE,KAAK,CAAC,CAAC,IAAM,YAAY,GAAG;AACzC;AAEO,SAAS,YAAY,CAAC;IACzB,OAAO;WAAI,IAAI,IAAI;KAAG;AAC1B;AAEO,SAAS,aAAa,CAAC,EAAE,CAAC;IAC7B,OAAO,EAAE,MAAM,CAAC,CAAC,IAAM,EAAE,QAAQ,CAAC;AACtC;AAEO,SAAS,SAAS,CAAC,EAAE,CAAC;IACzB,OAAO;WAAI;WAAM;KAAE;AACvB;AAGO,SAAS,cAAc,CAAC,EAAE,CAAC;IAC9B,OAAO,EAAE,MAAM,CAAC,CAAA,IAAK,CAAC,EAAE,QAAQ,CAAC;AACrC;AACA,kBAAkB;AAClB,SAAS,wBAAwB,CAAC,EAAE,IAAI;IACpC,OAAO,EAAE,MAAM,CAAC,CAAC,KAAK;QAClB,OAAO,aAAa,KAAK;IAC7B,GAAG;AACP;AAEO,SAAS,iBAAiB,CAAC;IAC9B,OAAQ,EAAE,MAAM,KAAK,IACf,CAAC,CAAC,EAAE,GAEJ,EAAE,MAAM,GAAG,IACP,wBAAwB,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,EAAE,IACxC,EAAE;AAChB;AAEO,SAAS,aAAa,CAAC;IAC1B,MAAM,MAAM,EAAE;IACd,KAAK,MAAM,KAAK,EACZ,IAAI,IAAI,IAAI;IAChB,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1836, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs"],"sourcesContent":["import { SetUnionMany, SetIntersectMany } from '../sets/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsIntersect, IsUnion, IsTuple, IsArray, IsObject, IsRecord } from '../guard/kind.mjs';\n// prettier-ignore\nfunction FromRest(types) {\n    const result = [];\n    for (const L of types)\n        result.push(KeyOfPropertyKeys(L));\n    return result;\n}\n// prettier-ignore\nfunction FromIntersect(types) {\n    const propertyKeysArray = FromRest(types);\n    const propertyKeys = SetUnionMany(propertyKeysArray);\n    return propertyKeys;\n}\n// prettier-ignore\nfunction FromUnion(types) {\n    const propertyKeysArray = FromRest(types);\n    const propertyKeys = SetIntersectMany(propertyKeysArray);\n    return propertyKeys;\n}\n// prettier-ignore\nfunction FromTuple(types) {\n    return types.map((_, indexer) => indexer.toString());\n}\n// prettier-ignore\nfunction FromArray(_) {\n    return (['[number]']);\n}\n// prettier-ignore\nfunction FromProperties(T) {\n    return (globalThis.Object.getOwnPropertyNames(T));\n}\n// ------------------------------------------------------------------\n// FromPatternProperties\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromPatternProperties(patternProperties) {\n    if (!includePatternProperties)\n        return [];\n    const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);\n    return patternPropertyKeys.map(key => {\n        return (key[0] === '^' && key[key.length - 1] === '$')\n            ? key.slice(1, key.length - 1)\n            : key;\n    });\n}\n/** Returns a tuple of PropertyKeys derived from the given TSchema. */\n// prettier-ignore\nexport function KeyOfPropertyKeys(type) {\n    return (IsIntersect(type) ? FromIntersect(type.allOf) :\n        IsUnion(type) ? FromUnion(type.anyOf) :\n            IsTuple(type) ? FromTuple(type.items ?? []) :\n                IsArray(type) ? FromArray(type.items) :\n                    IsObject(type) ? FromProperties(type.properties) :\n                        IsRecord(type) ? FromPatternProperties(type.patternProperties) :\n                            []);\n}\n// ----------------------------------------------------------------\n// KeyOfPattern\n// ----------------------------------------------------------------\nlet includePatternProperties = false;\n/** Returns a regular expression pattern derived from the given TSchema */\nexport function KeyOfPattern(schema) {\n    includePatternProperties = true;\n    const keys = KeyOfPropertyKeys(schema);\n    includePatternProperties = false;\n    const pattern = keys.map((key) => `(${key})`);\n    return `^(${pattern.join('|')})$`;\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;AACA,kBAAkB;AAClB,SAAS,SAAS,KAAK;IACnB,MAAM,SAAS,EAAE;IACjB,KAAK,MAAM,KAAK,MACZ,OAAO,IAAI,CAAC,kBAAkB;IAClC,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,cAAc,KAAK;IACxB,MAAM,oBAAoB,SAAS;IACnC,MAAM,eAAe,IAAA,+LAAY,EAAC;IAClC,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,UAAU,KAAK;IACpB,MAAM,oBAAoB,SAAS;IACnC,MAAM,eAAe,IAAA,mMAAgB,EAAC;IACtC,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,UAAU,KAAK;IACpB,OAAO,MAAM,GAAG,CAAC,CAAC,GAAG,UAAY,QAAQ,QAAQ;AACrD;AACA,kBAAkB;AAClB,SAAS,UAAU,CAAC;IAChB,OAAQ;QAAC;KAAW;AACxB;AACA,kBAAkB;AAClB,SAAS,eAAe,CAAC;IACrB,OAAQ,WAAW,MAAM,CAAC,mBAAmB,CAAC;AAClD;AACA,qEAAqE;AACrE,wBAAwB;AACxB,qEAAqE;AACrE,kBAAkB;AAClB,SAAS,sBAAsB,iBAAiB;IAC5C,IAAI,CAAC,0BACD,OAAO,EAAE;IACb,MAAM,sBAAsB,WAAW,MAAM,CAAC,mBAAmB,CAAC;IAClE,OAAO,oBAAoB,GAAG,CAAC,CAAA;QAC3B,OAAO,AAAC,GAAG,CAAC,EAAE,KAAK,OAAO,GAAG,CAAC,IAAI,MAAM,GAAG,EAAE,KAAK,MAC5C,IAAI,KAAK,CAAC,GAAG,IAAI,MAAM,GAAG,KAC1B;IACV;AACJ;AAGO,SAAS,kBAAkB,IAAI;IAClC,OAAQ,IAAA,gMAAW,EAAC,QAAQ,cAAc,KAAK,KAAK,IAChD,IAAA,4LAAO,EAAC,QAAQ,UAAU,KAAK,KAAK,IAChC,IAAA,4LAAO,EAAC,QAAQ,UAAU,KAAK,KAAK,IAAI,EAAE,IACtC,IAAA,4LAAO,EAAC,QAAQ,UAAU,KAAK,KAAK,IAChC,IAAA,6LAAQ,EAAC,QAAQ,eAAe,KAAK,UAAU,IAC3C,IAAA,6LAAQ,EAAC,QAAQ,sBAAsB,KAAK,iBAAiB,IACzD,EAAE;AAC9B;AACA,mEAAmE;AACnE,eAAe;AACf,mEAAmE;AACnE,IAAI,2BAA2B;AAExB,SAAS,aAAa,MAAM;IAC/B,2BAA2B;IAC3B,MAAM,OAAO,kBAAkB;IAC/B,2BAA2B;IAC3B,MAAM,UAAU,KAAK,GAAG,CAAC,CAAC,MAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;IAC5C,OAAO,CAAC,EAAE,EAAE,QAAQ,IAAI,CAAC,KAAK,EAAE,CAAC;AACrC","ignoreList":[0]}},
    {"offset": {"line": 1910, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/object/object.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsOptional } from '../guard/kind.mjs';\n/** Creates a RequiredArray derived from the given TProperties value. */\nfunction RequiredArray(properties) {\n    return globalThis.Object.keys(properties).filter((key) => !IsOptional(properties[key]));\n}\n/** `[Json]` Creates an Object type */\nfunction _Object(properties, options) {\n    const required = RequiredArray(properties);\n    const schema = required.length > 0 ? { [Kind]: 'Object', type: 'object', required, properties } : { [Kind]: 'Object', type: 'object', properties };\n    return CreateType(schema, options);\n}\n/** `[Json]` Creates an Object type */\nexport var Object = _Object;\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;;AACA,sEAAsE,GACtE,SAAS,cAAc,UAAU;IAC7B,OAAO,WAAW,MAAM,CAAC,IAAI,CAAC,YAAY,MAAM,CAAC,CAAC,MAAQ,CAAC,IAAA,+LAAU,EAAC,UAAU,CAAC,IAAI;AACzF;AACA,oCAAoC,GACpC,SAAS,QAAQ,UAAU,EAAE,OAAO;IAChC,MAAM,WAAW,cAAc;IAC/B,MAAM,SAAS,SAAS,MAAM,GAAG,IAAI;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAU,MAAM;QAAU;QAAU;IAAW,IAAI;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAU,MAAM;QAAU;IAAW;IACjJ,OAAO,IAAA,gMAAU,EAAC,QAAQ;AAC9B;AAEO,IAAI,SAAS","ignoreList":[0]}},
    {"offset": {"line": 1945, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/composite/composite.mjs"],"sourcesContent":["import { IntersectEvaluated } from '../intersect/index.mjs';\nimport { IndexFromPropertyKeys } from '../indexed/index.mjs';\nimport { KeyOfPropertyKeys } from '../keyof/index.mjs';\nimport { Object } from '../object/index.mjs';\nimport { SetDistinct } from '../sets/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsNever } from '../guard/kind.mjs';\n// prettier-ignore\nfunction CompositeKeys(T) {\n    const Acc = [];\n    for (const L of T)\n        Acc.push(...KeyOfPropertyKeys(L));\n    return SetDistinct(Acc);\n}\n// prettier-ignore\nfunction FilterNever(T) {\n    return T.filter(L => !IsNever(L));\n}\n// prettier-ignore\nfunction CompositeProperty(T, K) {\n    const Acc = [];\n    for (const L of T)\n        Acc.push(...IndexFromPropertyKeys(L, [K]));\n    return FilterNever(Acc);\n}\n// prettier-ignore\nfunction CompositeProperties(T, K) {\n    const Acc = {};\n    for (const L of K) {\n        Acc[L] = IntersectEvaluated(CompositeProperty(T, L));\n    }\n    return Acc;\n}\n// prettier-ignore\nexport function Composite(T, options) {\n    const K = CompositeKeys(T);\n    const P = CompositeProperties(T, K);\n    const R = Object(P, options);\n    return R;\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;;;;;AACA,kBAAkB;AAClB,SAAS,cAAc,CAAC;IACpB,MAAM,MAAM,EAAE;IACd,KAAK,MAAM,KAAK,EACZ,IAAI,IAAI,IAAI,IAAA,2NAAiB,EAAC;IAClC,OAAO,IAAA,8LAAW,EAAC;AACvB;AACA,kBAAkB;AAClB,SAAS,YAAY,CAAC;IAClB,OAAO,EAAE,MAAM,CAAC,CAAA,IAAK,CAAC,IAAA,4LAAO,EAAC;AAClC;AACA,kBAAkB;AAClB,SAAS,kBAAkB,CAAC,EAAE,CAAC;IAC3B,MAAM,MAAM,EAAE;IACd,KAAK,MAAM,KAAK,EACZ,IAAI,IAAI,IAAI,IAAA,+MAAqB,EAAC,GAAG;QAAC;KAAE;IAC5C,OAAO,YAAY;AACvB;AACA,kBAAkB;AAClB,SAAS,oBAAoB,CAAC,EAAE,CAAC;IAC7B,MAAM,MAAM,CAAC;IACb,KAAK,MAAM,KAAK,EAAG;QACf,GAAG,CAAC,EAAE,GAAG,IAAA,6NAAkB,EAAC,kBAAkB,GAAG;IACrD;IACA,OAAO;AACX;AAEO,SAAS,UAAU,CAAC,EAAE,OAAO;IAChC,MAAM,IAAI,cAAc;IACxB,MAAM,IAAI,oBAAoB,GAAG;IACjC,MAAM,IAAI,IAAA,8LAAM,EAAC,GAAG;IACpB,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 2000, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/date/date.mjs"],"sourcesContent":["import { Kind } from '../symbols/index.mjs';\nimport { CreateType } from '../create/type.mjs';\n/** `[JavaScript]` Creates a Date type */\nexport function Date(options) {\n    return CreateType({ [Kind]: 'Date', type: 'Date' }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,KAAK,OAAO;IACxB,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAQ,MAAM;IAAO,GAAG;AACxD","ignoreList":[0]}},
    {"offset": {"line": 2018, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/function/function.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Function type */\nexport function Function(parameters, returns, options) {\n    return CreateType({ [Kind]: 'Function', type: 'Function', parameters, returns }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,SAAS,UAAU,EAAE,OAAO,EAAE,OAAO;IACjD,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAY,MAAM;QAAY;QAAY;IAAQ,GAAG;AACrF","ignoreList":[0]}},
    {"offset": {"line": 2038, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/literal/literal.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Literal type */\nexport function Literal(value, options) {\n    return CreateType({\n        [Kind]: 'Literal',\n        const: value,\n        type: typeof value,\n    }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,QAAQ,KAAK,EAAE,OAAO;IAClC,OAAO,IAAA,gMAAU,EAAC;QACd,CAAC,8LAAI,CAAC,EAAE;QACR,OAAO;QACP,MAAM,OAAO;IACjB,GAAG;AACP","ignoreList":[0]}},
    {"offset": {"line": 2057, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/null/null.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Null type */\nexport function Null(options) {\n    return CreateType({ [Kind]: 'Null', type: 'null' }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,KAAK,OAAO;IACxB,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAQ,MAAM;IAAO,GAAG;AACxD","ignoreList":[0]}},
    {"offset": {"line": 2075, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/symbol/symbol.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Symbol type */\nexport function Symbol(options) {\n    return CreateType({ [Kind]: 'Symbol', type: 'symbol' }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,OAAO,OAAO;IAC1B,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAU,MAAM;IAAS,GAAG;AAC5D","ignoreList":[0]}},
    {"offset": {"line": 2093, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/tuple/tuple.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Tuple type */\nexport function Tuple(types, options) {\n    // prettier-ignore\n    return CreateType(types.length > 0 ?\n        { [Kind]: 'Tuple', type: 'array', items: types, additionalItems: false, minItems: types.length, maxItems: types.length } :\n        { [Kind]: 'Tuple', type: 'array', minItems: types.length, maxItems: types.length }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,MAAM,KAAK,EAAE,OAAO;IAChC,kBAAkB;IAClB,OAAO,IAAA,gMAAU,EAAC,MAAM,MAAM,GAAG,IAC7B;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAS,MAAM;QAAS,OAAO;QAAO,iBAAiB;QAAO,UAAU,MAAM,MAAM;QAAE,UAAU,MAAM,MAAM;IAAC,IACvH;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAS,MAAM;QAAS,UAAU,MAAM,MAAM;QAAE,UAAU,MAAM,MAAM;IAAC,GAAG;AAC5F","ignoreList":[0]}},
    {"offset": {"line": 2121, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs"],"sourcesContent":["import { MappedResult } from '../mapped/index.mjs';\nimport { Readonly } from './readonly.mjs';\n// prettier-ignore\nfunction FromProperties(K, F) {\n    const Acc = {};\n    for (const K2 of globalThis.Object.getOwnPropertyNames(K))\n        Acc[K2] = Readonly(K[K2], F);\n    return Acc;\n}\n// prettier-ignore\nfunction FromMappedResult(R, F) {\n    return FromProperties(R.properties, F);\n}\n// prettier-ignore\nexport function ReadonlyFromMappedResult(R, F) {\n    const P = FromMappedResult(R, F);\n    return MappedResult(P);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACA,kBAAkB;AAClB,SAAS,eAAe,CAAC,EAAE,CAAC;IACxB,MAAM,MAAM,CAAC;IACb,KAAK,MAAM,MAAM,WAAW,MAAM,CAAC,mBAAmB,CAAC,GACnD,GAAG,CAAC,GAAG,GAAG,IAAA,oMAAQ,EAAC,CAAC,CAAC,GAAG,EAAE;IAC9B,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,iBAAiB,CAAC,EAAE,CAAC;IAC1B,OAAO,eAAe,EAAE,UAAU,EAAE;AACxC;AAEO,SAAS,yBAAyB,CAAC,EAAE,CAAC;IACzC,MAAM,IAAI,iBAAiB,GAAG;IAC9B,OAAO,IAAA,8MAAY,EAAC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 2147, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/readonly/readonly.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { ReadonlyKind } from '../symbols/index.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { ReadonlyFromMappedResult } from './readonly-from-mapped-result.mjs';\nimport { IsMappedResult } from '../guard/kind.mjs';\nfunction RemoveReadonly(schema) {\n    return CreateType(Discard(schema, [ReadonlyKind]));\n}\nfunction AddReadonly(schema) {\n    return CreateType({ ...schema, [ReadonlyKind]: 'Readonly' });\n}\n// prettier-ignore\nfunction ReadonlyWithFlag(schema, F) {\n    return (F === false\n        ? RemoveReadonly(schema)\n        : AddReadonly(schema));\n}\n/** `[Json]` Creates a Readonly property */\nexport function Readonly(schema, enable) {\n    const F = enable ?? true;\n    return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AACA,SAAS,eAAe,MAAM;IAC1B,OAAO,IAAA,gMAAU,EAAC,IAAA,iMAAO,EAAC,QAAQ;QAAC,sMAAY;KAAC;AACpD;AACA,SAAS,YAAY,MAAM;IACvB,OAAO,IAAA,gMAAU,EAAC;QAAE,GAAG,MAAM;QAAE,CAAC,sMAAY,CAAC,EAAE;IAAW;AAC9D;AACA,kBAAkB;AAClB,SAAS,iBAAiB,MAAM,EAAE,CAAC;IAC/B,OAAQ,MAAM,QACR,eAAe,UACf,YAAY;AACtB;AAEO,SAAS,SAAS,MAAM,EAAE,MAAM;IACnC,MAAM,IAAI,UAAU;IACpB,OAAO,IAAA,mMAAc,EAAC,UAAU,IAAA,gPAAwB,EAAC,QAAQ,KAAK,iBAAiB,QAAQ;AACnG","ignoreList":[0]}},
    {"offset": {"line": 2184, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/undefined/undefined.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Undefined type */\nexport function Undefined(options) {\n    return CreateType({ [Kind]: 'Undefined', type: 'undefined' }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,UAAU,OAAO;IAC7B,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAa,MAAM;IAAY,GAAG;AAClE","ignoreList":[0]}},
    {"offset": {"line": 2202, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/uint8array/uint8array.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Uint8Array type */\nexport function Uint8Array(options) {\n    return CreateType({ [Kind]: 'Uint8Array', type: 'Uint8Array' }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,WAAW,OAAO;IAC9B,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAc,MAAM;IAAa,GAAG;AACpE","ignoreList":[0]}},
    {"offset": {"line": 2220, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/unknown/unknown.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates an Unknown type */\nexport function Unknown(options) {\n    return CreateType({ [Kind]: 'Unknown' }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,QAAQ,OAAO;IAC3B,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;IAAU,GAAG;AAC7C","ignoreList":[0]}},
    {"offset": {"line": 2237, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/const/const.mjs"],"sourcesContent":["import { Any } from '../any/index.mjs';\nimport { BigInt } from '../bigint/index.mjs';\nimport { Date } from '../date/index.mjs';\nimport { Function as FunctionType } from '../function/index.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { Null } from '../null/index.mjs';\nimport { Object } from '../object/index.mjs';\nimport { Symbol } from '../symbol/index.mjs';\nimport { Tuple } from '../tuple/index.mjs';\nimport { Readonly } from '../readonly/index.mjs';\nimport { Undefined } from '../undefined/index.mjs';\nimport { Uint8Array } from '../uint8array/index.mjs';\nimport { Unknown } from '../unknown/index.mjs';\nimport { CreateType } from '../create/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsNumber, IsBigInt, IsUint8Array, IsDate, IsIterator, IsObject, IsAsyncIterator, IsFunction, IsUndefined, IsNull, IsSymbol, IsBoolean, IsString } from '../guard/value.mjs';\n// prettier-ignore\nfunction FromArray(T) {\n    return T.map(L => FromValue(L, false));\n}\n// prettier-ignore\nfunction FromProperties(value) {\n    const Acc = {};\n    for (const K of globalThis.Object.getOwnPropertyNames(value))\n        Acc[K] = Readonly(FromValue(value[K], false));\n    return Acc;\n}\nfunction ConditionalReadonly(T, root) {\n    return (root === true ? T : Readonly(T));\n}\n// prettier-ignore\nfunction FromValue(value, root) {\n    return (IsAsyncIterator(value) ? ConditionalReadonly(Any(), root) :\n        IsIterator(value) ? ConditionalReadonly(Any(), root) :\n            IsArray(value) ? Readonly(Tuple(FromArray(value))) :\n                IsUint8Array(value) ? Uint8Array() :\n                    IsDate(value) ? Date() :\n                        IsObject(value) ? ConditionalReadonly(Object(FromProperties(value)), root) :\n                            IsFunction(value) ? ConditionalReadonly(FunctionType([], Unknown()), root) :\n                                IsUndefined(value) ? Undefined() :\n                                    IsNull(value) ? Null() :\n                                        IsSymbol(value) ? Symbol() :\n                                            IsBigInt(value) ? BigInt() :\n                                                IsNumber(value) ? Literal(value) :\n                                                    IsBoolean(value) ? Literal(value) :\n                                                        IsString(value) ? Literal(value) :\n                                                            Object({}));\n}\n/** `[JavaScript]` Creates a readonly const type from the given value. */\nexport function Const(T, options) {\n    return CreateType(FromValue(T, true), options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,aAAa;AACb,qEAAqE;AACrE;;;;;;;;;;;;;;;;AACA,kBAAkB;AAClB,SAAS,UAAU,CAAC;IAChB,OAAO,EAAE,GAAG,CAAC,CAAA,IAAK,UAAU,GAAG;AACnC;AACA,kBAAkB;AAClB,SAAS,eAAe,KAAK;IACzB,MAAM,MAAM,CAAC;IACb,KAAK,MAAM,KAAK,WAAW,MAAM,CAAC,mBAAmB,CAAC,OAClD,GAAG,CAAC,EAAE,GAAG,IAAA,oMAAQ,EAAC,UAAU,KAAK,CAAC,EAAE,EAAE;IAC1C,OAAO;AACX;AACA,SAAS,oBAAoB,CAAC,EAAE,IAAI;IAChC,OAAQ,SAAS,OAAO,IAAI,IAAA,oMAAQ,EAAC;AACzC;AACA,kBAAkB;AAClB,SAAS,UAAU,KAAK,EAAE,IAAI;IAC1B,OAAQ,IAAA,qMAAe,EAAC,SAAS,oBAAoB,IAAA,qLAAG,KAAI,QACxD,IAAA,gMAAU,EAAC,SAAS,oBAAoB,IAAA,qLAAG,KAAI,QAC3C,IAAA,6LAAO,EAAC,SAAS,IAAA,oMAAQ,EAAC,IAAA,2LAAK,EAAC,UAAU,WACtC,IAAA,kMAAY,EAAC,SAAS,IAAA,0MAAU,MAC5B,IAAA,4LAAM,EAAC,SAAS,IAAA,wLAAI,MAChB,IAAA,8LAAQ,EAAC,SAAS,oBAAoB,IAAA,8LAAM,EAAC,eAAe,SAAS,QACjE,IAAA,gMAAU,EAAC,SAAS,oBAAoB,IAAA,oMAAY,EAAC,EAAE,EAAE,IAAA,iMAAO,MAAK,QACjE,IAAA,iMAAW,EAAC,SAAS,IAAA,uMAAS,MAC1B,IAAA,4LAAM,EAAC,SAAS,IAAA,wLAAI,MAChB,IAAA,8LAAQ,EAAC,SAAS,IAAA,8LAAM,MACpB,IAAA,8LAAQ,EAAC,SAAS,IAAA,8LAAM,MACpB,IAAA,8LAAQ,EAAC,SAAS,IAAA,iMAAO,EAAC,SACtB,IAAA,+LAAS,EAAC,SAAS,IAAA,iMAAO,EAAC,SACvB,IAAA,8LAAQ,EAAC,SAAS,IAAA,iMAAO,EAAC,SACtB,IAAA,8LAAM,EAAC,CAAC;AACpE;AAEO,SAAS,MAAM,CAAC,EAAE,OAAO;IAC5B,OAAO,IAAA,gMAAU,EAAC,UAAU,GAAG,OAAO;AAC1C","ignoreList":[0]}},
    {"offset": {"line": 2298, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/constructor/constructor.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Constructor type */\nexport function Constructor(parameters, returns, options) {\n    return CreateType({ [Kind]: 'Constructor', type: 'Constructor', parameters, returns }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,YAAY,UAAU,EAAE,OAAO,EAAE,OAAO;IACpD,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAe,MAAM;QAAe;QAAY;IAAQ,GAAG;AAC3F","ignoreList":[0]}},
    {"offset": {"line": 2318, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs"],"sourcesContent":["import { Tuple } from '../tuple/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport * as KindGuard from '../guard/kind.mjs';\n/** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */\nexport function ConstructorParameters(schema, options) {\n    return (KindGuard.IsConstructor(schema) ? Tuple(schema.parameters, options) : Never(options));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,SAAS,sBAAsB,MAAM,EAAE,OAAO;IACjD,OAAQ,kMAAuB,CAAC,UAAU,IAAA,2LAAK,EAAC,OAAO,UAAU,EAAE,WAAW,IAAA,2LAAK,EAAC;AACxF","ignoreList":[0]}},
    {"offset": {"line": 2335, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/enum/enum.mjs"],"sourcesContent":["import { Literal } from '../literal/index.mjs';\nimport { Kind, Hint } from '../symbols/index.mjs';\nimport { Union } from '../union/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsUndefined } from '../guard/value.mjs';\n/** `[Json]` Creates a Enum type */\nexport function Enum(item, options) {\n    if (IsUndefined(item))\n        throw new Error('Enum undefined or empty');\n    const values1 = globalThis.Object.getOwnPropertyNames(item)\n        .filter((key) => isNaN(key))\n        .map((key) => item[key]);\n    const values2 = [...new Set(values1)];\n    const anyOf = values2.map((value) => Literal(value));\n    return Union(anyOf, { ...options, [Hint]: 'Enum' });\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA,qEAAqE;AACrE,aAAa;AACb,qEAAqE;AACrE;;;;;AAEO,SAAS,KAAK,IAAI,EAAE,OAAO;IAC9B,IAAI,IAAA,iMAAW,EAAC,OACZ,MAAM,IAAI,MAAM;IACpB,MAAM,UAAU,WAAW,MAAM,CAAC,mBAAmB,CAAC,MACjD,MAAM,CAAC,CAAC,MAAQ,MAAM,MACtB,GAAG,CAAC,CAAC,MAAQ,IAAI,CAAC,IAAI;IAC3B,MAAM,UAAU;WAAI,IAAI,IAAI;KAAS;IACrC,MAAM,QAAQ,QAAQ,GAAG,CAAC,CAAC,QAAU,IAAA,iMAAO,EAAC;IAC7C,OAAO,IAAA,2LAAK,EAAC,OAAO;QAAE,GAAG,OAAO;QAAE,CAAC,8LAAI,CAAC,EAAE;IAAO;AACrD","ignoreList":[0]}},
    {"offset": {"line": 2366, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/number/number.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Number type */\nexport function Number(options) {\n    return CreateType({ [Kind]: 'Number', type: 'number' }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,OAAO,OAAO;IAC1B,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAU,MAAM;IAAS,GAAG;AAC5D","ignoreList":[0]}},
    {"offset": {"line": 2384, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/string/string.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a String type */\nexport function String(options) {\n    return CreateType({ [Kind]: 'String', type: 'string' }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,OAAO,OAAO;IAC1B,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAU,MAAM;IAAS,GAAG;AAC5D","ignoreList":[0]}},
    {"offset": {"line": 2402, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/template-literal/union.mjs"],"sourcesContent":["import { UnionEvaluated } from '../union/index.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { TemplateLiteralGenerate } from './generate.mjs';\n/** Returns a Union from the given TemplateLiteral */\nexport function TemplateLiteralToUnion(schema) {\n    const R = TemplateLiteralGenerate(schema);\n    const L = R.map((S) => Literal(S));\n    return UnionEvaluated(L);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,SAAS,uBAAuB,MAAM;IACzC,MAAM,IAAI,IAAA,8NAAuB,EAAC;IAClC,MAAM,IAAI,EAAE,GAAG,CAAC,CAAC,IAAM,IAAA,iMAAO,EAAC;IAC/B,OAAO,IAAA,iNAAc,EAAC;AAC1B","ignoreList":[0]}},
    {"offset": {"line": 2421, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/patterns/patterns.mjs"],"sourcesContent":["export const PatternBoolean = '(true|false)';\nexport const PatternNumber = '(0|[1-9][0-9]*)';\nexport const PatternString = '(.*)';\nexport const PatternNever = '(?!.*)';\nexport const PatternBooleanExact = `^${PatternBoolean}$`;\nexport const PatternNumberExact = `^${PatternNumber}$`;\nexport const PatternStringExact = `^${PatternString}$`;\nexport const PatternNeverExact = `^${PatternNever}$`;\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAO,MAAM,iBAAiB;AACvB,MAAM,gBAAgB;AACtB,MAAM,gBAAgB;AACtB,MAAM,eAAe;AACrB,MAAM,sBAAsB,CAAC,CAAC,EAAE,eAAe,CAAC,CAAC;AACjD,MAAM,qBAAqB,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC;AAC/C,MAAM,qBAAqB,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC;AAC/C,MAAM,oBAAoB,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2451, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/guard/type.mjs"],"sourcesContent":["import * as ValueGuard from './value.mjs';\nimport { Kind, Hint, TransformKind, ReadonlyKind, OptionalKind } from '../symbols/index.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\nexport class TypeGuardUnknownTypeError extends TypeBoxError {\n}\nconst KnownTypes = [\n    'Argument',\n    'Any',\n    'Array',\n    'AsyncIterator',\n    'BigInt',\n    'Boolean',\n    'Computed',\n    'Constructor',\n    'Date',\n    'Enum',\n    'Function',\n    'Integer',\n    'Intersect',\n    'Iterator',\n    'Literal',\n    'MappedKey',\n    'MappedResult',\n    'Not',\n    'Null',\n    'Number',\n    'Object',\n    'Promise',\n    'Record',\n    'Ref',\n    'RegExp',\n    'String',\n    'Symbol',\n    'TemplateLiteral',\n    'This',\n    'Tuple',\n    'Undefined',\n    'Union',\n    'Uint8Array',\n    'Unknown',\n    'Void',\n];\nfunction IsPattern(value) {\n    try {\n        new RegExp(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction IsControlCharacterFree(value) {\n    if (!ValueGuard.IsString(value))\n        return false;\n    for (let i = 0; i < value.length; i++) {\n        const code = value.charCodeAt(i);\n        if ((code >= 7 && code <= 13) || code === 27 || code === 127) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction IsAdditionalProperties(value) {\n    return IsOptionalBoolean(value) || IsSchema(value);\n}\nfunction IsOptionalBigInt(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);\n}\nfunction IsOptionalNumber(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);\n}\nfunction IsOptionalBoolean(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);\n}\nfunction IsOptionalString(value) {\n    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);\n}\nfunction IsOptionalPattern(value) {\n    return ValueGuard.IsUndefined(value) || (ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value));\n}\nfunction IsOptionalFormat(value) {\n    return ValueGuard.IsUndefined(value) || (ValueGuard.IsString(value) && IsControlCharacterFree(value));\n}\nfunction IsOptionalSchema(value) {\n    return ValueGuard.IsUndefined(value) || IsSchema(value);\n}\n// ------------------------------------------------------------------\n// Modifiers\n// ------------------------------------------------------------------\n/** Returns true if this value has a Readonly symbol */\nexport function IsReadonly(value) {\n    return ValueGuard.IsObject(value) && value[ReadonlyKind] === 'Readonly';\n}\n/** Returns true if this value has a Optional symbol */\nexport function IsOptional(value) {\n    return ValueGuard.IsObject(value) && value[OptionalKind] === 'Optional';\n}\n// ------------------------------------------------------------------\n// Types\n// ------------------------------------------------------------------\n/** Returns true if the given value is TAny */\nexport function IsAny(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Any') &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TArgument */\nexport function IsArgument(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Argument') &&\n        ValueGuard.IsNumber(value.index));\n}\n/** Returns true if the given value is TArray */\nexport function IsArray(value) {\n    return (IsKindOf(value, 'Array') &&\n        value.type === 'array' &&\n        IsOptionalString(value.$id) &&\n        IsSchema(value.items) &&\n        IsOptionalNumber(value.minItems) &&\n        IsOptionalNumber(value.maxItems) &&\n        IsOptionalBoolean(value.uniqueItems) &&\n        IsOptionalSchema(value.contains) &&\n        IsOptionalNumber(value.minContains) &&\n        IsOptionalNumber(value.maxContains));\n}\n/** Returns true if the given value is TAsyncIterator */\nexport function IsAsyncIterator(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'AsyncIterator') &&\n        value.type === 'AsyncIterator' &&\n        IsOptionalString(value.$id) &&\n        IsSchema(value.items));\n}\n/** Returns true if the given value is TBigInt */\nexport function IsBigInt(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'BigInt') &&\n        value.type === 'bigint' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalBigInt(value.exclusiveMaximum) &&\n        IsOptionalBigInt(value.exclusiveMinimum) &&\n        IsOptionalBigInt(value.maximum) &&\n        IsOptionalBigInt(value.minimum) &&\n        IsOptionalBigInt(value.multipleOf));\n}\n/** Returns true if the given value is TBoolean */\nexport function IsBoolean(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Boolean') &&\n        value.type === 'boolean' &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TComputed */\nexport function IsComputed(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Computed') &&\n        ValueGuard.IsString(value.target) &&\n        ValueGuard.IsArray(value.parameters) &&\n        value.parameters.every((schema) => IsSchema(schema)));\n}\n/** Returns true if the given value is TConstructor */\nexport function IsConstructor(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Constructor') &&\n        value.type === 'Constructor' &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsArray(value.parameters) &&\n        value.parameters.every(schema => IsSchema(schema)) &&\n        IsSchema(value.returns));\n}\n/** Returns true if the given value is TDate */\nexport function IsDate(value) {\n    return (IsKindOf(value, 'Date') &&\n        value.type === 'Date' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalNumber(value.exclusiveMaximumTimestamp) &&\n        IsOptionalNumber(value.exclusiveMinimumTimestamp) &&\n        IsOptionalNumber(value.maximumTimestamp) &&\n        IsOptionalNumber(value.minimumTimestamp) &&\n        IsOptionalNumber(value.multipleOfTimestamp));\n}\n/** Returns true if the given value is TFunction */\nexport function IsFunction(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Function') &&\n        value.type === 'Function' &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsArray(value.parameters) &&\n        value.parameters.every(schema => IsSchema(schema)) &&\n        IsSchema(value.returns));\n}\n/** Returns true if the given value is TImport */\nexport function IsImport(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Import') &&\n        ValueGuard.HasPropertyKey(value, '$defs') &&\n        ValueGuard.IsObject(value.$defs) &&\n        IsProperties(value.$defs) &&\n        ValueGuard.HasPropertyKey(value, '$ref') &&\n        ValueGuard.IsString(value.$ref) &&\n        value.$ref in value.$defs // required\n    );\n}\n/** Returns true if the given value is TInteger */\nexport function IsInteger(value) {\n    return (IsKindOf(value, 'Integer') &&\n        value.type === 'integer' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalNumber(value.exclusiveMaximum) &&\n        IsOptionalNumber(value.exclusiveMinimum) &&\n        IsOptionalNumber(value.maximum) &&\n        IsOptionalNumber(value.minimum) &&\n        IsOptionalNumber(value.multipleOf));\n}\n/** Returns true if the given schema is TProperties */\nexport function IsProperties(value) {\n    // prettier-ignore\n    return (ValueGuard.IsObject(value) &&\n        Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema(schema)));\n}\n/** Returns true if the given value is TIntersect */\nexport function IsIntersect(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Intersect') &&\n        (ValueGuard.IsString(value.type) && value.type !== 'object' ? false : true) &&\n        ValueGuard.IsArray(value.allOf) &&\n        value.allOf.every(schema => IsSchema(schema) && !IsTransform(schema)) &&\n        IsOptionalString(value.type) &&\n        (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TIterator */\nexport function IsIterator(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Iterator') &&\n        value.type === 'Iterator' &&\n        IsOptionalString(value.$id) &&\n        IsSchema(value.items));\n}\n/** Returns true if the given value is a TKind with the given name. */\nexport function IsKindOf(value, kind) {\n    return ValueGuard.IsObject(value) && Kind in value && value[Kind] === kind;\n}\n/** Returns true if the given value is TLiteral<string> */\nexport function IsLiteralString(value) {\n    return IsLiteral(value) && ValueGuard.IsString(value.const);\n}\n/** Returns true if the given value is TLiteral<number> */\nexport function IsLiteralNumber(value) {\n    return IsLiteral(value) && ValueGuard.IsNumber(value.const);\n}\n/** Returns true if the given value is TLiteral<boolean> */\nexport function IsLiteralBoolean(value) {\n    return IsLiteral(value) && ValueGuard.IsBoolean(value.const);\n}\n/** Returns true if the given value is TLiteral */\nexport function IsLiteral(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Literal') &&\n        IsOptionalString(value.$id) && IsLiteralValue(value.const));\n}\n/** Returns true if the given value is a TLiteralValue */\nexport function IsLiteralValue(value) {\n    return ValueGuard.IsBoolean(value) || ValueGuard.IsNumber(value) || ValueGuard.IsString(value);\n}\n/** Returns true if the given value is a TMappedKey */\nexport function IsMappedKey(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'MappedKey') &&\n        ValueGuard.IsArray(value.keys) &&\n        value.keys.every(key => ValueGuard.IsNumber(key) || ValueGuard.IsString(key)));\n}\n/** Returns true if the given value is TMappedResult */\nexport function IsMappedResult(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'MappedResult') &&\n        IsProperties(value.properties));\n}\n/** Returns true if the given value is TNever */\nexport function IsNever(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Never') &&\n        ValueGuard.IsObject(value.not) &&\n        Object.getOwnPropertyNames(value.not).length === 0);\n}\n/** Returns true if the given value is TNot */\nexport function IsNot(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Not') &&\n        IsSchema(value.not));\n}\n/** Returns true if the given value is TNull */\nexport function IsNull(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Null') &&\n        value.type === 'null' &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TNumber */\nexport function IsNumber(value) {\n    return (IsKindOf(value, 'Number') &&\n        value.type === 'number' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalNumber(value.exclusiveMaximum) &&\n        IsOptionalNumber(value.exclusiveMinimum) &&\n        IsOptionalNumber(value.maximum) &&\n        IsOptionalNumber(value.minimum) &&\n        IsOptionalNumber(value.multipleOf));\n}\n/** Returns true if the given value is TObject */\nexport function IsObject(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Object') &&\n        value.type === 'object' &&\n        IsOptionalString(value.$id) &&\n        IsProperties(value.properties) &&\n        IsAdditionalProperties(value.additionalProperties) &&\n        IsOptionalNumber(value.minProperties) &&\n        IsOptionalNumber(value.maxProperties));\n}\n/** Returns true if the given value is TPromise */\nexport function IsPromise(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Promise') &&\n        value.type === 'Promise' &&\n        IsOptionalString(value.$id) &&\n        IsSchema(value.item));\n}\n/** Returns true if the given value is TRecord */\nexport function IsRecord(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Record') &&\n        value.type === 'object' &&\n        IsOptionalString(value.$id) &&\n        IsAdditionalProperties(value.additionalProperties) &&\n        ValueGuard.IsObject(value.patternProperties) &&\n        ((schema) => {\n            const keys = Object.getOwnPropertyNames(schema.patternProperties);\n            return (keys.length === 1 &&\n                IsPattern(keys[0]) &&\n                ValueGuard.IsObject(schema.patternProperties) &&\n                IsSchema(schema.patternProperties[keys[0]]));\n        })(value));\n}\n/** Returns true if this value is TRecursive */\nexport function IsRecursive(value) {\n    return ValueGuard.IsObject(value) && Hint in value && value[Hint] === 'Recursive';\n}\n/** Returns true if the given value is TRef */\nexport function IsRef(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Ref') &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsString(value.$ref));\n}\n/** Returns true if the given value is TRegExp */\nexport function IsRegExp(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'RegExp') &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsString(value.source) &&\n        ValueGuard.IsString(value.flags) &&\n        IsOptionalNumber(value.maxLength) &&\n        IsOptionalNumber(value.minLength));\n}\n/** Returns true if the given value is TString */\nexport function IsString(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'String') &&\n        value.type === 'string' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalNumber(value.minLength) &&\n        IsOptionalNumber(value.maxLength) &&\n        IsOptionalPattern(value.pattern) &&\n        IsOptionalFormat(value.format));\n}\n/** Returns true if the given value is TSymbol */\nexport function IsSymbol(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Symbol') &&\n        value.type === 'symbol' &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TTemplateLiteral */\nexport function IsTemplateLiteral(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'TemplateLiteral') &&\n        value.type === 'string' &&\n        ValueGuard.IsString(value.pattern) &&\n        value.pattern[0] === '^' &&\n        value.pattern[value.pattern.length - 1] === '$');\n}\n/** Returns true if the given value is TThis */\nexport function IsThis(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'This') &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsString(value.$ref));\n}\n/** Returns true of this value is TTransform */\nexport function IsTransform(value) {\n    return ValueGuard.IsObject(value) && TransformKind in value;\n}\n/** Returns true if the given value is TTuple */\nexport function IsTuple(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Tuple') &&\n        value.type === 'array' &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsNumber(value.minItems) &&\n        ValueGuard.IsNumber(value.maxItems) &&\n        value.minItems === value.maxItems &&\n        (( // empty\n        ValueGuard.IsUndefined(value.items) &&\n            ValueGuard.IsUndefined(value.additionalItems) &&\n            value.minItems === 0) || (ValueGuard.IsArray(value.items) &&\n            value.items.every(schema => IsSchema(schema)))));\n}\n/** Returns true if the given value is TUndefined */\nexport function IsUndefined(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Undefined') &&\n        value.type === 'undefined' &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TUnion<Literal<string | number>[]> */\nexport function IsUnionLiteral(value) {\n    return IsUnion(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));\n}\n/** Returns true if the given value is TUnion */\nexport function IsUnion(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Union') &&\n        IsOptionalString(value.$id) &&\n        ValueGuard.IsObject(value) &&\n        ValueGuard.IsArray(value.anyOf) &&\n        value.anyOf.every(schema => IsSchema(schema)));\n}\n/** Returns true if the given value is TUint8Array */\nexport function IsUint8Array(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Uint8Array') &&\n        value.type === 'Uint8Array' &&\n        IsOptionalString(value.$id) &&\n        IsOptionalNumber(value.minByteLength) &&\n        IsOptionalNumber(value.maxByteLength));\n}\n/** Returns true if the given value is TUnknown */\nexport function IsUnknown(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Unknown') &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is a raw TUnsafe */\nexport function IsUnsafe(value) {\n    return IsKindOf(value, 'Unsafe');\n}\n/** Returns true if the given value is TVoid */\nexport function IsVoid(value) {\n    // prettier-ignore\n    return (IsKindOf(value, 'Void') &&\n        value.type === 'void' &&\n        IsOptionalString(value.$id));\n}\n/** Returns true if the given value is TKind */\nexport function IsKind(value) {\n    return ValueGuard.IsObject(value) && Kind in value && ValueGuard.IsString(value[Kind]) && !KnownTypes.includes(value[Kind]);\n}\n/** Returns true if the given value is TSchema */\nexport function IsSchema(value) {\n    // prettier-ignore\n    return (ValueGuard.IsObject(value)) && (IsAny(value) ||\n        IsArgument(value) ||\n        IsArray(value) ||\n        IsBoolean(value) ||\n        IsBigInt(value) ||\n        IsAsyncIterator(value) ||\n        IsComputed(value) ||\n        IsConstructor(value) ||\n        IsDate(value) ||\n        IsFunction(value) ||\n        IsInteger(value) ||\n        IsIntersect(value) ||\n        IsIterator(value) ||\n        IsLiteral(value) ||\n        IsMappedKey(value) ||\n        IsMappedResult(value) ||\n        IsNever(value) ||\n        IsNot(value) ||\n        IsNull(value) ||\n        IsNumber(value) ||\n        IsObject(value) ||\n        IsPromise(value) ||\n        IsRecord(value) ||\n        IsRef(value) ||\n        IsRegExp(value) ||\n        IsString(value) ||\n        IsSymbol(value) ||\n        IsTemplateLiteral(value) ||\n        IsThis(value) ||\n        IsTuple(value) ||\n        IsUndefined(value) ||\n        IsUnion(value) ||\n        IsUint8Array(value) ||\n        IsUnknown(value) ||\n        IsUnsafe(value) ||\n        IsVoid(value) ||\n        IsKind(value));\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2852, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/extends/extends-check.mjs"],"sourcesContent":["import { Any } from '../any/index.mjs';\nimport { Function as FunctionType } from '../function/index.mjs';\nimport { Number } from '../number/index.mjs';\nimport { String } from '../string/index.mjs';\nimport { Unknown } from '../unknown/index.mjs';\nimport { TemplateLiteralToUnion } from '../template-literal/index.mjs';\nimport { PatternNumberExact, PatternStringExact } from '../patterns/index.mjs';\nimport { Kind, Hint } from '../symbols/index.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\nimport { TypeGuard, ValueGuard } from '../guard/index.mjs';\nexport class ExtendsResolverError extends TypeBoxError {\n}\nexport var ExtendsResult;\n(function (ExtendsResult) {\n    ExtendsResult[ExtendsResult[\"Union\"] = 0] = \"Union\";\n    ExtendsResult[ExtendsResult[\"True\"] = 1] = \"True\";\n    ExtendsResult[ExtendsResult[\"False\"] = 2] = \"False\";\n})(ExtendsResult || (ExtendsResult = {}));\n// ------------------------------------------------------------------\n// IntoBooleanResult\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IntoBooleanResult(result) {\n    return result === ExtendsResult.False ? result : ExtendsResult.True;\n}\n// ------------------------------------------------------------------\n// Throw\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction Throw(message) {\n    throw new ExtendsResolverError(message);\n}\n// ------------------------------------------------------------------\n// StructuralRight\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsStructuralRight(right) {\n    return (TypeGuard.IsNever(right) ||\n        TypeGuard.IsIntersect(right) ||\n        TypeGuard.IsUnion(right) ||\n        TypeGuard.IsUnknown(right) ||\n        TypeGuard.IsAny(right));\n}\n// prettier-ignore\nfunction StructuralRight(left, right) {\n    return (TypeGuard.IsNever(right) ? FromNeverRight(left, right) :\n        TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :\n            TypeGuard.IsUnion(right) ? FromUnionRight(left, right) :\n                TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) :\n                    TypeGuard.IsAny(right) ? FromAnyRight(left, right) :\n                        Throw('StructuralRight'));\n}\n// ------------------------------------------------------------------\n// Any\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromAnyRight(left, right) {\n    return ExtendsResult.True;\n}\n// prettier-ignore\nfunction FromAny(left, right) {\n    return (TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :\n        (TypeGuard.IsUnion(right) && right.anyOf.some((schema) => TypeGuard.IsAny(schema) || TypeGuard.IsUnknown(schema))) ? ExtendsResult.True :\n            TypeGuard.IsUnion(right) ? ExtendsResult.Union :\n                TypeGuard.IsUnknown(right) ? ExtendsResult.True :\n                    TypeGuard.IsAny(right) ? ExtendsResult.True :\n                        ExtendsResult.Union);\n}\n// ------------------------------------------------------------------\n// Array\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromArrayRight(left, right) {\n    return (TypeGuard.IsUnknown(left) ? ExtendsResult.False :\n        TypeGuard.IsAny(left) ? ExtendsResult.Union :\n            TypeGuard.IsNever(left) ? ExtendsResult.True :\n                ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromArray(left, right) {\n    return (TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True :\n        IsStructuralRight(right) ? StructuralRight(left, right) :\n            !TypeGuard.IsArray(right) ? ExtendsResult.False :\n                IntoBooleanResult(Visit(left.items, right.items)));\n}\n// ------------------------------------------------------------------\n// AsyncIterator\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromAsyncIterator(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        !TypeGuard.IsAsyncIterator(right) ? ExtendsResult.False :\n            IntoBooleanResult(Visit(left.items, right.items)));\n}\n// ------------------------------------------------------------------\n// BigInt\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromBigInt(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsBigInt(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Boolean\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromBooleanRight(left, right) {\n    return (TypeGuard.IsLiteralBoolean(left) ? ExtendsResult.True :\n        TypeGuard.IsBoolean(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromBoolean(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsBoolean(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Constructor\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromConstructor(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            !TypeGuard.IsConstructor(right) ? ExtendsResult.False :\n                left.parameters.length > right.parameters.length ? ExtendsResult.False :\n                    (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True)) ? ExtendsResult.False :\n                        IntoBooleanResult(Visit(left.returns, right.returns)));\n}\n// ------------------------------------------------------------------\n// Date\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromDate(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsDate(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Function\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromFunction(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            !TypeGuard.IsFunction(right) ? ExtendsResult.False :\n                left.parameters.length > right.parameters.length ? ExtendsResult.False :\n                    (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True)) ? ExtendsResult.False :\n                        IntoBooleanResult(Visit(left.returns, right.returns)));\n}\n// ------------------------------------------------------------------\n// Integer\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromIntegerRight(left, right) {\n    return (TypeGuard.IsLiteral(left) && ValueGuard.IsNumber(left.const) ? ExtendsResult.True :\n        TypeGuard.IsNumber(left) || TypeGuard.IsInteger(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromInteger(left, right) {\n    return (TypeGuard.IsInteger(right) || TypeGuard.IsNumber(right) ? ExtendsResult.True :\n        IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n                TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Intersect\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromIntersectRight(left, right) {\n    return right.allOf.every((schema) => Visit(left, schema) === ExtendsResult.True)\n        ? ExtendsResult.True\n        : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromIntersect(left, right) {\n    return left.allOf.some((schema) => Visit(schema, right) === ExtendsResult.True)\n        ? ExtendsResult.True\n        : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Iterator\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromIterator(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        !TypeGuard.IsIterator(right) ? ExtendsResult.False :\n            IntoBooleanResult(Visit(left.items, right.items)));\n}\n// ------------------------------------------------------------------\n// Literal\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromLiteral(left, right) {\n    return (TypeGuard.IsLiteral(right) && right.const === left.const ? ExtendsResult.True :\n        IsStructuralRight(right) ? StructuralRight(left, right) :\n            TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n                TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                    TypeGuard.IsString(right) ? FromStringRight(left, right) :\n                        TypeGuard.IsNumber(right) ? FromNumberRight(left, right) :\n                            TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) :\n                                TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) :\n                                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Never\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromNeverRight(left, right) {\n    return ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromNever(left, right) {\n    return ExtendsResult.True;\n}\n// ------------------------------------------------------------------\n// Not\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction UnwrapTNot(schema) {\n    let [current, depth] = [schema, 0];\n    while (true) {\n        if (!TypeGuard.IsNot(current))\n            break;\n        current = current.not;\n        depth += 1;\n    }\n    return depth % 2 === 0 ? current : Unknown();\n}\n// prettier-ignore\nfunction FromNot(left, right) {\n    // TypeScript has no concept of negated types, and attempts to correctly check the negated\n    // type at runtime would put TypeBox at odds with TypeScripts ability to statically infer\n    // the type. Instead we unwrap to either unknown or T and continue evaluating.\n    // prettier-ignore\n    return (TypeGuard.IsNot(left) ? Visit(UnwrapTNot(left), right) :\n        TypeGuard.IsNot(right) ? Visit(left, UnwrapTNot(right)) :\n            Throw('Invalid fallthrough for Not'));\n}\n// ------------------------------------------------------------------\n// Null\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromNull(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsNull(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Number\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromNumberRight(left, right) {\n    return (TypeGuard.IsLiteralNumber(left) ? ExtendsResult.True :\n        TypeGuard.IsNumber(left) || TypeGuard.IsInteger(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromNumber(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsInteger(right) || TypeGuard.IsNumber(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Object\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsObjectPropertyCount(schema, count) {\n    return Object.getOwnPropertyNames(schema.properties).length === count;\n}\n// prettier-ignore\nfunction IsObjectStringLike(schema) {\n    return IsObjectArrayLike(schema);\n}\n// prettier-ignore\nfunction IsObjectSymbolLike(schema) {\n    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && TypeGuard.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && ((TypeGuard.IsString(schema.properties.description.anyOf[0]) &&\n        TypeGuard.IsUndefined(schema.properties.description.anyOf[1])) || (TypeGuard.IsString(schema.properties.description.anyOf[1]) &&\n        TypeGuard.IsUndefined(schema.properties.description.anyOf[0]))));\n}\n// prettier-ignore\nfunction IsObjectNumberLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectBooleanLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectBigIntLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectDateLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectUint8ArrayLike(schema) {\n    return IsObjectArrayLike(schema);\n}\n// prettier-ignore\nfunction IsObjectFunctionLike(schema) {\n    const length = Number();\n    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === ExtendsResult.True);\n}\n// prettier-ignore\nfunction IsObjectConstructorLike(schema) {\n    return IsObjectPropertyCount(schema, 0);\n}\n// prettier-ignore\nfunction IsObjectArrayLike(schema) {\n    const length = Number();\n    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === ExtendsResult.True);\n}\n// prettier-ignore\nfunction IsObjectPromiseLike(schema) {\n    const then = FunctionType([Any()], Any());\n    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit(schema.properties['then'], then)) === ExtendsResult.True);\n}\n// ------------------------------------------------------------------\n// Property\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction Property(left, right) {\n    return (Visit(left, right) === ExtendsResult.False ? ExtendsResult.False :\n        TypeGuard.IsOptional(left) && !TypeGuard.IsOptional(right) ? ExtendsResult.False :\n            ExtendsResult.True);\n}\n// prettier-ignore\nfunction FromObjectRight(left, right) {\n    return (TypeGuard.IsUnknown(left) ? ExtendsResult.False :\n        TypeGuard.IsAny(left) ? ExtendsResult.Union : (TypeGuard.IsNever(left) ||\n            (TypeGuard.IsLiteralString(left) && IsObjectStringLike(right)) ||\n            (TypeGuard.IsLiteralNumber(left) && IsObjectNumberLike(right)) ||\n            (TypeGuard.IsLiteralBoolean(left) && IsObjectBooleanLike(right)) ||\n            (TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right)) ||\n            (TypeGuard.IsBigInt(left) && IsObjectBigIntLike(right)) ||\n            (TypeGuard.IsString(left) && IsObjectStringLike(right)) ||\n            (TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right)) ||\n            (TypeGuard.IsNumber(left) && IsObjectNumberLike(right)) ||\n            (TypeGuard.IsInteger(left) && IsObjectNumberLike(right)) ||\n            (TypeGuard.IsBoolean(left) && IsObjectBooleanLike(right)) ||\n            (TypeGuard.IsUint8Array(left) && IsObjectUint8ArrayLike(right)) ||\n            (TypeGuard.IsDate(left) && IsObjectDateLike(right)) ||\n            (TypeGuard.IsConstructor(left) && IsObjectConstructorLike(right)) ||\n            (TypeGuard.IsFunction(left) && IsObjectFunctionLike(right))) ? ExtendsResult.True :\n            (TypeGuard.IsRecord(left) && TypeGuard.IsString(RecordKey(left))) ? (() => {\n                // When expressing a Record with literal key values, the Record is converted into a Object with\n                // the Hint assigned as `Record`. This is used to invert the extends logic.\n                return right[Hint] === 'Record' ? ExtendsResult.True : ExtendsResult.False;\n            })() :\n                (TypeGuard.IsRecord(left) && TypeGuard.IsNumber(RecordKey(left))) ? (() => {\n                    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;\n                })() :\n                    ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromObject(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n            !TypeGuard.IsObject(right) ? ExtendsResult.False :\n                (() => {\n                    for (const key of Object.getOwnPropertyNames(right.properties)) {\n                        if (!(key in left.properties) && !TypeGuard.IsOptional(right.properties[key])) {\n                            return ExtendsResult.False;\n                        }\n                        if (TypeGuard.IsOptional(right.properties[key])) {\n                            return ExtendsResult.True;\n                        }\n                        if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {\n                            return ExtendsResult.False;\n                        }\n                    }\n                    return ExtendsResult.True;\n                })());\n}\n// ------------------------------------------------------------------\n// Promise\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromPromise(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True :\n            !TypeGuard.IsPromise(right) ? ExtendsResult.False :\n                IntoBooleanResult(Visit(left.item, right.item)));\n}\n// ------------------------------------------------------------------\n// Record\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction RecordKey(schema) {\n    return (PatternNumberExact in schema.patternProperties ? Number() :\n        PatternStringExact in schema.patternProperties ? String() :\n            Throw('Unknown record key pattern'));\n}\n// prettier-ignore\nfunction RecordValue(schema) {\n    return (PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] :\n        PatternStringExact in schema.patternProperties ? schema.patternProperties[PatternStringExact] :\n            Throw('Unable to get record value schema'));\n}\n// prettier-ignore\nfunction FromRecordRight(left, right) {\n    const [Key, Value] = [RecordKey(right), RecordValue(right)];\n    return ((TypeGuard.IsLiteralString(left) && TypeGuard.IsNumber(Key) && IntoBooleanResult(Visit(left, Value)) === ExtendsResult.True) ? ExtendsResult.True :\n        TypeGuard.IsUint8Array(left) && TypeGuard.IsNumber(Key) ? Visit(left, Value) :\n            TypeGuard.IsString(left) && TypeGuard.IsNumber(Key) ? Visit(left, Value) :\n                TypeGuard.IsArray(left) && TypeGuard.IsNumber(Key) ? Visit(left, Value) :\n                    TypeGuard.IsObject(left) ? (() => {\n                        for (const key of Object.getOwnPropertyNames(left.properties)) {\n                            if (Property(Value, left.properties[key]) === ExtendsResult.False) {\n                                return ExtendsResult.False;\n                            }\n                        }\n                        return ExtendsResult.True;\n                    })() :\n                        ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromRecord(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            !TypeGuard.IsRecord(right) ? ExtendsResult.False :\n                Visit(RecordValue(left), RecordValue(right)));\n}\n// ------------------------------------------------------------------\n// RegExp\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromRegExp(left, right) {\n    // Note: RegExp types evaluate as strings, not RegExp objects.\n    // Here we remap either into string and continue evaluating.\n    const L = TypeGuard.IsRegExp(left) ? String() : left;\n    const R = TypeGuard.IsRegExp(right) ? String() : right;\n    return Visit(L, R);\n}\n// ------------------------------------------------------------------\n// String\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromStringRight(left, right) {\n    return (TypeGuard.IsLiteral(left) && ValueGuard.IsString(left.const) ? ExtendsResult.True :\n        TypeGuard.IsString(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromString(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsString(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Symbol\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromSymbol(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsSymbol(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// TemplateLiteral\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromTemplateLiteral(left, right) {\n    // TemplateLiteral types are resolved to either unions for finite expressions or string\n    // for infinite expressions. Here we call to TemplateLiteralResolver to resolve for\n    // either type and continue evaluating.\n    return (TypeGuard.IsTemplateLiteral(left) ? Visit(TemplateLiteralToUnion(left), right) :\n        TypeGuard.IsTemplateLiteral(right) ? Visit(left, TemplateLiteralToUnion(right)) :\n            Throw('Invalid fallthrough for TemplateLiteral'));\n}\n// ------------------------------------------------------------------\n// Tuple\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction IsArrayOfTuple(left, right) {\n    return (TypeGuard.IsArray(right) &&\n        left.items !== undefined &&\n        left.items.every((schema) => Visit(schema, right.items) === ExtendsResult.True));\n}\n// prettier-ignore\nfunction FromTupleRight(left, right) {\n    return (TypeGuard.IsNever(left) ? ExtendsResult.True :\n        TypeGuard.IsUnknown(left) ? ExtendsResult.False :\n            TypeGuard.IsAny(left) ? ExtendsResult.Union :\n                ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromTuple(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True :\n            TypeGuard.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True :\n                !TypeGuard.IsTuple(right) ? ExtendsResult.False :\n                    (ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items)) || (!ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items)) ? ExtendsResult.False :\n                        (ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items)) ? ExtendsResult.True :\n                            left.items.every((schema, index) => Visit(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True :\n                                ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Uint8Array\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUint8Array(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsUint8Array(right) ? ExtendsResult.True :\n                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Undefined\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUndefined(left, right) {\n    return (IsStructuralRight(right) ? StructuralRight(left, right) :\n        TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n            TypeGuard.IsRecord(right) ? FromRecordRight(left, right) :\n                TypeGuard.IsVoid(right) ? FromVoidRight(left, right) :\n                    TypeGuard.IsUndefined(right) ? ExtendsResult.True :\n                        ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Union\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUnionRight(left, right) {\n    return right.anyOf.some((schema) => Visit(left, schema) === ExtendsResult.True)\n        ? ExtendsResult.True\n        : ExtendsResult.False;\n}\n// prettier-ignore\nfunction FromUnion(left, right) {\n    return left.anyOf.every((schema) => Visit(schema, right) === ExtendsResult.True)\n        ? ExtendsResult.True\n        : ExtendsResult.False;\n}\n// ------------------------------------------------------------------\n// Unknown\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromUnknownRight(left, right) {\n    return ExtendsResult.True;\n}\n// prettier-ignore\nfunction FromUnknown(left, right) {\n    return (TypeGuard.IsNever(right) ? FromNeverRight(left, right) :\n        TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :\n            TypeGuard.IsUnion(right) ? FromUnionRight(left, right) :\n                TypeGuard.IsAny(right) ? FromAnyRight(left, right) :\n                    TypeGuard.IsString(right) ? FromStringRight(left, right) :\n                        TypeGuard.IsNumber(right) ? FromNumberRight(left, right) :\n                            TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) :\n                                TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) :\n                                    TypeGuard.IsArray(right) ? FromArrayRight(left, right) :\n                                        TypeGuard.IsTuple(right) ? FromTupleRight(left, right) :\n                                            TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n                                                TypeGuard.IsUnknown(right) ? ExtendsResult.True :\n                                                    ExtendsResult.False);\n}\n// ------------------------------------------------------------------\n// Void\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromVoidRight(left, right) {\n    return (TypeGuard.IsUndefined(left) ? ExtendsResult.True :\n        TypeGuard.IsUndefined(left) ? ExtendsResult.True :\n            ExtendsResult.False);\n}\n// prettier-ignore\nfunction FromVoid(left, right) {\n    return (TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) :\n        TypeGuard.IsUnion(right) ? FromUnionRight(left, right) :\n            TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) :\n                TypeGuard.IsAny(right) ? FromAnyRight(left, right) :\n                    TypeGuard.IsObject(right) ? FromObjectRight(left, right) :\n                        TypeGuard.IsVoid(right) ? ExtendsResult.True :\n                            ExtendsResult.False);\n}\n// prettier-ignore\nfunction Visit(left, right) {\n    return (\n    // resolvable\n    (TypeGuard.IsTemplateLiteral(left) || TypeGuard.IsTemplateLiteral(right)) ? FromTemplateLiteral(left, right) :\n        (TypeGuard.IsRegExp(left) || TypeGuard.IsRegExp(right)) ? FromRegExp(left, right) :\n            (TypeGuard.IsNot(left) || TypeGuard.IsNot(right)) ? FromNot(left, right) :\n                // standard\n                TypeGuard.IsAny(left) ? FromAny(left, right) :\n                    TypeGuard.IsArray(left) ? FromArray(left, right) :\n                        TypeGuard.IsBigInt(left) ? FromBigInt(left, right) :\n                            TypeGuard.IsBoolean(left) ? FromBoolean(left, right) :\n                                TypeGuard.IsAsyncIterator(left) ? FromAsyncIterator(left, right) :\n                                    TypeGuard.IsConstructor(left) ? FromConstructor(left, right) :\n                                        TypeGuard.IsDate(left) ? FromDate(left, right) :\n                                            TypeGuard.IsFunction(left) ? FromFunction(left, right) :\n                                                TypeGuard.IsInteger(left) ? FromInteger(left, right) :\n                                                    TypeGuard.IsIntersect(left) ? FromIntersect(left, right) :\n                                                        TypeGuard.IsIterator(left) ? FromIterator(left, right) :\n                                                            TypeGuard.IsLiteral(left) ? FromLiteral(left, right) :\n                                                                TypeGuard.IsNever(left) ? FromNever(left, right) :\n                                                                    TypeGuard.IsNull(left) ? FromNull(left, right) :\n                                                                        TypeGuard.IsNumber(left) ? FromNumber(left, right) :\n                                                                            TypeGuard.IsObject(left) ? FromObject(left, right) :\n                                                                                TypeGuard.IsRecord(left) ? FromRecord(left, right) :\n                                                                                    TypeGuard.IsString(left) ? FromString(left, right) :\n                                                                                        TypeGuard.IsSymbol(left) ? FromSymbol(left, right) :\n                                                                                            TypeGuard.IsTuple(left) ? FromTuple(left, right) :\n                                                                                                TypeGuard.IsPromise(left) ? FromPromise(left, right) :\n                                                                                                    TypeGuard.IsUint8Array(left) ? FromUint8Array(left, right) :\n                                                                                                        TypeGuard.IsUndefined(left) ? FromUndefined(left, right) :\n                                                                                                            TypeGuard.IsUnion(left) ? FromUnion(left, right) :\n                                                                                                                TypeGuard.IsUnknown(left) ? FromUnknown(left, right) :\n                                                                                                                    TypeGuard.IsVoid(left) ? FromVoid(left, right) :\n                                                                                                                        Throw(`Unknown left type operand '${left[Kind]}'`));\n}\nexport function ExtendsCheck(left, right) {\n    return Visit(left, right);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3312, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs"],"sourcesContent":["import { MappedResult } from '../mapped/index.mjs';\nimport { Exclude } from './exclude.mjs';\n// prettier-ignore\nfunction FromProperties(P, U) {\n    const Acc = {};\n    for (const K2 of globalThis.Object.getOwnPropertyNames(P))\n        Acc[K2] = Exclude(P[K2], U);\n    return Acc;\n}\n// prettier-ignore\nfunction FromMappedResult(R, T) {\n    return FromProperties(R.properties, T);\n}\n// prettier-ignore\nexport function ExcludeFromMappedResult(R, T) {\n    const P = FromMappedResult(R, T);\n    return MappedResult(P);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACA,kBAAkB;AAClB,SAAS,eAAe,CAAC,EAAE,CAAC;IACxB,MAAM,MAAM,CAAC;IACb,KAAK,MAAM,MAAM,WAAW,MAAM,CAAC,mBAAmB,CAAC,GACnD,GAAG,CAAC,GAAG,GAAG,IAAA,iMAAO,EAAC,CAAC,CAAC,GAAG,EAAE;IAC7B,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,iBAAiB,CAAC,EAAE,CAAC;IAC1B,OAAO,eAAe,EAAE,UAAU,EAAE;AACxC;AAEO,SAAS,wBAAwB,CAAC,EAAE,CAAC;IACxC,MAAM,IAAI,iBAAiB,GAAG;IAC9B,OAAO,IAAA,8MAAY,EAAC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 3338, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs"],"sourcesContent":["import { Exclude } from './exclude.mjs';\nimport { TemplateLiteralToUnion } from '../template-literal/index.mjs';\nexport function ExcludeFromTemplateLiteral(L, R) {\n    return Exclude(TemplateLiteralToUnion(L), R);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACO,SAAS,2BAA2B,CAAC,EAAE,CAAC;IAC3C,OAAO,IAAA,iMAAO,EAAC,IAAA,0NAAsB,EAAC,IAAI;AAC9C","ignoreList":[0]}},
    {"offset": {"line": 3353, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/exclude/exclude.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Union } from '../union/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport { ExtendsCheck, ExtendsResult } from '../extends/index.mjs';\nimport { ExcludeFromMappedResult } from './exclude-from-mapped-result.mjs';\nimport { ExcludeFromTemplateLiteral } from './exclude-from-template-literal.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedResult, IsTemplateLiteral, IsUnion } from '../guard/kind.mjs';\nfunction ExcludeRest(L, R) {\n    const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);\n    return excluded.length === 1 ? excluded[0] : Union(excluded);\n}\n/** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */\nexport function Exclude(L, R, options = {}) {\n    // overloads\n    if (IsTemplateLiteral(L))\n        return CreateType(ExcludeFromTemplateLiteral(L, R), options);\n    if (IsMappedResult(L))\n        return CreateType(ExcludeFromMappedResult(L, R), options);\n    // prettier-ignore\n    return CreateType(IsUnion(L) ? ExcludeRest(L.anyOf, R) :\n        ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;;;;;;AACA,SAAS,YAAY,CAAC,EAAE,CAAC;IACrB,MAAM,WAAW,EAAE,MAAM,CAAC,CAAC,QAAU,IAAA,+MAAY,EAAC,OAAO,OAAO,gNAAa,CAAC,KAAK;IACnF,OAAO,SAAS,MAAM,KAAK,IAAI,QAAQ,CAAC,EAAE,GAAG,IAAA,2LAAK,EAAC;AACvD;AAEO,SAAS,QAAQ,CAAC,EAAE,CAAC,EAAE,UAAU,CAAC,CAAC;IACtC,YAAY;IACZ,IAAI,IAAA,sMAAiB,EAAC,IAClB,OAAO,IAAA,gMAAU,EAAC,IAAA,mPAA0B,EAAC,GAAG,IAAI;IACxD,IAAI,IAAA,mMAAc,EAAC,IACf,OAAO,IAAA,gMAAU,EAAC,IAAA,6OAAuB,EAAC,GAAG,IAAI;IACrD,kBAAkB;IAClB,OAAO,IAAA,gMAAU,EAAC,IAAA,4LAAO,EAAC,KAAK,YAAY,EAAE,KAAK,EAAE,KAChD,IAAA,+MAAY,EAAC,GAAG,OAAO,gNAAa,CAAC,KAAK,GAAG,IAAA,2LAAK,MAAK,GAAG;AAClE","ignoreList":[0]}},
    {"offset": {"line": 3389, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs"],"sourcesContent":["import { MappedResult } from '../mapped/index.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { Extends } from './extends.mjs';\nimport { Clone } from '../clone/value.mjs';\n// prettier-ignore\nfunction FromPropertyKey(K, U, L, R, options) {\n    return {\n        [K]: Extends(Literal(K), U, L, R, Clone(options))\n    };\n}\n// prettier-ignore\nfunction FromPropertyKeys(K, U, L, R, options) {\n    return K.reduce((Acc, LK) => {\n        return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedKey(K, U, L, R, options) {\n    return FromPropertyKeys(K.keys, U, L, R, options);\n}\n// prettier-ignore\nexport function ExtendsFromMappedKey(T, U, L, R, options) {\n    const P = FromMappedKey(T, U, L, R, options);\n    return MappedResult(P);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AACA,kBAAkB;AAClB,SAAS,gBAAgB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,OAAO;IACxC,OAAO;QACH,CAAC,EAAE,EAAE,IAAA,iMAAO,EAAC,IAAA,iMAAO,EAAC,IAAI,GAAG,GAAG,GAAG,IAAA,2LAAK,EAAC;IAC5C;AACJ;AACA,kBAAkB;AAClB,SAAS,iBAAiB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,OAAO;IACzC,OAAO,EAAE,MAAM,CAAC,CAAC,KAAK;QAClB,OAAO;YAAE,GAAG,GAAG;YAAE,GAAG,gBAAgB,IAAI,GAAG,GAAG,GAAG,QAAQ;QAAC;IAC9D,GAAG,CAAC;AACR;AACA,kBAAkB;AAClB,SAAS,cAAc,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,OAAO;IACtC,OAAO,iBAAiB,EAAE,IAAI,EAAE,GAAG,GAAG,GAAG;AAC7C;AAEO,SAAS,qBAAqB,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,OAAO;IACpD,MAAM,IAAI,cAAc,GAAG,GAAG,GAAG,GAAG;IACpC,OAAO,IAAA,8MAAY,EAAC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 3428, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs"],"sourcesContent":["import { MappedResult } from '../mapped/index.mjs';\nimport { Extends } from './extends.mjs';\nimport { Clone } from '../clone/value.mjs';\n// prettier-ignore\nfunction FromProperties(P, Right, True, False, options) {\n    const Acc = {};\n    for (const K2 of globalThis.Object.getOwnPropertyNames(P))\n        Acc[K2] = Extends(P[K2], Right, True, False, Clone(options));\n    return Acc;\n}\n// prettier-ignore\nfunction FromMappedResult(Left, Right, True, False, options) {\n    return FromProperties(Left.properties, Right, True, False, options);\n}\n// prettier-ignore\nexport function ExtendsFromMappedResult(Left, Right, True, False, options) {\n    const P = FromMappedResult(Left, Right, True, False, options);\n    return MappedResult(P);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACA,kBAAkB;AAClB,SAAS,eAAe,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO;IAClD,MAAM,MAAM,CAAC;IACb,KAAK,MAAM,MAAM,WAAW,MAAM,CAAC,mBAAmB,CAAC,GACnD,GAAG,CAAC,GAAG,GAAG,IAAA,iMAAO,EAAC,CAAC,CAAC,GAAG,EAAE,OAAO,MAAM,OAAO,IAAA,2LAAK,EAAC;IACvD,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,iBAAiB,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO;IACvD,OAAO,eAAe,KAAK,UAAU,EAAE,OAAO,MAAM,OAAO;AAC/D;AAEO,SAAS,wBAAwB,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO;IACrE,MAAM,IAAI,iBAAiB,MAAM,OAAO,MAAM,OAAO;IACrD,OAAO,IAAA,8MAAY,EAAC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 3456, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/extends/extends.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Union } from '../union/index.mjs';\nimport { ExtendsCheck, ExtendsResult } from './extends-check.mjs';\nimport { ExtendsFromMappedKey } from './extends-from-mapped-key.mjs';\nimport { ExtendsFromMappedResult } from './extends-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedKey, IsMappedResult } from '../guard/kind.mjs';\n// prettier-ignore\nfunction ExtendsResolve(left, right, trueType, falseType) {\n    const R = ExtendsCheck(left, right);\n    return (R === ExtendsResult.Union ? Union([trueType, falseType]) :\n        R === ExtendsResult.True ? trueType :\n            falseType);\n}\n/** `[Json]` Creates a Conditional type */\nexport function Extends(L, R, T, F, options) {\n    // prettier-ignore\n    return (IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) :\n        IsMappedKey(L) ? CreateType(ExtendsFromMappedKey(L, R, T, F, options)) :\n            CreateType(ExtendsResolve(L, R, T, F), options));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;;;;;AACA,kBAAkB;AAClB,SAAS,eAAe,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAE,SAAS;IACpD,MAAM,IAAI,IAAA,+MAAY,EAAC,MAAM;IAC7B,OAAQ,MAAM,gNAAa,CAAC,KAAK,GAAG,IAAA,2LAAK,EAAC;QAAC;QAAU;KAAU,IAC3D,MAAM,gNAAa,CAAC,IAAI,GAAG,WACvB;AACZ;AAEO,SAAS,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,OAAO;IACvC,kBAAkB;IAClB,OAAQ,IAAA,mMAAc,EAAC,KAAK,IAAA,6OAAuB,EAAC,GAAG,GAAG,GAAG,GAAG,WAC5D,IAAA,gMAAW,EAAC,KAAK,IAAA,gMAAU,EAAC,IAAA,uOAAoB,EAAC,GAAG,GAAG,GAAG,GAAG,YACzD,IAAA,gMAAU,EAAC,eAAe,GAAG,GAAG,GAAG,IAAI;AACnD","ignoreList":[0]}},
    {"offset": {"line": 3491, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs"],"sourcesContent":["import { MappedResult } from '../mapped/index.mjs';\nimport { Extract } from './extract.mjs';\n// prettier-ignore\nfunction FromProperties(P, T) {\n    const Acc = {};\n    for (const K2 of globalThis.Object.getOwnPropertyNames(P))\n        Acc[K2] = Extract(P[K2], T);\n    return Acc;\n}\n// prettier-ignore\nfunction FromMappedResult(R, T) {\n    return FromProperties(R.properties, T);\n}\n// prettier-ignore\nexport function ExtractFromMappedResult(R, T) {\n    const P = FromMappedResult(R, T);\n    return MappedResult(P);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACA,kBAAkB;AAClB,SAAS,eAAe,CAAC,EAAE,CAAC;IACxB,MAAM,MAAM,CAAC;IACb,KAAK,MAAM,MAAM,WAAW,MAAM,CAAC,mBAAmB,CAAC,GACnD,GAAG,CAAC,GAAG,GAAG,IAAA,iMAAO,EAAC,CAAC,CAAC,GAAG,EAAE;IAC7B,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,iBAAiB,CAAC,EAAE,CAAC;IAC1B,OAAO,eAAe,EAAE,UAAU,EAAE;AACxC;AAEO,SAAS,wBAAwB,CAAC,EAAE,CAAC;IACxC,MAAM,IAAI,iBAAiB,GAAG;IAC9B,OAAO,IAAA,8MAAY,EAAC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 3517, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs"],"sourcesContent":["import { Extract } from './extract.mjs';\nimport { TemplateLiteralToUnion } from '../template-literal/index.mjs';\nexport function ExtractFromTemplateLiteral(L, R) {\n    return Extract(TemplateLiteralToUnion(L), R);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACO,SAAS,2BAA2B,CAAC,EAAE,CAAC;IAC3C,OAAO,IAAA,iMAAO,EAAC,IAAA,0NAAsB,EAAC,IAAI;AAC9C","ignoreList":[0]}},
    {"offset": {"line": 3532, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/extract/extract.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Union } from '../union/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport { ExtendsCheck, ExtendsResult } from '../extends/index.mjs';\nimport { ExtractFromMappedResult } from './extract-from-mapped-result.mjs';\nimport { ExtractFromTemplateLiteral } from './extract-from-template-literal.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedResult, IsTemplateLiteral, IsUnion } from '../guard/kind.mjs';\nfunction ExtractRest(L, R) {\n    const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);\n    return extracted.length === 1 ? extracted[0] : Union(extracted);\n}\n/** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */\nexport function Extract(L, R, options) {\n    // overloads\n    if (IsTemplateLiteral(L))\n        return CreateType(ExtractFromTemplateLiteral(L, R), options);\n    if (IsMappedResult(L))\n        return CreateType(ExtractFromMappedResult(L, R), options);\n    // prettier-ignore\n    return CreateType(IsUnion(L) ? ExtractRest(L.anyOf, R) :\n        ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;;;;;;AACA,SAAS,YAAY,CAAC,EAAE,CAAC;IACrB,MAAM,YAAY,EAAE,MAAM,CAAC,CAAC,QAAU,IAAA,+MAAY,EAAC,OAAO,OAAO,gNAAa,CAAC,KAAK;IACpF,OAAO,UAAU,MAAM,KAAK,IAAI,SAAS,CAAC,EAAE,GAAG,IAAA,2LAAK,EAAC;AACzD;AAEO,SAAS,QAAQ,CAAC,EAAE,CAAC,EAAE,OAAO;IACjC,YAAY;IACZ,IAAI,IAAA,sMAAiB,EAAC,IAClB,OAAO,IAAA,gMAAU,EAAC,IAAA,mPAA0B,EAAC,GAAG,IAAI;IACxD,IAAI,IAAA,mMAAc,EAAC,IACf,OAAO,IAAA,gMAAU,EAAC,IAAA,6OAAuB,EAAC,GAAG,IAAI;IACrD,kBAAkB;IAClB,OAAO,IAAA,gMAAU,EAAC,IAAA,4LAAO,EAAC,KAAK,YAAY,EAAE,KAAK,EAAE,KAChD,IAAA,+MAAY,EAAC,GAAG,OAAO,gNAAa,CAAC,KAAK,GAAG,IAAI,IAAA,2LAAK,KAAI;AAClE","ignoreList":[0]}},
    {"offset": {"line": 3568, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/instance-type/instance-type.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Never } from '../never/index.mjs';\nimport * as KindGuard from '../guard/kind.mjs';\n/** `[JavaScript]` Extracts the InstanceType from the given Constructor type */\nexport function InstanceType(schema, options) {\n    return (KindGuard.IsConstructor(schema) ? CreateType(schema.returns, options) : Never(options));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,SAAS,aAAa,MAAM,EAAE,OAAO;IACxC,OAAQ,kMAAuB,CAAC,UAAU,IAAA,gMAAU,EAAC,OAAO,OAAO,EAAE,WAAW,IAAA,2LAAK,EAAC;AAC1F","ignoreList":[0]}},
    {"offset": {"line": 3585, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/clone/type.mjs"],"sourcesContent":["import { Clone } from './value.mjs';\n/** Clones a Rest */\nexport function CloneRest(schemas) {\n    return schemas.map((schema) => CloneType(schema));\n}\n/** Clones a Type */\nexport function CloneType(schema, options) {\n    return options === undefined ? Clone(schema) : Clone({ ...options, ...schema });\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAEO,SAAS,UAAU,OAAO;IAC7B,OAAO,QAAQ,GAAG,CAAC,CAAC,SAAW,UAAU;AAC7C;AAEO,SAAS,UAAU,MAAM,EAAE,OAAO;IACrC,OAAO,YAAY,YAAY,IAAA,2LAAK,EAAC,UAAU,IAAA,2LAAK,EAAC;QAAE,GAAG,OAAO;QAAE,GAAG,MAAM;IAAC;AACjF","ignoreList":[0]}},
    {"offset": {"line": 3606, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs"],"sourcesContent":["import { Readonly } from '../readonly/index.mjs';\nimport { Optional } from '../optional/index.mjs';\n/** `[Json]` Creates a Readonly and Optional property */\nexport function ReadonlyOptional(schema) {\n    return Readonly(Optional(schema));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,iBAAiB,MAAM;IACnC,OAAO,IAAA,oMAAQ,EAAC,IAAA,oMAAQ,EAAC;AAC7B","ignoreList":[0]}},
    {"offset": {"line": 3621, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/record/record.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind, Hint } from '../symbols/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport { Number } from '../number/index.mjs';\nimport { Object } from '../object/index.mjs';\nimport { String } from '../string/index.mjs';\nimport { Union } from '../union/index.mjs';\nimport { IsTemplateLiteralFinite } from '../template-literal/index.mjs';\nimport { PatternStringExact, PatternNumberExact, PatternNeverExact } from '../patterns/index.mjs';\nimport { IndexPropertyKeys } from '../indexed/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsUndefined } from '../guard/value.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsInteger, IsLiteral, IsAny, IsBoolean, IsNever, IsNumber, IsString, IsRegExp, IsTemplateLiteral, IsUnion } from '../guard/kind.mjs';\n// ------------------------------------------------------------------\n// RecordCreateFromPattern\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction RecordCreateFromPattern(pattern, T, options) {\n    return CreateType({ [Kind]: 'Record', type: 'object', patternProperties: { [pattern]: T } }, options);\n}\n// ------------------------------------------------------------------\n// RecordCreateFromKeys\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction RecordCreateFromKeys(K, T, options) {\n    const result = {};\n    for (const K2 of K)\n        result[K2] = T;\n    return Object(result, { ...options, [Hint]: 'Record' });\n}\n// prettier-ignore\nfunction FromTemplateLiteralKey(K, T, options) {\n    return (IsTemplateLiteralFinite(K)\n        ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options)\n        : RecordCreateFromPattern(K.pattern, T, options));\n}\n// prettier-ignore\nfunction FromUnionKey(key, type, options) {\n    return RecordCreateFromKeys(IndexPropertyKeys(Union(key)), type, options);\n}\n// prettier-ignore\nfunction FromLiteralKey(key, type, options) {\n    return RecordCreateFromKeys([key.toString()], type, options);\n}\n// prettier-ignore\nfunction FromRegExpKey(key, type, options) {\n    return RecordCreateFromPattern(key.source, type, options);\n}\n// prettier-ignore\nfunction FromStringKey(key, type, options) {\n    const pattern = IsUndefined(key.pattern) ? PatternStringExact : key.pattern;\n    return RecordCreateFromPattern(pattern, type, options);\n}\n// prettier-ignore\nfunction FromAnyKey(_, type, options) {\n    return RecordCreateFromPattern(PatternStringExact, type, options);\n}\n// prettier-ignore\nfunction FromNeverKey(_key, type, options) {\n    return RecordCreateFromPattern(PatternNeverExact, type, options);\n}\n// prettier-ignore\nfunction FromBooleanKey(_key, type, options) {\n    return Object({ true: type, false: type }, options);\n}\n// prettier-ignore\nfunction FromIntegerKey(_key, type, options) {\n    return RecordCreateFromPattern(PatternNumberExact, type, options);\n}\n// prettier-ignore\nfunction FromNumberKey(_, type, options) {\n    return RecordCreateFromPattern(PatternNumberExact, type, options);\n}\n// ------------------------------------------------------------------\n// TRecordOrObject\n// ------------------------------------------------------------------\n/** `[Json]` Creates a Record type */\nexport function Record(key, type, options = {}) {\n    // prettier-ignore\n    return (IsUnion(key) ? FromUnionKey(key.anyOf, type, options) :\n        IsTemplateLiteral(key) ? FromTemplateLiteralKey(key, type, options) :\n            IsLiteral(key) ? FromLiteralKey(key.const, type, options) :\n                IsBoolean(key) ? FromBooleanKey(key, type, options) :\n                    IsInteger(key) ? FromIntegerKey(key, type, options) :\n                        IsNumber(key) ? FromNumberKey(key, type, options) :\n                            IsRegExp(key) ? FromRegExpKey(key, type, options) :\n                                IsString(key) ? FromStringKey(key, type, options) :\n                                    IsAny(key) ? FromAnyKey(key, type, options) :\n                                        IsNever(key) ? FromNeverKey(key, type, options) :\n                                            Never(options));\n}\n// ------------------------------------------------------------------\n// Record Utilities\n// ------------------------------------------------------------------\n/** Gets the Records Pattern */\nexport function RecordPattern(record) {\n    return globalThis.Object.getOwnPropertyNames(record.patternProperties)[0];\n}\n/** Gets the Records Key Type */\n// prettier-ignore\nexport function RecordKey(type) {\n    const pattern = RecordPattern(type);\n    return (pattern === PatternStringExact ? String() :\n        pattern === PatternNumberExact ? Number() :\n            String({ pattern }));\n}\n/** Gets a Record Value Type */\n// prettier-ignore\nexport function RecordValue(type) {\n    return type.patternProperties[RecordPattern(type)];\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3752, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/instantiate/instantiate.mjs"],"sourcesContent":["import { CloneType } from '../clone/type.mjs';\nimport { Unknown } from '../unknown/index.mjs';\nimport { ReadonlyOptional } from '../readonly-optional/index.mjs';\nimport { Readonly } from '../readonly/index.mjs';\nimport { Optional } from '../optional/index.mjs';\nimport { Object } from '../object/index.mjs';\nimport { Record, RecordKey, RecordValue } from '../record/index.mjs';\nimport * as ValueGuard from '../guard/value.mjs';\nimport * as KindGuard from '../guard/kind.mjs';\n// prettier-ignore\nfunction FromConstructor(args, type) {\n    type.parameters = FromTypes(args, type.parameters);\n    type.returns = FromType(args, type.returns);\n    return type;\n}\n// prettier-ignore\nfunction FromFunction(args, type) {\n    type.parameters = FromTypes(args, type.parameters);\n    type.returns = FromType(args, type.returns);\n    return type;\n}\n// prettier-ignore\nfunction FromIntersect(args, type) {\n    type.allOf = FromTypes(args, type.allOf);\n    return type;\n}\n// prettier-ignore\nfunction FromUnion(args, type) {\n    type.anyOf = FromTypes(args, type.anyOf);\n    return type;\n}\n// prettier-ignore\nfunction FromTuple(args, type) {\n    if (ValueGuard.IsUndefined(type.items))\n        return type;\n    type.items = FromTypes(args, type.items);\n    return type;\n}\n// prettier-ignore\nfunction FromArray(args, type) {\n    type.items = FromType(args, type.items);\n    return type;\n}\n// prettier-ignore\nfunction FromAsyncIterator(args, type) {\n    type.items = FromType(args, type.items);\n    return type;\n}\n// prettier-ignore\nfunction FromIterator(args, type) {\n    type.items = FromType(args, type.items);\n    return type;\n}\n// prettier-ignore\nfunction FromPromise(args, type) {\n    type.item = FromType(args, type.item);\n    return type;\n}\n// prettier-ignore\nfunction FromObject(args, type) {\n    const mappedProperties = FromProperties(args, type.properties);\n    return { ...type, ...Object(mappedProperties) }; // retain options\n}\n// prettier-ignore\nfunction FromRecord(args, type) {\n    const mappedKey = FromType(args, RecordKey(type));\n    const mappedValue = FromType(args, RecordValue(type));\n    const result = Record(mappedKey, mappedValue);\n    return { ...type, ...result }; // retain options\n}\n// prettier-ignore\nfunction FromArgument(args, argument) {\n    return argument.index in args ? args[argument.index] : Unknown();\n}\n// prettier-ignore\nfunction FromProperty(args, type) {\n    const isReadonly = KindGuard.IsReadonly(type);\n    const isOptional = KindGuard.IsOptional(type);\n    const mapped = FromType(args, type);\n    return (isReadonly && isOptional ? ReadonlyOptional(mapped) :\n        isReadonly && !isOptional ? Readonly(mapped) :\n            !isReadonly && isOptional ? Optional(mapped) :\n                mapped);\n}\n// prettier-ignore\nfunction FromProperties(args, properties) {\n    return globalThis.Object.getOwnPropertyNames(properties).reduce((result, key) => {\n        return { ...result, [key]: FromProperty(args, properties[key]) };\n    }, {});\n}\n// prettier-ignore\nexport function FromTypes(args, types) {\n    return types.map(type => FromType(args, type));\n}\n// prettier-ignore\nfunction FromType(args, type) {\n    return (KindGuard.IsConstructor(type) ? FromConstructor(args, type) :\n        KindGuard.IsFunction(type) ? FromFunction(args, type) :\n            KindGuard.IsIntersect(type) ? FromIntersect(args, type) :\n                KindGuard.IsUnion(type) ? FromUnion(args, type) :\n                    KindGuard.IsTuple(type) ? FromTuple(args, type) :\n                        KindGuard.IsArray(type) ? FromArray(args, type) :\n                            KindGuard.IsAsyncIterator(type) ? FromAsyncIterator(args, type) :\n                                KindGuard.IsIterator(type) ? FromIterator(args, type) :\n                                    KindGuard.IsPromise(type) ? FromPromise(args, type) :\n                                        KindGuard.IsObject(type) ? FromObject(args, type) :\n                                            KindGuard.IsRecord(type) ? FromRecord(args, type) :\n                                                KindGuard.IsArgument(type) ? FromArgument(args, type) :\n                                                    type);\n}\n/** `[JavaScript]` Instantiates a type with the given parameters */\n// prettier-ignore\nexport function Instantiate(type, args) {\n    return FromType(args, CloneType(type));\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3876, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/integer/integer.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates an Integer type */\nexport function Integer(options) {\n    return CreateType({ [Kind]: 'Integer', type: 'integer' }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,QAAQ,OAAO;IAC3B,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAW,MAAM;IAAU,GAAG;AAC9D","ignoreList":[0]}},
    {"offset": {"line": 3894, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/template-literal/syntax.mjs"],"sourcesContent":["import { Literal } from '../literal/index.mjs';\nimport { Boolean } from '../boolean/index.mjs';\nimport { BigInt } from '../bigint/index.mjs';\nimport { Number } from '../number/index.mjs';\nimport { String } from '../string/index.mjs';\nimport { UnionEvaluated } from '../union/index.mjs';\nimport { Never } from '../never/index.mjs';\n// ------------------------------------------------------------------\n// SyntaxParsers\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction* FromUnion(syntax) {\n    const trim = syntax.trim().replace(/\"|'/g, '');\n    return (trim === 'boolean' ? yield Boolean() :\n        trim === 'number' ? yield Number() :\n            trim === 'bigint' ? yield BigInt() :\n                trim === 'string' ? yield String() :\n                    yield (() => {\n                        const literals = trim.split('|').map((literal) => Literal(literal.trim()));\n                        return (literals.length === 0 ? Never() :\n                            literals.length === 1 ? literals[0] :\n                                UnionEvaluated(literals));\n                    })());\n}\n// prettier-ignore\nfunction* FromTerminal(syntax) {\n    if (syntax[1] !== '{') {\n        const L = Literal('$');\n        const R = FromSyntax(syntax.slice(1));\n        return yield* [L, ...R];\n    }\n    for (let i = 2; i < syntax.length; i++) {\n        if (syntax[i] === '}') {\n            const L = FromUnion(syntax.slice(2, i));\n            const R = FromSyntax(syntax.slice(i + 1));\n            return yield* [...L, ...R];\n        }\n    }\n    yield Literal(syntax);\n}\n// prettier-ignore\nfunction* FromSyntax(syntax) {\n    for (let i = 0; i < syntax.length; i++) {\n        if (syntax[i] === '$') {\n            const L = Literal(syntax.slice(0, i));\n            const R = FromTerminal(syntax.slice(i));\n            return yield* [L, ...R];\n        }\n    }\n    yield Literal(syntax);\n}\n/** Parses TemplateLiteralSyntax and returns a tuple of TemplateLiteralKinds */\nexport function TemplateLiteralSyntax(syntax) {\n    return [...FromSyntax(syntax)];\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AACA,qEAAqE;AACrE,gBAAgB;AAChB,qEAAqE;AACrE,kBAAkB;AAClB,UAAU,UAAU,MAAM;IACtB,MAAM,OAAO,OAAO,IAAI,GAAG,OAAO,CAAC,QAAQ;IAC3C,OAAQ,SAAS,YAAY,MAAM,IAAA,iMAAO,MACtC,SAAS,WAAW,MAAM,IAAA,8LAAM,MAC5B,SAAS,WAAW,MAAM,IAAA,8LAAM,MAC5B,SAAS,WAAW,MAAM,IAAA,8LAAM,MAC5B,MAAM,CAAC;QACH,MAAM,WAAW,KAAK,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,UAAY,IAAA,iMAAO,EAAC,QAAQ,IAAI;QACtE,OAAQ,SAAS,MAAM,KAAK,IAAI,IAAA,2LAAK,MACjC,SAAS,MAAM,KAAK,IAAI,QAAQ,CAAC,EAAE,GAC/B,IAAA,iNAAc,EAAC;IAC3B,CAAC;AACrB;AACA,kBAAkB;AAClB,UAAU,aAAa,MAAM;IACzB,IAAI,MAAM,CAAC,EAAE,KAAK,KAAK;QACnB,MAAM,IAAI,IAAA,iMAAO,EAAC;QAClB,MAAM,IAAI,WAAW,OAAO,KAAK,CAAC;QAClC,OAAO,OAAO;YAAC;eAAM;SAAE;IAC3B;IACA,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,IAAK;QACpC,IAAI,MAAM,CAAC,EAAE,KAAK,KAAK;YACnB,MAAM,IAAI,UAAU,OAAO,KAAK,CAAC,GAAG;YACpC,MAAM,IAAI,WAAW,OAAO,KAAK,CAAC,IAAI;YACtC,OAAO,OAAO;mBAAI;mBAAM;aAAE;QAC9B;IACJ;IACA,MAAM,IAAA,iMAAO,EAAC;AAClB;AACA,kBAAkB;AAClB,UAAU,WAAW,MAAM;IACvB,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,IAAK;QACpC,IAAI,MAAM,CAAC,EAAE,KAAK,KAAK;YACnB,MAAM,IAAI,IAAA,iMAAO,EAAC,OAAO,KAAK,CAAC,GAAG;YAClC,MAAM,IAAI,aAAa,OAAO,KAAK,CAAC;YACpC,OAAO,OAAO;gBAAC;mBAAM;aAAE;QAC3B;IACJ;IACA,MAAM,IAAA,iMAAO,EAAC;AAClB;AAEO,SAAS,sBAAsB,MAAM;IACxC,OAAO;WAAI,WAAW;KAAQ;AAClC","ignoreList":[0]}},
    {"offset": {"line": 3968, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/template-literal/pattern.mjs"],"sourcesContent":["import { PatternNumber, PatternString, PatternBoolean } from '../patterns/index.mjs';\nimport { Kind } from '../symbols/index.mjs';\nimport { TypeBoxError } from '../error/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsTemplateLiteral, IsUnion, IsNumber, IsInteger, IsBigInt, IsString, IsLiteral, IsBoolean } from '../guard/kind.mjs';\n// ------------------------------------------------------------------\n// TemplateLiteralPatternError\n// ------------------------------------------------------------------\nexport class TemplateLiteralPatternError extends TypeBoxError {\n}\n// ------------------------------------------------------------------\n// TemplateLiteralPattern\n// ------------------------------------------------------------------\nfunction Escape(value) {\n    return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n// prettier-ignore\nfunction Visit(schema, acc) {\n    return (IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) :\n        IsUnion(schema) ? `(${schema.anyOf.map((schema) => Visit(schema, acc)).join('|')})` :\n            IsNumber(schema) ? `${acc}${PatternNumber}` :\n                IsInteger(schema) ? `${acc}${PatternNumber}` :\n                    IsBigInt(schema) ? `${acc}${PatternNumber}` :\n                        IsString(schema) ? `${acc}${PatternString}` :\n                            IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` :\n                                IsBoolean(schema) ? `${acc}${PatternBoolean}` :\n                                    (() => { throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`); })());\n}\nexport function TemplateLiteralPattern(kinds) {\n    return `^${kinds.map((schema) => Visit(schema, '')).join('')}\\$`;\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;;;AAIO,MAAM,oCAAoC,kMAAY;AAC7D;AACA,qEAAqE;AACrE,yBAAyB;AACzB,qEAAqE;AACrE,SAAS,OAAO,KAAK;IACjB,OAAO,MAAM,OAAO,CAAC,uBAAuB;AAChD;AACA,kBAAkB;AAClB,SAAS,MAAM,MAAM,EAAE,GAAG;IACtB,OAAQ,IAAA,sMAAiB,EAAC,UAAU,OAAO,OAAO,CAAC,KAAK,CAAC,GAAG,OAAO,OAAO,CAAC,MAAM,GAAG,KAChF,IAAA,4LAAO,EAAC,UAAU,CAAC,CAAC,EAAE,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC,SAAW,MAAM,QAAQ,MAAM,IAAI,CAAC,KAAK,CAAC,CAAC,GAC/E,IAAA,6LAAQ,EAAC,UAAU,GAAG,MAAM,yMAAa,EAAE,GACvC,IAAA,8LAAS,EAAC,UAAU,GAAG,MAAM,yMAAa,EAAE,GACxC,IAAA,6LAAQ,EAAC,UAAU,GAAG,MAAM,yMAAa,EAAE,GACvC,IAAA,6LAAQ,EAAC,UAAU,GAAG,MAAM,yMAAa,EAAE,GACvC,IAAA,8LAAS,EAAC,UAAU,GAAG,MAAM,OAAO,OAAO,KAAK,CAAC,QAAQ,KAAK,GAC1D,IAAA,8LAAS,EAAC,UAAU,GAAG,MAAM,0MAAc,EAAE,GACzC,CAAC;QAAQ,MAAM,IAAI,4BAA4B,CAAC,iBAAiB,EAAE,MAAM,CAAC,8LAAI,CAAC,CAAC,CAAC,CAAC;IAAG,CAAC;AAC1H;AACO,SAAS,uBAAuB,KAAK;IACxC,OAAO,CAAC,CAAC,EAAE,MAAM,GAAG,CAAC,CAAC,SAAW,MAAM,QAAQ,KAAK,IAAI,CAAC,IAAI,EAAE,CAAC;AACpE","ignoreList":[0]}},
    {"offset": {"line": 4006, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/template-literal/template-literal.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { TemplateLiteralSyntax } from './syntax.mjs';\nimport { TemplateLiteralPattern } from './pattern.mjs';\nimport { IsString } from '../guard/value.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a TemplateLiteral type */\n// prettier-ignore\nexport function TemplateLiteral(unresolved, options) {\n    const pattern = IsString(unresolved)\n        ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved))\n        : TemplateLiteralPattern(unresolved);\n    return CreateType({ [Kind]: 'TemplateLiteral', type: 'string', pattern }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAGO,SAAS,gBAAgB,UAAU,EAAE,OAAO;IAC/C,MAAM,UAAU,IAAA,8LAAQ,EAAC,cACnB,IAAA,4NAAsB,EAAC,IAAA,0NAAqB,EAAC,eAC7C,IAAA,4NAAsB,EAAC;IAC7B,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAmB,MAAM;QAAU;IAAQ,GAAG;AAC9E","ignoreList":[0]}},
    {"offset": {"line": 4032, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs"],"sourcesContent":["import { MappedResult } from '../mapped/index.mjs';\nimport { Intrinsic } from './intrinsic.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { Clone } from '../clone/value.mjs';\n// prettier-ignore\nfunction MappedIntrinsicPropertyKey(K, M, options) {\n    return {\n        [K]: Intrinsic(Literal(K), M, Clone(options))\n    };\n}\n// prettier-ignore\nfunction MappedIntrinsicPropertyKeys(K, M, options) {\n    const result = K.reduce((Acc, L) => {\n        return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };\n    }, {});\n    return result;\n}\n// prettier-ignore\nfunction MappedIntrinsicProperties(T, M, options) {\n    return MappedIntrinsicPropertyKeys(T['keys'], M, options);\n}\n// prettier-ignore\nexport function IntrinsicFromMappedKey(T, M, options) {\n    const P = MappedIntrinsicProperties(T, M, options);\n    return MappedResult(P);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AACA,kBAAkB;AAClB,SAAS,2BAA2B,CAAC,EAAE,CAAC,EAAE,OAAO;IAC7C,OAAO;QACH,CAAC,EAAE,EAAE,IAAA,uMAAS,EAAC,IAAA,iMAAO,EAAC,IAAI,GAAG,IAAA,2LAAK,EAAC;IACxC;AACJ;AACA,kBAAkB;AAClB,SAAS,4BAA4B,CAAC,EAAE,CAAC,EAAE,OAAO;IAC9C,MAAM,SAAS,EAAE,MAAM,CAAC,CAAC,KAAK;QAC1B,OAAO;YAAE,GAAG,GAAG;YAAE,GAAG,2BAA2B,GAAG,GAAG,QAAQ;QAAC;IAClE,GAAG,CAAC;IACJ,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,0BAA0B,CAAC,EAAE,CAAC,EAAE,OAAO;IAC5C,OAAO,4BAA4B,CAAC,CAAC,OAAO,EAAE,GAAG;AACrD;AAEO,SAAS,uBAAuB,CAAC,EAAE,CAAC,EAAE,OAAO;IAChD,MAAM,IAAI,0BAA0B,GAAG,GAAG;IAC1C,OAAO,IAAA,8MAAY,EAAC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 4072, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { TemplateLiteral, TemplateLiteralParseExact, IsTemplateLiteralExpressionFinite, TemplateLiteralExpressionGenerate } from '../template-literal/index.mjs';\nimport { IntrinsicFromMappedKey } from './intrinsic-from-mapped-key.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { Union } from '../union/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedKey, IsTemplateLiteral, IsUnion, IsLiteral } from '../guard/kind.mjs';\n// ------------------------------------------------------------------\n// Apply\n// ------------------------------------------------------------------\nfunction ApplyUncapitalize(value) {\n    const [first, rest] = [value.slice(0, 1), value.slice(1)];\n    return [first.toLowerCase(), rest].join('');\n}\nfunction ApplyCapitalize(value) {\n    const [first, rest] = [value.slice(0, 1), value.slice(1)];\n    return [first.toUpperCase(), rest].join('');\n}\nfunction ApplyUppercase(value) {\n    return value.toUpperCase();\n}\nfunction ApplyLowercase(value) {\n    return value.toLowerCase();\n}\nfunction FromTemplateLiteral(schema, mode, options) {\n    // note: template literals require special runtime handling as they are encoded in string patterns.\n    // This diverges from the mapped type which would otherwise map on the template literal kind.\n    const expression = TemplateLiteralParseExact(schema.pattern);\n    const finite = IsTemplateLiteralExpressionFinite(expression);\n    if (!finite)\n        return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };\n    const strings = [...TemplateLiteralExpressionGenerate(expression)];\n    const literals = strings.map((value) => Literal(value));\n    const mapped = FromRest(literals, mode);\n    const union = Union(mapped);\n    return TemplateLiteral([union], options);\n}\n// prettier-ignore\nfunction FromLiteralValue(value, mode) {\n    return (typeof value === 'string' ? (mode === 'Uncapitalize' ? ApplyUncapitalize(value) :\n        mode === 'Capitalize' ? ApplyCapitalize(value) :\n            mode === 'Uppercase' ? ApplyUppercase(value) :\n                mode === 'Lowercase' ? ApplyLowercase(value) :\n                    value) : value.toString());\n}\n// prettier-ignore\nfunction FromRest(T, M) {\n    return T.map(L => Intrinsic(L, M));\n}\n/** Applies an intrinsic string manipulation to the given type. */\nexport function Intrinsic(schema, mode, options = {}) {\n    // prettier-ignore\n    return (\n    // Intrinsic-Mapped-Inference\n    IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) :\n        // Standard-Inference\n        IsTemplateLiteral(schema) ? FromTemplateLiteral(schema, mode, options) :\n            IsUnion(schema) ? Union(FromRest(schema.anyOf, mode), options) :\n                IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) :\n                    // Default Type\n                    CreateType(schema, options));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;;;;;AACA,qEAAqE;AACrE,QAAQ;AACR,qEAAqE;AACrE,SAAS,kBAAkB,KAAK;IAC5B,MAAM,CAAC,OAAO,KAAK,GAAG;QAAC,MAAM,KAAK,CAAC,GAAG;QAAI,MAAM,KAAK,CAAC;KAAG;IACzD,OAAO;QAAC,MAAM,WAAW;QAAI;KAAK,CAAC,IAAI,CAAC;AAC5C;AACA,SAAS,gBAAgB,KAAK;IAC1B,MAAM,CAAC,OAAO,KAAK,GAAG;QAAC,MAAM,KAAK,CAAC,GAAG;QAAI,MAAM,KAAK,CAAC;KAAG;IACzD,OAAO;QAAC,MAAM,WAAW;QAAI;KAAK,CAAC,IAAI,CAAC;AAC5C;AACA,SAAS,eAAe,KAAK;IACzB,OAAO,MAAM,WAAW;AAC5B;AACA,SAAS,eAAe,KAAK;IACzB,OAAO,MAAM,WAAW;AAC5B;AACA,SAAS,oBAAoB,MAAM,EAAE,IAAI,EAAE,OAAO;IAC9C,mGAAmG;IACnG,6FAA6F;IAC7F,MAAM,aAAa,IAAA,6NAAyB,EAAC,OAAO,OAAO;IAC3D,MAAM,SAAS,IAAA,sOAAiC,EAAC;IACjD,IAAI,CAAC,QACD,OAAO;QAAE,GAAG,MAAM;QAAE,SAAS,iBAAiB,OAAO,OAAO,EAAE;IAAM;IACxE,MAAM,UAAU;WAAI,IAAA,wOAAiC,EAAC;KAAY;IAClE,MAAM,WAAW,QAAQ,GAAG,CAAC,CAAC,QAAU,IAAA,iMAAO,EAAC;IAChD,MAAM,SAAS,SAAS,UAAU;IAClC,MAAM,QAAQ,IAAA,2LAAK,EAAC;IACpB,OAAO,IAAA,iOAAe,EAAC;QAAC;KAAM,EAAE;AACpC;AACA,kBAAkB;AAClB,SAAS,iBAAiB,KAAK,EAAE,IAAI;IACjC,OAAQ,OAAO,UAAU,WAAY,SAAS,iBAAiB,kBAAkB,SAC7E,SAAS,eAAe,gBAAgB,SACpC,SAAS,cAAc,eAAe,SAClC,SAAS,cAAc,eAAe,SAClC,QAAS,MAAM,QAAQ;AAC3C;AACA,kBAAkB;AAClB,SAAS,SAAS,CAAC,EAAE,CAAC;IAClB,OAAO,EAAE,GAAG,CAAC,CAAA,IAAK,UAAU,GAAG;AACnC;AAEO,SAAS,UAAU,MAAM,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC;IAChD,kBAAkB;IAClB,OACA,6BAA6B;IAC7B,IAAA,gMAAW,EAAC,UAAU,IAAA,6OAAsB,EAAC,QAAQ,MAAM,WACvD,qBAAqB;IACrB,IAAA,sMAAiB,EAAC,UAAU,oBAAoB,QAAQ,MAAM,WAC1D,IAAA,4LAAO,EAAC,UAAU,IAAA,2LAAK,EAAC,SAAS,OAAO,KAAK,EAAE,OAAO,WAClD,IAAA,8LAAS,EAAC,UAAU,IAAA,iMAAO,EAAC,iBAAiB,OAAO,KAAK,EAAE,OAAO,WAC9D,eAAe;IACf,IAAA,gMAAU,EAAC,QAAQ;AACvC","ignoreList":[0]}},
    {"offset": {"line": 4161, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs"],"sourcesContent":["import { Intrinsic } from './intrinsic.mjs';\n/** `[Json]` Intrinsic function to Capitalize LiteralString types */\nexport function Capitalize(T, options = {}) {\n    return Intrinsic(T, 'Capitalize', options);\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEO,SAAS,WAAW,CAAC,EAAE,UAAU,CAAC,CAAC;IACtC,OAAO,IAAA,uMAAS,EAAC,GAAG,cAAc;AACtC","ignoreList":[0]}},
    {"offset": {"line": 4174, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs"],"sourcesContent":["import { Intrinsic } from './intrinsic.mjs';\n/** `[Json]` Intrinsic function to Uncapitalize LiteralString types */\nexport function Uncapitalize(T, options = {}) {\n    return Intrinsic(T, 'Uncapitalize', options);\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEO,SAAS,aAAa,CAAC,EAAE,UAAU,CAAC,CAAC;IACxC,OAAO,IAAA,uMAAS,EAAC,GAAG,gBAAgB;AACxC","ignoreList":[0]}},
    {"offset": {"line": 4187, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs"],"sourcesContent":["import { Intrinsic } from './intrinsic.mjs';\n/** `[Json]` Intrinsic function to Lowercase LiteralString types */\nexport function Lowercase(T, options = {}) {\n    return Intrinsic(T, 'Lowercase', options);\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEO,SAAS,UAAU,CAAC,EAAE,UAAU,CAAC,CAAC;IACrC,OAAO,IAAA,uMAAS,EAAC,GAAG,aAAa;AACrC","ignoreList":[0]}},
    {"offset": {"line": 4200, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs"],"sourcesContent":["import { Intrinsic } from './intrinsic.mjs';\n/** `[Json]` Intrinsic function to Uppercase LiteralString types */\nexport function Uppercase(T, options = {}) {\n    return Intrinsic(T, 'Uppercase', options);\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEO,SAAS,UAAU,CAAC,EAAE,UAAU,CAAC,CAAC;IACrC,OAAO,IAAA,uMAAS,EAAC,GAAG,aAAa;AACrC","ignoreList":[0]}},
    {"offset": {"line": 4213, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/iterator/iterator.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates an Iterator type */\nexport function Iterator(items, options) {\n    return CreateType({ [Kind]: 'Iterator', type: 'Iterator', items }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,SAAS,KAAK,EAAE,OAAO;IACnC,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAY,MAAM;QAAY;IAAM,GAAG;AACvE","ignoreList":[0]}},
    {"offset": {"line": 4232, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs"],"sourcesContent":["import { MappedResult } from '../mapped/index.mjs';\nimport { KeyOf } from './keyof.mjs';\nimport { Clone } from '../clone/value.mjs';\n// prettier-ignore\nfunction FromProperties(properties, options) {\n    const result = {};\n    for (const K2 of globalThis.Object.getOwnPropertyNames(properties))\n        result[K2] = KeyOf(properties[K2], Clone(options));\n    return result;\n}\n// prettier-ignore\nfunction FromMappedResult(mappedResult, options) {\n    return FromProperties(mappedResult.properties, options);\n}\n// prettier-ignore\nexport function KeyOfFromMappedResult(mappedResult, options) {\n    const properties = FromMappedResult(mappedResult, options);\n    return MappedResult(properties);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACA,kBAAkB;AAClB,SAAS,eAAe,UAAU,EAAE,OAAO;IACvC,MAAM,SAAS,CAAC;IAChB,KAAK,MAAM,MAAM,WAAW,MAAM,CAAC,mBAAmB,CAAC,YACnD,MAAM,CAAC,GAAG,GAAG,IAAA,2LAAK,EAAC,UAAU,CAAC,GAAG,EAAE,IAAA,2LAAK,EAAC;IAC7C,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,iBAAiB,YAAY,EAAE,OAAO;IAC3C,OAAO,eAAe,aAAa,UAAU,EAAE;AACnD;AAEO,SAAS,sBAAsB,YAAY,EAAE,OAAO;IACvD,MAAM,aAAa,iBAAiB,cAAc;IAClD,OAAO,IAAA,8MAAY,EAAC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 4260, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/keyof/keyof.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { Number } from '../number/index.mjs';\nimport { Computed } from '../computed/index.mjs';\nimport { Ref } from '../ref/index.mjs';\nimport { KeyOfPropertyKeys } from './keyof-property-keys.mjs';\nimport { UnionEvaluated } from '../union/index.mjs';\nimport { KeyOfFromMappedResult } from './keyof-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedResult, IsRef, IsComputed } from '../guard/kind.mjs';\n// prettier-ignore\nfunction FromComputed(target, parameters) {\n    return Computed('KeyOf', [Computed(target, parameters)]);\n}\n// prettier-ignore\nfunction FromRef($ref) {\n    return Computed('KeyOf', [Ref($ref)]);\n}\n// prettier-ignore\nfunction KeyOfFromType(type, options) {\n    const propertyKeys = KeyOfPropertyKeys(type);\n    const propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys);\n    const result = UnionEvaluated(propertyKeyTypes);\n    return CreateType(result, options);\n}\n// prettier-ignore\nexport function KeyOfPropertyKeysToRest(propertyKeys) {\n    return propertyKeys.map(L => L === '[number]' ? Number() : Literal(L));\n}\n/** `[Json]` Creates a KeyOf type */\nexport function KeyOf(type, options) {\n    return (IsComputed(type) ? FromComputed(type.target, type.parameters) : IsRef(type) ? FromRef(type.$ref) : IsMappedResult(type) ? KeyOfFromMappedResult(type, options) : KeyOfFromType(type, options));\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;;;;;;;;AACA,kBAAkB;AAClB,SAAS,aAAa,MAAM,EAAE,UAAU;IACpC,OAAO,IAAA,oMAAQ,EAAC,SAAS;QAAC,IAAA,oMAAQ,EAAC,QAAQ;KAAY;AAC3D;AACA,kBAAkB;AAClB,SAAS,QAAQ,IAAI;IACjB,OAAO,IAAA,oMAAQ,EAAC,SAAS;QAAC,IAAA,qLAAG,EAAC;KAAM;AACxC;AACA,kBAAkB;AAClB,SAAS,cAAc,IAAI,EAAE,OAAO;IAChC,MAAM,eAAe,IAAA,2NAAiB,EAAC;IACvC,MAAM,mBAAmB,wBAAwB;IACjD,MAAM,SAAS,IAAA,iNAAc,EAAC;IAC9B,OAAO,IAAA,gMAAU,EAAC,QAAQ;AAC9B;AAEO,SAAS,wBAAwB,YAAY;IAChD,OAAO,aAAa,GAAG,CAAC,CAAA,IAAK,MAAM,aAAa,IAAA,8LAAM,MAAK,IAAA,iMAAO,EAAC;AACvE;AAEO,SAAS,MAAM,IAAI,EAAE,OAAO;IAC/B,OAAQ,IAAA,+LAAU,EAAC,QAAQ,aAAa,KAAK,MAAM,EAAE,KAAK,UAAU,IAAI,IAAA,0LAAK,EAAC,QAAQ,QAAQ,KAAK,IAAI,IAAI,IAAA,mMAAc,EAAC,QAAQ,IAAA,uOAAqB,EAAC,MAAM,WAAW,cAAc,MAAM;AACjM","ignoreList":[0]}},
    {"offset": {"line": 4316, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/promise/promise.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Promise type */\nexport function Promise(item, options) {\n    return CreateType({ [Kind]: 'Promise', type: 'Promise', item }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,QAAQ,IAAI,EAAE,OAAO;IACjC,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAW,MAAM;QAAW;IAAK,GAAG;AACpE","ignoreList":[0]}},
    {"offset": {"line": 4335, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/mapped/mapped.mjs"],"sourcesContent":["import { Kind, OptionalKind, ReadonlyKind } from '../symbols/index.mjs';\nimport { Discard } from '../discard/index.mjs';\n// evaluation types\nimport { Array } from '../array/index.mjs';\nimport { AsyncIterator } from '../async-iterator/index.mjs';\nimport { Constructor } from '../constructor/index.mjs';\nimport { Function as FunctionType } from '../function/index.mjs';\nimport { IndexPropertyKeys } from '../indexed/index.mjs';\nimport { Intersect } from '../intersect/index.mjs';\nimport { Iterator } from '../iterator/index.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { Object } from '../object/index.mjs';\nimport { Optional } from '../optional/index.mjs';\nimport { Promise } from '../promise/index.mjs';\nimport { Readonly } from '../readonly/index.mjs';\nimport { Tuple } from '../tuple/index.mjs';\nimport { Union } from '../union/index.mjs';\n// operator\nimport { SetIncludes } from '../sets/index.mjs';\n// mapping types\nimport { MappedResult } from './mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsAsyncIterator, IsConstructor, IsFunction, IsIntersect, IsIterator, IsReadonly, IsMappedResult, IsMappedKey, IsObject, IsOptional, IsPromise, IsSchema, IsTuple, IsUnion } from '../guard/kind.mjs';\n// prettier-ignore\nfunction FromMappedResult(K, P) {\n    return (K in P\n        ? FromSchemaType(K, P[K])\n        : MappedResult(P));\n}\n// prettier-ignore\nfunction MappedKeyToKnownMappedResultProperties(K) {\n    return { [K]: Literal(K) };\n}\n// prettier-ignore\nfunction MappedKeyToUnknownMappedResultProperties(P) {\n    const Acc = {};\n    for (const L of P)\n        Acc[L] = Literal(L);\n    return Acc;\n}\n// prettier-ignore\nfunction MappedKeyToMappedResultProperties(K, P) {\n    return (SetIncludes(P, K)\n        ? MappedKeyToKnownMappedResultProperties(K)\n        : MappedKeyToUnknownMappedResultProperties(P));\n}\n// prettier-ignore\nfunction FromMappedKey(K, P) {\n    const R = MappedKeyToMappedResultProperties(K, P);\n    return FromMappedResult(K, R);\n}\n// prettier-ignore\nfunction FromRest(K, T) {\n    return T.map(L => FromSchemaType(K, L));\n}\n// prettier-ignore\nfunction FromProperties(K, T) {\n    const Acc = {};\n    for (const K2 of globalThis.Object.getOwnPropertyNames(T))\n        Acc[K2] = FromSchemaType(K, T[K2]);\n    return Acc;\n}\n// prettier-ignore\nfunction FromSchemaType(K, T) {\n    // required to retain user defined options for mapped type\n    const options = { ...T };\n    return (\n    // unevaluated modifier types\n    IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) :\n        IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) :\n            // unevaluated mapped types\n            IsMappedResult(T) ? FromMappedResult(K, T.properties) :\n                IsMappedKey(T) ? FromMappedKey(K, T.keys) :\n                    // unevaluated types\n                    IsConstructor(T) ? Constructor(FromRest(K, T.parameters), FromSchemaType(K, T.returns), options) :\n                        IsFunction(T) ? FunctionType(FromRest(K, T.parameters), FromSchemaType(K, T.returns), options) :\n                            IsAsyncIterator(T) ? AsyncIterator(FromSchemaType(K, T.items), options) :\n                                IsIterator(T) ? Iterator(FromSchemaType(K, T.items), options) :\n                                    IsIntersect(T) ? Intersect(FromRest(K, T.allOf), options) :\n                                        IsUnion(T) ? Union(FromRest(K, T.anyOf), options) :\n                                            IsTuple(T) ? Tuple(FromRest(K, T.items ?? []), options) :\n                                                IsObject(T) ? Object(FromProperties(K, T.properties), options) :\n                                                    IsArray(T) ? Array(FromSchemaType(K, T.items), options) :\n                                                        IsPromise(T) ? Promise(FromSchemaType(K, T.item), options) :\n                                                            T);\n}\n// prettier-ignore\nexport function MappedFunctionReturnType(K, T) {\n    const Acc = {};\n    for (const L of K)\n        Acc[L] = FromSchemaType(L, T);\n    return Acc;\n}\n/** `[Json]` Creates a Mapped object type */\nexport function Mapped(key, map, options) {\n    const K = IsSchema(key) ? IndexPropertyKeys(key) : key;\n    const RT = map({ [Kind]: 'MappedKey', keys: K });\n    const R = MappedFunctionReturnType(K, RT);\n    return Object(R, options);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4453, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs"],"sourcesContent":["import { MappedResult } from '../mapped/index.mjs';\nimport { Omit } from './omit.mjs';\nimport { Clone } from '../clone/value.mjs';\n// prettier-ignore\nfunction FromPropertyKey(type, key, options) {\n    return { [key]: Omit(type, [key], Clone(options)) };\n}\n// prettier-ignore\nfunction FromPropertyKeys(type, propertyKeys, options) {\n    return propertyKeys.reduce((Acc, LK) => {\n        return { ...Acc, ...FromPropertyKey(type, LK, options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedKey(type, mappedKey, options) {\n    return FromPropertyKeys(type, mappedKey.keys, options);\n}\n// prettier-ignore\nexport function OmitFromMappedKey(type, mappedKey, options) {\n    const properties = FromMappedKey(type, mappedKey, options);\n    return MappedResult(properties);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACA,kBAAkB;AAClB,SAAS,gBAAgB,IAAI,EAAE,GAAG,EAAE,OAAO;IACvC,OAAO;QAAE,CAAC,IAAI,EAAE,IAAA,wLAAI,EAAC,MAAM;YAAC;SAAI,EAAE,IAAA,2LAAK,EAAC;IAAU;AACtD;AACA,kBAAkB;AAClB,SAAS,iBAAiB,IAAI,EAAE,YAAY,EAAE,OAAO;IACjD,OAAO,aAAa,MAAM,CAAC,CAAC,KAAK;QAC7B,OAAO;YAAE,GAAG,GAAG;YAAE,GAAG,gBAAgB,MAAM,IAAI,QAAQ;QAAC;IAC3D,GAAG,CAAC;AACR;AACA,kBAAkB;AAClB,SAAS,cAAc,IAAI,EAAE,SAAS,EAAE,OAAO;IAC3C,OAAO,iBAAiB,MAAM,UAAU,IAAI,EAAE;AAClD;AAEO,SAAS,kBAAkB,IAAI,EAAE,SAAS,EAAE,OAAO;IACtD,MAAM,aAAa,cAAc,MAAM,WAAW;IAClD,OAAO,IAAA,8MAAY,EAAC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 4492, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs"],"sourcesContent":["import { MappedResult } from '../mapped/index.mjs';\nimport { Omit } from './omit.mjs';\nimport { Clone } from '../clone/value.mjs';\n// prettier-ignore\nfunction FromProperties(properties, propertyKeys, options) {\n    const result = {};\n    for (const K2 of globalThis.Object.getOwnPropertyNames(properties))\n        result[K2] = Omit(properties[K2], propertyKeys, Clone(options));\n    return result;\n}\n// prettier-ignore\nfunction FromMappedResult(mappedResult, propertyKeys, options) {\n    return FromProperties(mappedResult.properties, propertyKeys, options);\n}\n// prettier-ignore\nexport function OmitFromMappedResult(mappedResult, propertyKeys, options) {\n    const properties = FromMappedResult(mappedResult, propertyKeys, options);\n    return MappedResult(properties);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACA,kBAAkB;AAClB,SAAS,eAAe,UAAU,EAAE,YAAY,EAAE,OAAO;IACrD,MAAM,SAAS,CAAC;IAChB,KAAK,MAAM,MAAM,WAAW,MAAM,CAAC,mBAAmB,CAAC,YACnD,MAAM,CAAC,GAAG,GAAG,IAAA,wLAAI,EAAC,UAAU,CAAC,GAAG,EAAE,cAAc,IAAA,2LAAK,EAAC;IAC1D,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,iBAAiB,YAAY,EAAE,YAAY,EAAE,OAAO;IACzD,OAAO,eAAe,aAAa,UAAU,EAAE,cAAc;AACjE;AAEO,SAAS,qBAAqB,YAAY,EAAE,YAAY,EAAE,OAAO;IACpE,MAAM,aAAa,iBAAiB,cAAc,cAAc;IAChE,OAAO,IAAA,8MAAY,EAAC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 4520, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/omit/omit.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Discard } from '../discard/discard.mjs';\nimport { TransformKind } from '../symbols/symbols.mjs';\nimport { Computed } from '../computed/index.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { IndexPropertyKeys } from '../indexed/index.mjs';\nimport { Intersect } from '../intersect/index.mjs';\nimport { Union } from '../union/index.mjs';\nimport { Object } from '../object/index.mjs';\n// ------------------------------------------------------------------\n// Mapped\n// ------------------------------------------------------------------\nimport { OmitFromMappedKey } from './omit-from-mapped-key.mjs';\nimport { OmitFromMappedResult } from './omit-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsMappedKey, IsIntersect, IsUnion, IsObject, IsSchema, IsMappedResult, IsLiteralValue, IsRef } from '../guard/kind.mjs';\nimport { IsArray as IsArrayValue } from '../guard/value.mjs';\n// prettier-ignore\nfunction FromIntersect(types, propertyKeys) {\n    return types.map((type) => OmitResolve(type, propertyKeys));\n}\n// prettier-ignore\nfunction FromUnion(types, propertyKeys) {\n    return types.map((type) => OmitResolve(type, propertyKeys));\n}\n// ------------------------------------------------------------------\n// FromProperty\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction FromProperty(properties, key) {\n    const { [key]: _, ...R } = properties;\n    return R;\n}\n// prettier-ignore\nfunction FromProperties(properties, propertyKeys) {\n    return propertyKeys.reduce((T, K2) => FromProperty(T, K2), properties);\n}\n// prettier-ignore\nfunction FromObject(type, propertyKeys, properties) {\n    const options = Discard(type, [TransformKind, '$id', 'required', 'properties']);\n    const mappedProperties = FromProperties(properties, propertyKeys);\n    return Object(mappedProperties, options);\n}\n// prettier-ignore\nfunction UnionFromPropertyKeys(propertyKeys) {\n    const result = propertyKeys.reduce((result, key) => IsLiteralValue(key) ? [...result, Literal(key)] : result, []);\n    return Union(result);\n}\n// prettier-ignore\nfunction OmitResolve(type, propertyKeys) {\n    return (IsIntersect(type) ? Intersect(FromIntersect(type.allOf, propertyKeys)) :\n        IsUnion(type) ? Union(FromUnion(type.anyOf, propertyKeys)) :\n            IsObject(type) ? FromObject(type, propertyKeys, type.properties) :\n                Object({}));\n}\n/** `[Json]` Constructs a type whose keys are picked from the given type */\n// prettier-ignore\nexport function Omit(type, key, options) {\n    const typeKey = IsArrayValue(key) ? UnionFromPropertyKeys(key) : key;\n    const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;\n    const isTypeRef = IsRef(type);\n    const isKeyRef = IsRef(key);\n    return (IsMappedResult(type) ? OmitFromMappedResult(type, propertyKeys, options) :\n        IsMappedKey(key) ? OmitFromMappedKey(type, key, options) :\n            (isTypeRef && isKeyRef) ? Computed('Omit', [type, typeKey], options) :\n                (!isTypeRef && isKeyRef) ? Computed('Omit', [type, typeKey], options) :\n                    (isTypeRef && !isKeyRef) ? Computed('Omit', [type, typeKey], options) :\n                        CreateType({ ...OmitResolve(type, propertyKeys), ...options }));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,SAAS;AACT,qEAAqE;AACrE;AACA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;AACA;;;;;;;;;;;;;;AACA,kBAAkB;AAClB,SAAS,cAAc,KAAK,EAAE,YAAY;IACtC,OAAO,MAAM,GAAG,CAAC,CAAC,OAAS,YAAY,MAAM;AACjD;AACA,kBAAkB;AAClB,SAAS,UAAU,KAAK,EAAE,YAAY;IAClC,OAAO,MAAM,GAAG,CAAC,CAAC,OAAS,YAAY,MAAM;AACjD;AACA,qEAAqE;AACrE,eAAe;AACf,qEAAqE;AACrE,kBAAkB;AAClB,SAAS,aAAa,UAAU,EAAE,GAAG;IACjC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,GAAG,GAAG,GAAG;IAC3B,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,eAAe,UAAU,EAAE,YAAY;IAC5C,OAAO,aAAa,MAAM,CAAC,CAAC,GAAG,KAAO,aAAa,GAAG,KAAK;AAC/D;AACA,kBAAkB;AAClB,SAAS,WAAW,IAAI,EAAE,YAAY,EAAE,UAAU;IAC9C,MAAM,UAAU,IAAA,iMAAO,EAAC,MAAM;QAAC,uMAAa;QAAE;QAAO;QAAY;KAAa;IAC9E,MAAM,mBAAmB,eAAe,YAAY;IACpD,OAAO,IAAA,8LAAM,EAAC,kBAAkB;AACpC;AACA,kBAAkB;AAClB,SAAS,sBAAsB,YAAY;IACvC,MAAM,SAAS,aAAa,MAAM,CAAC,CAAC,QAAQ,MAAQ,IAAA,mMAAc,EAAC,OAAO;eAAI;YAAQ,IAAA,iMAAO,EAAC;SAAK,GAAG,QAAQ,EAAE;IAChH,OAAO,IAAA,2LAAK,EAAC;AACjB;AACA,kBAAkB;AAClB,SAAS,YAAY,IAAI,EAAE,YAAY;IACnC,OAAQ,IAAA,gMAAW,EAAC,QAAQ,IAAA,uMAAS,EAAC,cAAc,KAAK,KAAK,EAAE,iBAC5D,IAAA,4LAAO,EAAC,QAAQ,IAAA,2LAAK,EAAC,UAAU,KAAK,KAAK,EAAE,iBACxC,IAAA,6LAAQ,EAAC,QAAQ,WAAW,MAAM,cAAc,KAAK,UAAU,IAC3D,IAAA,8LAAM,EAAC,CAAC;AACxB;AAGO,SAAS,KAAK,IAAI,EAAE,GAAG,EAAE,OAAO;IACnC,MAAM,UAAU,IAAA,6LAAY,EAAC,OAAO,sBAAsB,OAAO;IACjE,MAAM,eAAe,IAAA,6LAAQ,EAAC,OAAO,IAAA,+NAAiB,EAAC,OAAO;IAC9D,MAAM,YAAY,IAAA,0LAAK,EAAC;IACxB,MAAM,WAAW,IAAA,0LAAK,EAAC;IACvB,OAAQ,IAAA,mMAAc,EAAC,QAAQ,IAAA,oOAAoB,EAAC,MAAM,cAAc,WACpE,IAAA,gMAAW,EAAC,OAAO,IAAA,8NAAiB,EAAC,MAAM,KAAK,WAC5C,AAAC,aAAa,WAAY,IAAA,oMAAQ,EAAC,QAAQ;QAAC;QAAM;KAAQ,EAAE,WACxD,AAAC,CAAC,aAAa,WAAY,IAAA,oMAAQ,EAAC,QAAQ;QAAC;QAAM;KAAQ,EAAE,WACzD,AAAC,aAAa,CAAC,WAAY,IAAA,oMAAQ,EAAC,QAAQ;QAAC;QAAM;KAAQ,EAAE,WACzD,IAAA,gMAAU,EAAC;QAAE,GAAG,YAAY,MAAM,aAAa;QAAE,GAAG,OAAO;IAAC;AACpF","ignoreList":[0]}},
    {"offset": {"line": 4622, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs"],"sourcesContent":["import { MappedResult } from '../mapped/index.mjs';\nimport { Pick } from './pick.mjs';\nimport { Clone } from '../clone/value.mjs';\n// prettier-ignore\nfunction FromPropertyKey(type, key, options) {\n    return {\n        [key]: Pick(type, [key], Clone(options))\n    };\n}\n// prettier-ignore\nfunction FromPropertyKeys(type, propertyKeys, options) {\n    return propertyKeys.reduce((result, leftKey) => {\n        return { ...result, ...FromPropertyKey(type, leftKey, options) };\n    }, {});\n}\n// prettier-ignore\nfunction FromMappedKey(type, mappedKey, options) {\n    return FromPropertyKeys(type, mappedKey.keys, options);\n}\n// prettier-ignore\nexport function PickFromMappedKey(type, mappedKey, options) {\n    const properties = FromMappedKey(type, mappedKey, options);\n    return MappedResult(properties);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACA,kBAAkB;AAClB,SAAS,gBAAgB,IAAI,EAAE,GAAG,EAAE,OAAO;IACvC,OAAO;QACH,CAAC,IAAI,EAAE,IAAA,wLAAI,EAAC,MAAM;YAAC;SAAI,EAAE,IAAA,2LAAK,EAAC;IACnC;AACJ;AACA,kBAAkB;AAClB,SAAS,iBAAiB,IAAI,EAAE,YAAY,EAAE,OAAO;IACjD,OAAO,aAAa,MAAM,CAAC,CAAC,QAAQ;QAChC,OAAO;YAAE,GAAG,MAAM;YAAE,GAAG,gBAAgB,MAAM,SAAS,QAAQ;QAAC;IACnE,GAAG,CAAC;AACR;AACA,kBAAkB;AAClB,SAAS,cAAc,IAAI,EAAE,SAAS,EAAE,OAAO;IAC3C,OAAO,iBAAiB,MAAM,UAAU,IAAI,EAAE;AAClD;AAEO,SAAS,kBAAkB,IAAI,EAAE,SAAS,EAAE,OAAO;IACtD,MAAM,aAAa,cAAc,MAAM,WAAW;IAClD,OAAO,IAAA,8MAAY,EAAC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 4661, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs"],"sourcesContent":["import { MappedResult } from '../mapped/index.mjs';\nimport { Pick } from './pick.mjs';\nimport { Clone } from '../clone/value.mjs';\n// prettier-ignore\nfunction FromProperties(properties, propertyKeys, options) {\n    const result = {};\n    for (const K2 of globalThis.Object.getOwnPropertyNames(properties))\n        result[K2] = Pick(properties[K2], propertyKeys, Clone(options));\n    return result;\n}\n// prettier-ignore\nfunction FromMappedResult(mappedResult, propertyKeys, options) {\n    return FromProperties(mappedResult.properties, propertyKeys, options);\n}\n// prettier-ignore\nexport function PickFromMappedResult(mappedResult, propertyKeys, options) {\n    const properties = FromMappedResult(mappedResult, propertyKeys, options);\n    return MappedResult(properties);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACA,kBAAkB;AAClB,SAAS,eAAe,UAAU,EAAE,YAAY,EAAE,OAAO;IACrD,MAAM,SAAS,CAAC;IAChB,KAAK,MAAM,MAAM,WAAW,MAAM,CAAC,mBAAmB,CAAC,YACnD,MAAM,CAAC,GAAG,GAAG,IAAA,wLAAI,EAAC,UAAU,CAAC,GAAG,EAAE,cAAc,IAAA,2LAAK,EAAC;IAC1D,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,iBAAiB,YAAY,EAAE,YAAY,EAAE,OAAO;IACzD,OAAO,eAAe,aAAa,UAAU,EAAE,cAAc;AACjE;AAEO,SAAS,qBAAqB,YAAY,EAAE,YAAY,EAAE,OAAO;IACpE,MAAM,aAAa,iBAAiB,cAAc,cAAc;IAChE,OAAO,IAAA,8MAAY,EAAC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 4689, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/pick/pick.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Discard } from '../discard/discard.mjs';\nimport { Computed } from '../computed/index.mjs';\nimport { Intersect } from '../intersect/index.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { Object } from '../object/index.mjs';\nimport { Union } from '../union/index.mjs';\nimport { IndexPropertyKeys } from '../indexed/index.mjs';\nimport { TransformKind } from '../symbols/symbols.mjs';\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nimport { IsMappedKey, IsMappedResult, IsIntersect, IsUnion, IsObject, IsSchema, IsLiteralValue, IsRef } from '../guard/kind.mjs';\nimport { IsArray as IsArrayValue } from '../guard/value.mjs';\n// ------------------------------------------------------------------\n// Infrastructure\n// ------------------------------------------------------------------\nimport { PickFromMappedKey } from './pick-from-mapped-key.mjs';\nimport { PickFromMappedResult } from './pick-from-mapped-result.mjs';\nfunction FromIntersect(types, propertyKeys) {\n    return types.map((type) => PickResolve(type, propertyKeys));\n}\n// prettier-ignore\nfunction FromUnion(types, propertyKeys) {\n    return types.map((type) => PickResolve(type, propertyKeys));\n}\n// prettier-ignore\nfunction FromProperties(properties, propertyKeys) {\n    const result = {};\n    for (const K2 of propertyKeys)\n        if (K2 in properties)\n            result[K2] = properties[K2];\n    return result;\n}\n// prettier-ignore\nfunction FromObject(Type, keys, properties) {\n    const options = Discard(Type, [TransformKind, '$id', 'required', 'properties']);\n    const mappedProperties = FromProperties(properties, keys);\n    return Object(mappedProperties, options);\n}\n// prettier-ignore\nfunction UnionFromPropertyKeys(propertyKeys) {\n    const result = propertyKeys.reduce((result, key) => IsLiteralValue(key) ? [...result, Literal(key)] : result, []);\n    return Union(result);\n}\n// prettier-ignore\nfunction PickResolve(type, propertyKeys) {\n    return (IsIntersect(type) ? Intersect(FromIntersect(type.allOf, propertyKeys)) :\n        IsUnion(type) ? Union(FromUnion(type.anyOf, propertyKeys)) :\n            IsObject(type) ? FromObject(type, propertyKeys, type.properties) :\n                Object({}));\n}\n/** `[Json]` Constructs a type whose keys are picked from the given type */\n// prettier-ignore\nexport function Pick(type, key, options) {\n    const typeKey = IsArrayValue(key) ? UnionFromPropertyKeys(key) : key;\n    const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;\n    const isTypeRef = IsRef(type);\n    const isKeyRef = IsRef(key);\n    return (IsMappedResult(type) ? PickFromMappedResult(type, propertyKeys, options) :\n        IsMappedKey(key) ? PickFromMappedKey(type, key, options) :\n            (isTypeRef && isKeyRef) ? Computed('Pick', [type, typeKey], options) :\n                (!isTypeRef && isKeyRef) ? Computed('Pick', [type, typeKey], options) :\n                    (isTypeRef && !isKeyRef) ? Computed('Pick', [type, typeKey], options) :\n                        CreateType({ ...PickResolve(type, propertyKeys), ...options }));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,SAAS;AACT,qEAAqE;AACrE;AACA;AACA,qEAAqE;AACrE,iBAAiB;AACjB,qEAAqE;AACrE;AACA;;;;;;;;;;;;;;AACA,SAAS,cAAc,KAAK,EAAE,YAAY;IACtC,OAAO,MAAM,GAAG,CAAC,CAAC,OAAS,YAAY,MAAM;AACjD;AACA,kBAAkB;AAClB,SAAS,UAAU,KAAK,EAAE,YAAY;IAClC,OAAO,MAAM,GAAG,CAAC,CAAC,OAAS,YAAY,MAAM;AACjD;AACA,kBAAkB;AAClB,SAAS,eAAe,UAAU,EAAE,YAAY;IAC5C,MAAM,SAAS,CAAC;IAChB,KAAK,MAAM,MAAM,aACb,IAAI,MAAM,YACN,MAAM,CAAC,GAAG,GAAG,UAAU,CAAC,GAAG;IACnC,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,WAAW,IAAI,EAAE,IAAI,EAAE,UAAU;IACtC,MAAM,UAAU,IAAA,iMAAO,EAAC,MAAM;QAAC,uMAAa;QAAE;QAAO;QAAY;KAAa;IAC9E,MAAM,mBAAmB,eAAe,YAAY;IACpD,OAAO,IAAA,8LAAM,EAAC,kBAAkB;AACpC;AACA,kBAAkB;AAClB,SAAS,sBAAsB,YAAY;IACvC,MAAM,SAAS,aAAa,MAAM,CAAC,CAAC,QAAQ,MAAQ,IAAA,mMAAc,EAAC,OAAO;eAAI;YAAQ,IAAA,iMAAO,EAAC;SAAK,GAAG,QAAQ,EAAE;IAChH,OAAO,IAAA,2LAAK,EAAC;AACjB;AACA,kBAAkB;AAClB,SAAS,YAAY,IAAI,EAAE,YAAY;IACnC,OAAQ,IAAA,gMAAW,EAAC,QAAQ,IAAA,uMAAS,EAAC,cAAc,KAAK,KAAK,EAAE,iBAC5D,IAAA,4LAAO,EAAC,QAAQ,IAAA,2LAAK,EAAC,UAAU,KAAK,KAAK,EAAE,iBACxC,IAAA,6LAAQ,EAAC,QAAQ,WAAW,MAAM,cAAc,KAAK,UAAU,IAC3D,IAAA,8LAAM,EAAC,CAAC;AACxB;AAGO,SAAS,KAAK,IAAI,EAAE,GAAG,EAAE,OAAO;IACnC,MAAM,UAAU,IAAA,6LAAY,EAAC,OAAO,sBAAsB,OAAO;IACjE,MAAM,eAAe,IAAA,6LAAQ,EAAC,OAAO,IAAA,+NAAiB,EAAC,OAAO;IAC9D,MAAM,YAAY,IAAA,0LAAK,EAAC;IACxB,MAAM,WAAW,IAAA,0LAAK,EAAC;IACvB,OAAQ,IAAA,mMAAc,EAAC,QAAQ,IAAA,oOAAoB,EAAC,MAAM,cAAc,WACpE,IAAA,gMAAW,EAAC,OAAO,IAAA,8NAAiB,EAAC,MAAM,KAAK,WAC5C,AAAC,aAAa,WAAY,IAAA,oMAAQ,EAAC,QAAQ;QAAC;QAAM;KAAQ,EAAE,WACxD,AAAC,CAAC,aAAa,WAAY,IAAA,oMAAQ,EAAC,QAAQ;QAAC;QAAM;KAAQ,EAAE,WACzD,AAAC,aAAa,CAAC,WAAY,IAAA,oMAAQ,EAAC,QAAQ;QAAC;QAAM;KAAQ,EAAE,WACzD,IAAA,gMAAU,EAAC;QAAE,GAAG,YAAY,MAAM,aAAa;QAAE,GAAG,OAAO;IAAC;AACpF","ignoreList":[0]}},
    {"offset": {"line": 4784, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs"],"sourcesContent":["import { MappedResult } from '../mapped/index.mjs';\nimport { Partial } from './partial.mjs';\nimport { Clone } from '../clone/value.mjs';\n// prettier-ignore\nfunction FromProperties(K, options) {\n    const Acc = {};\n    for (const K2 of globalThis.Object.getOwnPropertyNames(K))\n        Acc[K2] = Partial(K[K2], Clone(options));\n    return Acc;\n}\n// prettier-ignore\nfunction FromMappedResult(R, options) {\n    return FromProperties(R.properties, options);\n}\n// prettier-ignore\nexport function PartialFromMappedResult(R, options) {\n    const P = FromMappedResult(R, options);\n    return MappedResult(P);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACA,kBAAkB;AAClB,SAAS,eAAe,CAAC,EAAE,OAAO;IAC9B,MAAM,MAAM,CAAC;IACb,KAAK,MAAM,MAAM,WAAW,MAAM,CAAC,mBAAmB,CAAC,GACnD,GAAG,CAAC,GAAG,GAAG,IAAA,iMAAO,EAAC,CAAC,CAAC,GAAG,EAAE,IAAA,2LAAK,EAAC;IACnC,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,iBAAiB,CAAC,EAAE,OAAO;IAChC,OAAO,eAAe,EAAE,UAAU,EAAE;AACxC;AAEO,SAAS,wBAAwB,CAAC,EAAE,OAAO;IAC9C,MAAM,IAAI,iBAAiB,GAAG;IAC9B,OAAO,IAAA,8MAAY,EAAC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 4812, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/partial/partial.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Computed } from '../computed/index.mjs';\nimport { Optional } from '../optional/index.mjs';\nimport { Object } from '../object/index.mjs';\nimport { Intersect } from '../intersect/index.mjs';\nimport { Union } from '../union/index.mjs';\nimport { Ref } from '../ref/index.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { TransformKind } from '../symbols/index.mjs';\nimport { PartialFromMappedResult } from './partial-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// KindGuard\n// ------------------------------------------------------------------\nimport * as KindGuard from '../guard/kind.mjs';\n// prettier-ignore\nfunction FromComputed(target, parameters) {\n    return Computed('Partial', [Computed(target, parameters)]);\n}\n// prettier-ignore\nfunction FromRef($ref) {\n    return Computed('Partial', [Ref($ref)]);\n}\n// prettier-ignore\nfunction FromProperties(properties) {\n    const partialProperties = {};\n    for (const K of globalThis.Object.getOwnPropertyNames(properties))\n        partialProperties[K] = Optional(properties[K]);\n    return partialProperties;\n}\n// prettier-ignore\nfunction FromObject(type, properties) {\n    const options = Discard(type, [TransformKind, '$id', 'required', 'properties']);\n    const mappedProperties = FromProperties(properties);\n    return Object(mappedProperties, options);\n}\n// prettier-ignore\nfunction FromRest(types) {\n    return types.map(type => PartialResolve(type));\n}\n// ------------------------------------------------------------------\n// PartialResolve\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction PartialResolve(type) {\n    return (\n    // Mappable\n    KindGuard.IsComputed(type) ? FromComputed(type.target, type.parameters) :\n        KindGuard.IsRef(type) ? FromRef(type.$ref) :\n            KindGuard.IsIntersect(type) ? Intersect(FromRest(type.allOf)) :\n                KindGuard.IsUnion(type) ? Union(FromRest(type.anyOf)) :\n                    KindGuard.IsObject(type) ? FromObject(type, type.properties) :\n                        // Intrinsic\n                        KindGuard.IsBigInt(type) ? type :\n                            KindGuard.IsBoolean(type) ? type :\n                                KindGuard.IsInteger(type) ? type :\n                                    KindGuard.IsLiteral(type) ? type :\n                                        KindGuard.IsNull(type) ? type :\n                                            KindGuard.IsNumber(type) ? type :\n                                                KindGuard.IsString(type) ? type :\n                                                    KindGuard.IsSymbol(type) ? type :\n                                                        KindGuard.IsUndefined(type) ? type :\n                                                            // Passthrough\n                                                            Object({}));\n}\n/** `[Json]` Constructs a type where all properties are optional */\nexport function Partial(type, options) {\n    if (KindGuard.IsMappedResult(type)) {\n        return PartialFromMappedResult(type, options);\n    }\n    else {\n        // special: mapping types require overridable options\n        return CreateType({ ...PartialResolve(type), ...options });\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;;;;;;;;;;AACA,kBAAkB;AAClB,SAAS,aAAa,MAAM,EAAE,UAAU;IACpC,OAAO,IAAA,oMAAQ,EAAC,WAAW;QAAC,IAAA,oMAAQ,EAAC,QAAQ;KAAY;AAC7D;AACA,kBAAkB;AAClB,SAAS,QAAQ,IAAI;IACjB,OAAO,IAAA,oMAAQ,EAAC,WAAW;QAAC,IAAA,qLAAG,EAAC;KAAM;AAC1C;AACA,kBAAkB;AAClB,SAAS,eAAe,UAAU;IAC9B,MAAM,oBAAoB,CAAC;IAC3B,KAAK,MAAM,KAAK,WAAW,MAAM,CAAC,mBAAmB,CAAC,YAClD,iBAAiB,CAAC,EAAE,GAAG,IAAA,oMAAQ,EAAC,UAAU,CAAC,EAAE;IACjD,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,WAAW,IAAI,EAAE,UAAU;IAChC,MAAM,UAAU,IAAA,iMAAO,EAAC,MAAM;QAAC,uMAAa;QAAE;QAAO;QAAY;KAAa;IAC9E,MAAM,mBAAmB,eAAe;IACxC,OAAO,IAAA,8LAAM,EAAC,kBAAkB;AACpC;AACA,kBAAkB;AAClB,SAAS,SAAS,KAAK;IACnB,OAAO,MAAM,GAAG,CAAC,CAAA,OAAQ,eAAe;AAC5C;AACA,qEAAqE;AACrE,iBAAiB;AACjB,qEAAqE;AACrE,kBAAkB;AAClB,SAAS,eAAe,IAAI;IACxB,OACA,WAAW;IACX,+LAAoB,CAAC,QAAQ,aAAa,KAAK,MAAM,EAAE,KAAK,UAAU,IAClE,0LAAe,CAAC,QAAQ,QAAQ,KAAK,IAAI,IACrC,gMAAqB,CAAC,QAAQ,IAAA,uMAAS,EAAC,SAAS,KAAK,KAAK,KACvD,4LAAiB,CAAC,QAAQ,IAAA,2LAAK,EAAC,SAAS,KAAK,KAAK,KAC/C,6LAAkB,CAAC,QAAQ,WAAW,MAAM,KAAK,UAAU,IACvD,YAAY;IACZ,6LAAkB,CAAC,QAAQ,OACvB,8LAAmB,CAAC,QAAQ,OACxB,8LAAmB,CAAC,QAAQ,OACxB,8LAAmB,CAAC,QAAQ,OACxB,2LAAgB,CAAC,QAAQ,OACrB,6LAAkB,CAAC,QAAQ,OACvB,6LAAkB,CAAC,QAAQ,OACvB,6LAAkB,CAAC,QAAQ,OACvB,gMAAqB,CAAC,QAAQ,OAC1B,cAAc;IACd,IAAA,8LAAM,EAAC,CAAC;AACpE;AAEO,SAAS,QAAQ,IAAI,EAAE,OAAO;IACjC,IAAI,mMAAwB,CAAC,OAAO;QAChC,OAAO,IAAA,6OAAuB,EAAC,MAAM;IACzC,OACK;QACD,qDAAqD;QACrD,OAAO,IAAA,gMAAU,EAAC;YAAE,GAAG,eAAe,KAAK;YAAE,GAAG,OAAO;QAAC;IAC5D;AACJ","ignoreList":[0]}},
    {"offset": {"line": 4899, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs"],"sourcesContent":["import { MappedResult } from '../mapped/index.mjs';\nimport { Required } from './required.mjs';\n// prettier-ignore\nfunction FromProperties(P, options) {\n    const Acc = {};\n    for (const K2 of globalThis.Object.getOwnPropertyNames(P))\n        Acc[K2] = Required(P[K2], options);\n    return Acc;\n}\n// prettier-ignore\nfunction FromMappedResult(R, options) {\n    return FromProperties(R.properties, options);\n}\n// prettier-ignore\nexport function RequiredFromMappedResult(R, options) {\n    const P = FromMappedResult(R, options);\n    return MappedResult(P);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACA,kBAAkB;AAClB,SAAS,eAAe,CAAC,EAAE,OAAO;IAC9B,MAAM,MAAM,CAAC;IACb,KAAK,MAAM,MAAM,WAAW,MAAM,CAAC,mBAAmB,CAAC,GACnD,GAAG,CAAC,GAAG,GAAG,IAAA,oMAAQ,EAAC,CAAC,CAAC,GAAG,EAAE;IAC9B,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,iBAAiB,CAAC,EAAE,OAAO;IAChC,OAAO,eAAe,EAAE,UAAU,EAAE;AACxC;AAEO,SAAS,yBAAyB,CAAC,EAAE,OAAO;IAC/C,MAAM,IAAI,iBAAiB,GAAG;IAC9B,OAAO,IAAA,8MAAY,EAAC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 4925, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/required/required.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Computed } from '../computed/index.mjs';\nimport { Object } from '../object/index.mjs';\nimport { Intersect } from '../intersect/index.mjs';\nimport { Union } from '../union/index.mjs';\nimport { Ref } from '../ref/index.mjs';\nimport { OptionalKind, TransformKind } from '../symbols/index.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { RequiredFromMappedResult } from './required-from-mapped-result.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport * as KindGuard from '../guard/kind.mjs';\n// prettier-ignore\nfunction FromComputed(target, parameters) {\n    return Computed('Required', [Computed(target, parameters)]);\n}\n// prettier-ignore\nfunction FromRef($ref) {\n    return Computed('Required', [Ref($ref)]);\n}\n// prettier-ignore\nfunction FromProperties(properties) {\n    const requiredProperties = {};\n    for (const K of globalThis.Object.getOwnPropertyNames(properties))\n        requiredProperties[K] = Discard(properties[K], [OptionalKind]);\n    return requiredProperties;\n}\n// prettier-ignore\nfunction FromObject(type, properties) {\n    const options = Discard(type, [TransformKind, '$id', 'required', 'properties']);\n    const mappedProperties = FromProperties(properties);\n    return Object(mappedProperties, options);\n}\n// prettier-ignore\nfunction FromRest(types) {\n    return types.map(type => RequiredResolve(type));\n}\n// ------------------------------------------------------------------\n// RequiredResolve\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction RequiredResolve(type) {\n    return (\n    // Mappable\n    KindGuard.IsComputed(type) ? FromComputed(type.target, type.parameters) :\n        KindGuard.IsRef(type) ? FromRef(type.$ref) :\n            KindGuard.IsIntersect(type) ? Intersect(FromRest(type.allOf)) :\n                KindGuard.IsUnion(type) ? Union(FromRest(type.anyOf)) :\n                    KindGuard.IsObject(type) ? FromObject(type, type.properties) :\n                        // Intrinsic\n                        KindGuard.IsBigInt(type) ? type :\n                            KindGuard.IsBoolean(type) ? type :\n                                KindGuard.IsInteger(type) ? type :\n                                    KindGuard.IsLiteral(type) ? type :\n                                        KindGuard.IsNull(type) ? type :\n                                            KindGuard.IsNumber(type) ? type :\n                                                KindGuard.IsString(type) ? type :\n                                                    KindGuard.IsSymbol(type) ? type :\n                                                        KindGuard.IsUndefined(type) ? type :\n                                                            // Passthrough\n                                                            Object({}));\n}\n/** `[Json]` Constructs a type where all properties are required */\nexport function Required(type, options) {\n    if (KindGuard.IsMappedResult(type)) {\n        return RequiredFromMappedResult(type, options);\n    }\n    else {\n        // special: mapping types require overridable options\n        return CreateType({ ...RequiredResolve(type), ...options });\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;;;;;;;;;AACA,kBAAkB;AAClB,SAAS,aAAa,MAAM,EAAE,UAAU;IACpC,OAAO,IAAA,oMAAQ,EAAC,YAAY;QAAC,IAAA,oMAAQ,EAAC,QAAQ;KAAY;AAC9D;AACA,kBAAkB;AAClB,SAAS,QAAQ,IAAI;IACjB,OAAO,IAAA,oMAAQ,EAAC,YAAY;QAAC,IAAA,qLAAG,EAAC;KAAM;AAC3C;AACA,kBAAkB;AAClB,SAAS,eAAe,UAAU;IAC9B,MAAM,qBAAqB,CAAC;IAC5B,KAAK,MAAM,KAAK,WAAW,MAAM,CAAC,mBAAmB,CAAC,YAClD,kBAAkB,CAAC,EAAE,GAAG,IAAA,iMAAO,EAAC,UAAU,CAAC,EAAE,EAAE;QAAC,sMAAY;KAAC;IACjE,OAAO;AACX;AACA,kBAAkB;AAClB,SAAS,WAAW,IAAI,EAAE,UAAU;IAChC,MAAM,UAAU,IAAA,iMAAO,EAAC,MAAM;QAAC,uMAAa;QAAE;QAAO;QAAY;KAAa;IAC9E,MAAM,mBAAmB,eAAe;IACxC,OAAO,IAAA,8LAAM,EAAC,kBAAkB;AACpC;AACA,kBAAkB;AAClB,SAAS,SAAS,KAAK;IACnB,OAAO,MAAM,GAAG,CAAC,CAAA,OAAQ,gBAAgB;AAC7C;AACA,qEAAqE;AACrE,kBAAkB;AAClB,qEAAqE;AACrE,kBAAkB;AAClB,SAAS,gBAAgB,IAAI;IACzB,OACA,WAAW;IACX,+LAAoB,CAAC,QAAQ,aAAa,KAAK,MAAM,EAAE,KAAK,UAAU,IAClE,0LAAe,CAAC,QAAQ,QAAQ,KAAK,IAAI,IACrC,gMAAqB,CAAC,QAAQ,IAAA,uMAAS,EAAC,SAAS,KAAK,KAAK,KACvD,4LAAiB,CAAC,QAAQ,IAAA,2LAAK,EAAC,SAAS,KAAK,KAAK,KAC/C,6LAAkB,CAAC,QAAQ,WAAW,MAAM,KAAK,UAAU,IACvD,YAAY;IACZ,6LAAkB,CAAC,QAAQ,OACvB,8LAAmB,CAAC,QAAQ,OACxB,8LAAmB,CAAC,QAAQ,OACxB,8LAAmB,CAAC,QAAQ,OACxB,2LAAgB,CAAC,QAAQ,OACrB,6LAAkB,CAAC,QAAQ,OACvB,6LAAkB,CAAC,QAAQ,OACvB,6LAAkB,CAAC,QAAQ,OACvB,gMAAqB,CAAC,QAAQ,OAC1B,cAAc;IACd,IAAA,8LAAM,EAAC,CAAC;AACpE;AAEO,SAAS,SAAS,IAAI,EAAE,OAAO;IAClC,IAAI,mMAAwB,CAAC,OAAO;QAChC,OAAO,IAAA,gPAAwB,EAAC,MAAM;IAC1C,OACK;QACD,qDAAqD;QACrD,OAAO,IAAA,gMAAU,EAAC;YAAE,GAAG,gBAAgB,KAAK;YAAE,GAAG,OAAO;QAAC;IAC7D;AACJ","ignoreList":[0]}},
    {"offset": {"line": 5012, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/module/compute.mjs"],"sourcesContent":["import { CreateType } from '../create/index.mjs';\nimport { CloneType } from '../clone/index.mjs';\nimport { Discard } from '../discard/index.mjs';\nimport { Array } from '../array/index.mjs';\nimport { Awaited } from '../awaited/index.mjs';\nimport { AsyncIterator } from '../async-iterator/index.mjs';\nimport { Constructor } from '../constructor/index.mjs';\nimport { Index } from '../indexed/index.mjs';\nimport { Function as FunctionType } from '../function/index.mjs';\nimport { Intersect } from '../intersect/index.mjs';\nimport { Iterator } from '../iterator/index.mjs';\nimport { KeyOf } from '../keyof/index.mjs';\nimport { Object } from '../object/index.mjs';\nimport { Omit } from '../omit/index.mjs';\nimport { Pick } from '../pick/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport { Partial } from '../partial/index.mjs';\nimport { RecordValue, RecordPattern } from '../record/index.mjs';\nimport { Required } from '../required/index.mjs';\nimport { Tuple } from '../tuple/index.mjs';\nimport { Union } from '../union/index.mjs';\n// ------------------------------------------------------------------\n// Symbols\n// ------------------------------------------------------------------\nimport { TransformKind, OptionalKind, ReadonlyKind } from '../symbols/index.mjs';\n// ------------------------------------------------------------------\n// KindGuard\n// ------------------------------------------------------------------\nimport * as KindGuard from '../guard/kind.mjs';\n// prettier-ignore\nfunction DereferenceParameters(moduleProperties, types) {\n    return types.map((type) => {\n        return KindGuard.IsRef(type)\n            ? Dereference(moduleProperties, type.$ref)\n            : FromType(moduleProperties, type);\n    });\n}\n// prettier-ignore\nfunction Dereference(moduleProperties, ref) {\n    return (ref in moduleProperties\n        ? KindGuard.IsRef(moduleProperties[ref])\n            ? Dereference(moduleProperties, moduleProperties[ref].$ref)\n            : FromType(moduleProperties, moduleProperties[ref])\n        : Never());\n}\n// prettier-ignore\nfunction FromAwaited(parameters) {\n    return Awaited(parameters[0]);\n}\n// prettier-ignore\nfunction FromIndex(parameters) {\n    return Index(parameters[0], parameters[1]);\n}\n// prettier-ignore\nfunction FromKeyOf(parameters) {\n    return KeyOf(parameters[0]);\n}\n// prettier-ignore\nfunction FromPartial(parameters) {\n    return Partial(parameters[0]);\n}\n// prettier-ignore\nfunction FromOmit(parameters) {\n    return Omit(parameters[0], parameters[1]);\n}\n// prettier-ignore\nfunction FromPick(parameters) {\n    return Pick(parameters[0], parameters[1]);\n}\n// prettier-ignore\nfunction FromRequired(parameters) {\n    return Required(parameters[0]);\n}\n// prettier-ignore\nfunction FromComputed(moduleProperties, target, parameters) {\n    const dereferenced = DereferenceParameters(moduleProperties, parameters);\n    return (target === 'Awaited' ? FromAwaited(dereferenced) :\n        target === 'Index' ? FromIndex(dereferenced) :\n            target === 'KeyOf' ? FromKeyOf(dereferenced) :\n                target === 'Partial' ? FromPartial(dereferenced) :\n                    target === 'Omit' ? FromOmit(dereferenced) :\n                        target === 'Pick' ? FromPick(dereferenced) :\n                            target === 'Required' ? FromRequired(dereferenced) :\n                                Never());\n}\nfunction FromArray(moduleProperties, type) {\n    return Array(FromType(moduleProperties, type));\n}\nfunction FromAsyncIterator(moduleProperties, type) {\n    return AsyncIterator(FromType(moduleProperties, type));\n}\n// prettier-ignore\nfunction FromConstructor(moduleProperties, parameters, instanceType) {\n    return Constructor(FromTypes(moduleProperties, parameters), FromType(moduleProperties, instanceType));\n}\n// prettier-ignore\nfunction FromFunction(moduleProperties, parameters, returnType) {\n    return FunctionType(FromTypes(moduleProperties, parameters), FromType(moduleProperties, returnType));\n}\nfunction FromIntersect(moduleProperties, types) {\n    return Intersect(FromTypes(moduleProperties, types));\n}\nfunction FromIterator(moduleProperties, type) {\n    return Iterator(FromType(moduleProperties, type));\n}\nfunction FromObject(moduleProperties, properties) {\n    return Object(globalThis.Object.keys(properties).reduce((result, key) => {\n        return { ...result, [key]: FromType(moduleProperties, properties[key]) };\n    }, {}));\n}\n// prettier-ignore\nfunction FromRecord(moduleProperties, type) {\n    const [value, pattern] = [FromType(moduleProperties, RecordValue(type)), RecordPattern(type)];\n    const result = CloneType(type);\n    result.patternProperties[pattern] = value;\n    return result;\n}\n// prettier-ignore\nfunction FromTransform(moduleProperties, transform) {\n    return (KindGuard.IsRef(transform))\n        ? { ...Dereference(moduleProperties, transform.$ref), [TransformKind]: transform[TransformKind] }\n        : transform;\n}\nfunction FromTuple(moduleProperties, types) {\n    return Tuple(FromTypes(moduleProperties, types));\n}\nfunction FromUnion(moduleProperties, types) {\n    return Union(FromTypes(moduleProperties, types));\n}\nfunction FromTypes(moduleProperties, types) {\n    return types.map((type) => FromType(moduleProperties, type));\n}\n// prettier-ignore\nexport function FromType(moduleProperties, type) {\n    return (\n    // Modifiers\n    KindGuard.IsOptional(type) ? CreateType(FromType(moduleProperties, Discard(type, [OptionalKind])), type) :\n        KindGuard.IsReadonly(type) ? CreateType(FromType(moduleProperties, Discard(type, [ReadonlyKind])), type) :\n            // Transform\n            KindGuard.IsTransform(type) ? CreateType(FromTransform(moduleProperties, type), type) :\n                // Types\n                KindGuard.IsArray(type) ? CreateType(FromArray(moduleProperties, type.items), type) :\n                    KindGuard.IsAsyncIterator(type) ? CreateType(FromAsyncIterator(moduleProperties, type.items), type) :\n                        KindGuard.IsComputed(type) ? CreateType(FromComputed(moduleProperties, type.target, type.parameters)) :\n                            KindGuard.IsConstructor(type) ? CreateType(FromConstructor(moduleProperties, type.parameters, type.returns), type) :\n                                KindGuard.IsFunction(type) ? CreateType(FromFunction(moduleProperties, type.parameters, type.returns), type) :\n                                    KindGuard.IsIntersect(type) ? CreateType(FromIntersect(moduleProperties, type.allOf), type) :\n                                        KindGuard.IsIterator(type) ? CreateType(FromIterator(moduleProperties, type.items), type) :\n                                            KindGuard.IsObject(type) ? CreateType(FromObject(moduleProperties, type.properties), type) :\n                                                KindGuard.IsRecord(type) ? CreateType(FromRecord(moduleProperties, type)) :\n                                                    KindGuard.IsTuple(type) ? CreateType(FromTuple(moduleProperties, type.items || []), type) :\n                                                        KindGuard.IsUnion(type) ? CreateType(FromUnion(moduleProperties, type.anyOf), type) :\n                                                            type);\n}\n// prettier-ignore\nexport function ComputeType(moduleProperties, key) {\n    return (key in moduleProperties\n        ? FromType(moduleProperties, moduleProperties[key])\n        : Never());\n}\n// prettier-ignore\nexport function ComputeModuleProperties(moduleProperties) {\n    return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {\n        return { ...result, [key]: ComputeType(moduleProperties, key) };\n    }, {});\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5194, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/module/module.mjs"],"sourcesContent":["import { CreateType } from '../create/index.mjs';\nimport { Kind } from '../symbols/index.mjs';\n// ------------------------------------------------------------------\n// Module Infrastructure Types\n// ------------------------------------------------------------------\nimport { ComputeModuleProperties } from './compute.mjs';\n// ------------------------------------------------------------------\n// Module\n// ------------------------------------------------------------------\n// prettier-ignore\nexport class TModule {\n    constructor($defs) {\n        const computed = ComputeModuleProperties($defs);\n        const identified = this.WithIdentifiers(computed);\n        this.$defs = identified;\n    }\n    /** `[Json]` Imports a Type by Key. */\n    Import(key, options) {\n        const $defs = { ...this.$defs, [key]: CreateType(this.$defs[key], options) };\n        return CreateType({ [Kind]: 'Import', $defs, $ref: key });\n    }\n    // prettier-ignore\n    WithIdentifiers($defs) {\n        return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {\n            return { ...result, [key]: { ...$defs[key], $id: key } };\n        }, {});\n    }\n}\n/** `[Json]` Creates a Type Definition Module. */\nexport function Module(properties) {\n    return new TModule(properties);\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA,qEAAqE;AACrE,8BAA8B;AAC9B,qEAAqE;AACrE;;;;AAKO,MAAM;IACT,YAAY,KAAK,CAAE;QACf,MAAM,WAAW,IAAA,gNAAuB,EAAC;QACzC,MAAM,aAAa,IAAI,CAAC,eAAe,CAAC;QACxC,IAAI,CAAC,KAAK,GAAG;IACjB;IACA,oCAAoC,GACpC,OAAO,GAAG,EAAE,OAAO,EAAE;QACjB,MAAM,QAAQ;YAAE,GAAG,IAAI,CAAC,KAAK;YAAE,CAAC,IAAI,EAAE,IAAA,gMAAU,EAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE;QAAS;QAC3E,OAAO,IAAA,gMAAU,EAAC;YAAE,CAAC,8LAAI,CAAC,EAAE;YAAU;YAAO,MAAM;QAAI;IAC3D;IACA,kBAAkB;IAClB,gBAAgB,KAAK,EAAE;QACnB,OAAO,WAAW,MAAM,CAAC,mBAAmB,CAAC,OAAO,MAAM,CAAC,CAAC,QAAQ;YAChE,OAAO;gBAAE,GAAG,MAAM;gBAAE,CAAC,IAAI,EAAE;oBAAE,GAAG,KAAK,CAAC,IAAI;oBAAE,KAAK;gBAAI;YAAE;QAC3D,GAAG,CAAC;IACR;AACJ;AAEO,SAAS,OAAO,UAAU;IAC7B,OAAO,IAAI,QAAQ;AACvB","ignoreList":[0]}},
    {"offset": {"line": 5246, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/not/not.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Not type */\nexport function Not(type, options) {\n    return CreateType({ [Kind]: 'Not', not: type }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,IAAI,IAAI,EAAE,OAAO;IAC7B,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAO,KAAK;IAAK,GAAG;AACpD","ignoreList":[0]}},
    {"offset": {"line": 5264, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/parameters/parameters.mjs"],"sourcesContent":["import { Tuple } from '../tuple/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport * as KindGuard from '../guard/kind.mjs';\n/** `[JavaScript]` Extracts the Parameters from the given Function type */\nexport function Parameters(schema, options) {\n    return (KindGuard.IsFunction(schema) ? Tuple(schema.parameters, options) : Never());\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,SAAS,WAAW,MAAM,EAAE,OAAO;IACtC,OAAQ,+LAAoB,CAAC,UAAU,IAAA,2LAAK,EAAC,OAAO,UAAU,EAAE,WAAW,IAAA,2LAAK;AACpF","ignoreList":[0]}},
    {"offset": {"line": 5281, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/recursive/recursive.mjs"],"sourcesContent":["import { CloneType } from '../clone/type.mjs';\nimport { CreateType } from '../create/type.mjs';\nimport { IsUndefined } from '../guard/value.mjs';\nimport { Kind, Hint } from '../symbols/index.mjs';\n// Auto Tracked For Recursive Types without ID's\nlet Ordinal = 0;\n/** `[Json]` Creates a Recursive type */\nexport function Recursive(callback, options = {}) {\n    if (IsUndefined(options.$id))\n        options.$id = `T${Ordinal++}`;\n    const thisType = CloneType(callback({ [Kind]: 'This', $ref: `${options.$id}` }));\n    thisType.$id = options.$id;\n    // prettier-ignore\n    return CreateType({ [Hint]: 'Recursive', ...thisType }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AACA,gDAAgD;AAChD,IAAI,UAAU;AAEP,SAAS,UAAU,QAAQ,EAAE,UAAU,CAAC,CAAC;IAC5C,IAAI,IAAA,iMAAW,EAAC,QAAQ,GAAG,GACvB,QAAQ,GAAG,GAAG,CAAC,CAAC,EAAE,WAAW;IACjC,MAAM,WAAW,IAAA,8LAAS,EAAC,SAAS;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAQ,MAAM,GAAG,QAAQ,GAAG,EAAE;IAAC;IAC7E,SAAS,GAAG,GAAG,QAAQ,GAAG;IAC1B,kBAAkB;IAClB,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAa,GAAG,QAAQ;IAAC,GAAG;AAC5D","ignoreList":[0]}},
    {"offset": {"line": 5312, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/regexp/regexp.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { IsString } from '../guard/value.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a RegExp type */\nexport function RegExp(unresolved, options) {\n    const expr = IsString(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;\n    return CreateType({ [Kind]: 'RegExp', type: 'RegExp', source: expr.source, flags: expr.flags }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,SAAS,OAAO,UAAU,EAAE,OAAO;IACtC,MAAM,OAAO,IAAA,8LAAQ,EAAC,cAAc,IAAI,WAAW,MAAM,CAAC,cAAc;IACxE,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAU,MAAM;QAAU,QAAQ,KAAK,MAAM;QAAE,OAAO,KAAK,KAAK;IAAC,GAAG;AACpG","ignoreList":[0]}},
    {"offset": {"line": 5335, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/rest/rest.mjs"],"sourcesContent":["// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsIntersect, IsUnion, IsTuple } from '../guard/kind.mjs';\n// prettier-ignore\nfunction RestResolve(T) {\n    return (IsIntersect(T) ? T.allOf :\n        IsUnion(T) ? T.anyOf :\n            IsTuple(T) ? T.items ?? [] :\n                []);\n}\n/** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */\nexport function Rest(T) {\n    return RestResolve(T);\n}\n"],"names":[],"mappings":";;;;AAAA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;AACA,kBAAkB;AAClB,SAAS,YAAY,CAAC;IAClB,OAAQ,IAAA,gMAAW,EAAC,KAAK,EAAE,KAAK,GAC5B,IAAA,4LAAO,EAAC,KAAK,EAAE,KAAK,GAChB,IAAA,4LAAO,EAAC,KAAK,EAAE,KAAK,IAAI,EAAE,GACtB,EAAE;AAClB;AAEO,SAAS,KAAK,CAAC;IAClB,OAAO,YAAY;AACvB","ignoreList":[0]}},
    {"offset": {"line": 5355, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/return-type/return-type.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Never } from '../never/index.mjs';\nimport * as KindGuard from '../guard/kind.mjs';\n/** `[JavaScript]` Extracts the ReturnType from the given Function type */\nexport function ReturnType(schema, options) {\n    return (KindGuard.IsFunction(schema) ? CreateType(schema.returns, options) : Never(options));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,SAAS,WAAW,MAAM,EAAE,OAAO;IACtC,OAAQ,+LAAoB,CAAC,UAAU,IAAA,gMAAU,EAAC,OAAO,OAAO,EAAE,WAAW,IAAA,2LAAK,EAAC;AACvF","ignoreList":[0]}},
    {"offset": {"line": 5372, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/transform/transform.mjs"],"sourcesContent":["import { TransformKind } from '../symbols/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsTransform } from '../guard/kind.mjs';\n// ------------------------------------------------------------------\n// TransformBuilders\n// ------------------------------------------------------------------\nexport class TransformDecodeBuilder {\n    constructor(schema) {\n        this.schema = schema;\n    }\n    Decode(decode) {\n        return new TransformEncodeBuilder(this.schema, decode);\n    }\n}\n// prettier-ignore\nexport class TransformEncodeBuilder {\n    constructor(schema, decode) {\n        this.schema = schema;\n        this.decode = decode;\n    }\n    EncodeTransform(encode, schema) {\n        const Encode = (value) => schema[TransformKind].Encode(encode(value));\n        const Decode = (value) => this.decode(schema[TransformKind].Decode(value));\n        const Codec = { Encode: Encode, Decode: Decode };\n        return { ...schema, [TransformKind]: Codec };\n    }\n    EncodeSchema(encode, schema) {\n        const Codec = { Decode: this.decode, Encode: encode };\n        return { ...schema, [TransformKind]: Codec };\n    }\n    Encode(encode) {\n        return (IsTransform(this.schema) ? this.EncodeTransform(encode, this.schema) : this.EncodeSchema(encode, this.schema));\n    }\n}\n/** `[Json]` Creates a Transform type */\nexport function Transform(schema) {\n    return new TransformDecodeBuilder(schema);\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;AAIO,MAAM;IACT,YAAY,MAAM,CAAE;QAChB,IAAI,CAAC,MAAM,GAAG;IAClB;IACA,OAAO,MAAM,EAAE;QACX,OAAO,IAAI,uBAAuB,IAAI,CAAC,MAAM,EAAE;IACnD;AACJ;AAEO,MAAM;IACT,YAAY,MAAM,EAAE,MAAM,CAAE;QACxB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,MAAM,GAAG;IAClB;IACA,gBAAgB,MAAM,EAAE,MAAM,EAAE;QAC5B,MAAM,SAAS,CAAC,QAAU,MAAM,CAAC,uMAAa,CAAC,CAAC,MAAM,CAAC,OAAO;QAC9D,MAAM,SAAS,CAAC,QAAU,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,uMAAa,CAAC,CAAC,MAAM,CAAC;QACnE,MAAM,QAAQ;YAAE,QAAQ;YAAQ,QAAQ;QAAO;QAC/C,OAAO;YAAE,GAAG,MAAM;YAAE,CAAC,uMAAa,CAAC,EAAE;QAAM;IAC/C;IACA,aAAa,MAAM,EAAE,MAAM,EAAE;QACzB,MAAM,QAAQ;YAAE,QAAQ,IAAI,CAAC,MAAM;YAAE,QAAQ;QAAO;QACpD,OAAO;YAAE,GAAG,MAAM;YAAE,CAAC,uMAAa,CAAC,EAAE;QAAM;IAC/C;IACA,OAAO,MAAM,EAAE;QACX,OAAQ,IAAA,gMAAW,EAAC,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,eAAe,CAAC,QAAQ,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,YAAY,CAAC,QAAQ,IAAI,CAAC,MAAM;IACxH;AACJ;AAEO,SAAS,UAAU,MAAM;IAC5B,OAAO,IAAI,uBAAuB;AACtC","ignoreList":[0]}},
    {"offset": {"line": 5433, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/unsafe/unsafe.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[Json]` Creates a Unsafe type that will infers as the generic argument T */\nexport function Unsafe(options = {}) {\n    return CreateType({ [Kind]: options[Kind] ?? 'Unsafe' }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,OAAO,UAAU,CAAC,CAAC;IAC/B,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE,OAAO,CAAC,8LAAI,CAAC,IAAI;IAAS,GAAG;AAC7D","ignoreList":[0]}},
    {"offset": {"line": 5450, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/void/void.mjs"],"sourcesContent":["import { CreateType } from '../create/type.mjs';\nimport { Kind } from '../symbols/index.mjs';\n/** `[JavaScript]` Creates a Void type */\nexport function Void(options) {\n    return CreateType({ [Kind]: 'Void', type: 'void' }, options);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,KAAK,OAAO;IACxB,OAAO,IAAA,gMAAU,EAAC;QAAE,CAAC,8LAAI,CAAC,EAAE;QAAQ,MAAM;IAAO,GAAG;AACxD","ignoreList":[0]}},
    {"offset": {"line": 5661, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/type/json.mjs"],"sourcesContent":["import { Any } from '../any/index.mjs';\nimport { Array } from '../array/index.mjs';\nimport { Boolean } from '../boolean/index.mjs';\nimport { Composite } from '../composite/index.mjs';\nimport { Const } from '../const/index.mjs';\nimport { Enum } from '../enum/index.mjs';\nimport { Exclude } from '../exclude/index.mjs';\nimport { Extends } from '../extends/index.mjs';\nimport { Extract } from '../extract/index.mjs';\nimport { Index } from '../indexed/index.mjs';\nimport { Integer } from '../integer/index.mjs';\nimport { Intersect } from '../intersect/index.mjs';\nimport { Capitalize, Uncapitalize, Lowercase, Uppercase } from '../intrinsic/index.mjs';\nimport { KeyOf } from '../keyof/index.mjs';\nimport { Literal } from '../literal/index.mjs';\nimport { Mapped } from '../mapped/index.mjs';\nimport { Never } from '../never/index.mjs';\nimport { Not } from '../not/index.mjs';\nimport { Null } from '../null/index.mjs';\nimport { Module } from '../module/index.mjs';\nimport { Number } from '../number/index.mjs';\nimport { Object } from '../object/index.mjs';\nimport { Omit } from '../omit/index.mjs';\nimport { Optional } from '../optional/index.mjs';\nimport { Partial } from '../partial/index.mjs';\nimport { Pick } from '../pick/index.mjs';\nimport { Readonly } from '../readonly/index.mjs';\nimport { ReadonlyOptional } from '../readonly-optional/index.mjs';\nimport { Record } from '../record/index.mjs';\nimport { Recursive } from '../recursive/index.mjs';\nimport { Ref } from '../ref/index.mjs';\nimport { Required } from '../required/index.mjs';\nimport { Rest } from '../rest/index.mjs';\nimport { String } from '../string/index.mjs';\nimport { TemplateLiteral } from '../template-literal/index.mjs';\nimport { Transform } from '../transform/index.mjs';\nimport { Tuple } from '../tuple/index.mjs';\nimport { Union } from '../union/index.mjs';\nimport { Unknown } from '../unknown/index.mjs';\nimport { Unsafe } from '../unsafe/index.mjs';\n/** Json Type Builder with Static Resolution for TypeScript */\nexport class JsonTypeBuilder {\n    // ------------------------------------------------------------------------\n    // Modifiers\n    // ------------------------------------------------------------------------\n    /** `[Json]` Creates a Readonly and Optional property */\n    ReadonlyOptional(type) {\n        return ReadonlyOptional(type);\n    }\n    /** `[Json]` Creates a Readonly property */\n    Readonly(type, enable) {\n        return Readonly(type, enable ?? true);\n    }\n    /** `[Json]` Creates a Optional property */\n    Optional(type, enable) {\n        return Optional(type, enable ?? true);\n    }\n    // ------------------------------------------------------------------------\n    // Types\n    // ------------------------------------------------------------------------\n    /** `[Json]` Creates an Any type */\n    Any(options) {\n        return Any(options);\n    }\n    /** `[Json]` Creates an Array type */\n    Array(items, options) {\n        return Array(items, options);\n    }\n    /** `[Json]` Creates a Boolean type */\n    Boolean(options) {\n        return Boolean(options);\n    }\n    /** `[Json]` Intrinsic function to Capitalize LiteralString types */\n    Capitalize(schema, options) {\n        return Capitalize(schema, options);\n    }\n    /** `[Json]` Creates a Composite object type */\n    Composite(schemas, options) {\n        return Composite(schemas, options); // (error) TS 5.4.0-dev - review TComposite implementation\n    }\n    /** `[JavaScript]` Creates a readonly const type from the given value. */\n    Const(value, options) {\n        return Const(value, options);\n    }\n    /** `[Json]` Creates a Enum type */\n    Enum(item, options) {\n        return Enum(item, options);\n    }\n    /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */\n    Exclude(unionType, excludedMembers, options) {\n        return Exclude(unionType, excludedMembers, options);\n    }\n    /** `[Json]` Creates a Conditional type */\n    Extends(L, R, T, F, options) {\n        return Extends(L, R, T, F, options);\n    }\n    /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */\n    Extract(type, union, options) {\n        return Extract(type, union, options);\n    }\n    /** `[Json]` Returns an Indexed property type for the given keys */\n    Index(type, key, options) {\n        return Index(type, key, options);\n    }\n    /** `[Json]` Creates an Integer type */\n    Integer(options) {\n        return Integer(options);\n    }\n    /** `[Json]` Creates an Intersect type */\n    Intersect(types, options) {\n        return Intersect(types, options);\n    }\n    /** `[Json]` Creates a KeyOf type */\n    KeyOf(type, options) {\n        return KeyOf(type, options);\n    }\n    /** `[Json]` Creates a Literal type */\n    Literal(literalValue, options) {\n        return Literal(literalValue, options);\n    }\n    /** `[Json]` Intrinsic function to Lowercase LiteralString types */\n    Lowercase(type, options) {\n        return Lowercase(type, options);\n    }\n    /** `[Json]` Creates a Mapped object type */\n    Mapped(key, map, options) {\n        return Mapped(key, map, options);\n    }\n    /** `[Json]` Creates a Type Definition Module. */\n    Module(properties) {\n        return Module(properties);\n    }\n    /** `[Json]` Creates a Never type */\n    Never(options) {\n        return Never(options);\n    }\n    /** `[Json]` Creates a Not type */\n    Not(type, options) {\n        return Not(type, options);\n    }\n    /** `[Json]` Creates a Null type */\n    Null(options) {\n        return Null(options);\n    }\n    /** `[Json]` Creates a Number type */\n    Number(options) {\n        return Number(options);\n    }\n    /** `[Json]` Creates an Object type */\n    Object(properties, options) {\n        return Object(properties, options);\n    }\n    /** `[Json]` Constructs a type whose keys are omitted from the given type */\n    Omit(schema, selector, options) {\n        return Omit(schema, selector, options);\n    }\n    /** `[Json]` Constructs a type where all properties are optional */\n    Partial(type, options) {\n        return Partial(type, options);\n    }\n    /** `[Json]` Constructs a type whose keys are picked from the given type */\n    Pick(type, key, options) {\n        return Pick(type, key, options);\n    }\n    /** `[Json]` Creates a Record type */\n    Record(key, value, options) {\n        return Record(key, value, options);\n    }\n    /** `[Json]` Creates a Recursive type */\n    Recursive(callback, options) {\n        return Recursive(callback, options);\n    }\n    /** `[Json]` Creates a Ref type. The referenced type must contain a $id */\n    Ref(...args) {\n        return Ref(args[0], args[1]);\n    }\n    /** `[Json]` Constructs a type where all properties are required */\n    Required(type, options) {\n        return Required(type, options);\n    }\n    /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */\n    Rest(type) {\n        return Rest(type);\n    }\n    /** `[Json]` Creates a String type */\n    String(options) {\n        return String(options);\n    }\n    /** `[Json]` Creates a TemplateLiteral type */\n    TemplateLiteral(unresolved, options) {\n        return TemplateLiteral(unresolved, options);\n    }\n    /** `[Json]` Creates a Transform type */\n    Transform(type) {\n        return Transform(type);\n    }\n    /** `[Json]` Creates a Tuple type */\n    Tuple(types, options) {\n        return Tuple(types, options);\n    }\n    /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */\n    Uncapitalize(type, options) {\n        return Uncapitalize(type, options);\n    }\n    /** `[Json]` Creates a Union type */\n    Union(types, options) {\n        return Union(types, options);\n    }\n    /** `[Json]` Creates an Unknown type */\n    Unknown(options) {\n        return Unknown(options);\n    }\n    /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */\n    Unsafe(options) {\n        return Unsafe(options);\n    }\n    /** `[Json]` Intrinsic function to Uppercase LiteralString types */\n    Uppercase(schema, options) {\n        return Uppercase(schema, options);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5889, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/type/javascript.mjs"],"sourcesContent":["import { JsonTypeBuilder } from './json.mjs';\nimport { Argument } from '../argument/index.mjs';\nimport { AsyncIterator } from '../async-iterator/index.mjs';\nimport { Awaited } from '../awaited/index.mjs';\nimport { BigInt } from '../bigint/index.mjs';\nimport { Constructor } from '../constructor/index.mjs';\nimport { ConstructorParameters } from '../constructor-parameters/index.mjs';\nimport { Date } from '../date/index.mjs';\nimport { Function as FunctionType } from '../function/index.mjs';\nimport { InstanceType } from '../instance-type/index.mjs';\nimport { Instantiate } from '../instantiate/index.mjs';\nimport { Iterator } from '../iterator/index.mjs';\nimport { Parameters } from '../parameters/index.mjs';\nimport { Promise } from '../promise/index.mjs';\nimport { RegExp } from '../regexp/index.mjs';\nimport { ReturnType } from '../return-type/index.mjs';\nimport { Symbol } from '../symbol/index.mjs';\nimport { Uint8Array } from '../uint8array/index.mjs';\nimport { Undefined } from '../undefined/index.mjs';\nimport { Void } from '../void/index.mjs';\n/** JavaScript Type Builder with Static Resolution for TypeScript */\nexport class JavaScriptTypeBuilder extends JsonTypeBuilder {\n    /** `[JavaScript]` Creates a Generic Argument Type */\n    Argument(index) {\n        return Argument(index);\n    }\n    /** `[JavaScript]` Creates a AsyncIterator type */\n    AsyncIterator(items, options) {\n        return AsyncIterator(items, options);\n    }\n    /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */\n    Awaited(schema, options) {\n        return Awaited(schema, options);\n    }\n    /** `[JavaScript]` Creates a BigInt type */\n    BigInt(options) {\n        return BigInt(options);\n    }\n    /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */\n    ConstructorParameters(schema, options) {\n        return ConstructorParameters(schema, options);\n    }\n    /** `[JavaScript]` Creates a Constructor type */\n    Constructor(parameters, instanceType, options) {\n        return Constructor(parameters, instanceType, options);\n    }\n    /** `[JavaScript]` Creates a Date type */\n    Date(options = {}) {\n        return Date(options);\n    }\n    /** `[JavaScript]` Creates a Function type */\n    Function(parameters, returnType, options) {\n        return FunctionType(parameters, returnType, options);\n    }\n    /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */\n    InstanceType(schema, options) {\n        return InstanceType(schema, options);\n    }\n    /** `[JavaScript]` Instantiates a type with the given parameters */\n    Instantiate(schema, parameters) {\n        return Instantiate(schema, parameters);\n    }\n    /** `[JavaScript]` Creates an Iterator type */\n    Iterator(items, options) {\n        return Iterator(items, options);\n    }\n    /** `[JavaScript]` Extracts the Parameters from the given Function type */\n    Parameters(schema, options) {\n        return Parameters(schema, options);\n    }\n    /** `[JavaScript]` Creates a Promise type */\n    Promise(item, options) {\n        return Promise(item, options);\n    }\n    /** `[JavaScript]` Creates a RegExp type */\n    RegExp(unresolved, options) {\n        return RegExp(unresolved, options);\n    }\n    /** `[JavaScript]` Extracts the ReturnType from the given Function type */\n    ReturnType(type, options) {\n        return ReturnType(type, options);\n    }\n    /** `[JavaScript]` Creates a Symbol type */\n    Symbol(options) {\n        return Symbol(options);\n    }\n    /** `[JavaScript]` Creates a Undefined type */\n    Undefined(options) {\n        return Undefined(options);\n    }\n    /** `[JavaScript]` Creates a Uint8Array type */\n    Uint8Array(options) {\n        return Uint8Array(options);\n    }\n    /** `[JavaScript]` Creates a Void type */\n    Void(options) {\n        return Void(options);\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AAEO,MAAM,8BAA8B,mMAAe;IACtD,mDAAmD,GACnD,SAAS,KAAK,EAAE;QACZ,OAAO,IAAA,oMAAQ,EAAC;IACpB;IACA,gDAAgD,GAChD,cAAc,KAAK,EAAE,OAAO,EAAE;QAC1B,OAAO,IAAA,2NAAa,EAAC,OAAO;IAChC;IACA,6EAA6E,GAC7E,QAAQ,MAAM,EAAE,OAAO,EAAE;QACrB,OAAO,IAAA,iMAAO,EAAC,QAAQ;IAC3B;IACA,yCAAyC,GACzC,OAAO,OAAO,EAAE;QACZ,OAAO,IAAA,8LAAM,EAAC;IAClB;IACA,sFAAsF,GACtF,sBAAsB,MAAM,EAAE,OAAO,EAAE;QACnC,OAAO,IAAA,mPAAqB,EAAC,QAAQ;IACzC;IACA,8CAA8C,GAC9C,YAAY,UAAU,EAAE,YAAY,EAAE,OAAO,EAAE;QAC3C,OAAO,IAAA,6MAAW,EAAC,YAAY,cAAc;IACjD;IACA,uCAAuC,GACvC,KAAK,UAAU,CAAC,CAAC,EAAE;QACf,OAAO,IAAA,wLAAI,EAAC;IAChB;IACA,2CAA2C,GAC3C,SAAS,UAAU,EAAE,UAAU,EAAE,OAAO,EAAE;QACtC,OAAO,IAAA,oMAAY,EAAC,YAAY,YAAY;IAChD;IACA,6EAA6E,GAC7E,aAAa,MAAM,EAAE,OAAO,EAAE;QAC1B,OAAO,IAAA,wNAAY,EAAC,QAAQ;IAChC;IACA,iEAAiE,GACjE,YAAY,MAAM,EAAE,UAAU,EAAE;QAC5B,OAAO,IAAA,6MAAW,EAAC,QAAQ;IAC/B;IACA,4CAA4C,GAC5C,SAAS,KAAK,EAAE,OAAO,EAAE;QACrB,OAAO,IAAA,oMAAQ,EAAC,OAAO;IAC3B;IACA,wEAAwE,GACxE,WAAW,MAAM,EAAE,OAAO,EAAE;QACxB,OAAO,IAAA,0MAAU,EAAC,QAAQ;IAC9B;IACA,0CAA0C,GAC1C,QAAQ,IAAI,EAAE,OAAO,EAAE;QACnB,OAAO,IAAA,iMAAO,EAAC,MAAM;IACzB;IACA,yCAAyC,GACzC,OAAO,UAAU,EAAE,OAAO,EAAE;QACxB,OAAO,IAAA,8LAAM,EAAC,YAAY;IAC9B;IACA,wEAAwE,GACxE,WAAW,IAAI,EAAE,OAAO,EAAE;QACtB,OAAO,IAAA,kNAAU,EAAC,MAAM;IAC5B;IACA,yCAAyC,GACzC,OAAO,OAAO,EAAE;QACZ,OAAO,IAAA,8LAAM,EAAC;IAClB;IACA,4CAA4C,GAC5C,UAAU,OAAO,EAAE;QACf,OAAO,IAAA,uMAAS,EAAC;IACrB;IACA,6CAA6C,GAC7C,WAAW,OAAO,EAAE;QAChB,OAAO,IAAA,0MAAU,EAAC;IACtB;IACA,uCAAuC,GACvC,KAAK,OAAO,EAAE;QACV,OAAO,IAAA,wLAAI,EAAC;IAChB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 5996, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/type/index.mjs"],"sourcesContent":["// ------------------------------------------------------------------\n// JsonTypeBuilder\n// ------------------------------------------------------------------\nexport { JsonTypeBuilder } from './json.mjs';\n// ------------------------------------------------------------------\n// JavaScriptTypeBuilder\n// ------------------------------------------------------------------\nimport * as TypeBuilder from './type.mjs';\nimport { JavaScriptTypeBuilder } from './javascript.mjs';\n/** JavaScript Type Builder with Static Resolution for TypeScript */\nconst Type = TypeBuilder;\nexport { JavaScriptTypeBuilder };\nexport { Type };\n"],"names":[],"mappings":"AAAA,qEAAqE;AACrE,kBAAkB;AAClB,qEAAqE;;;;;AAErE,qEAAqE;AACrE,wBAAwB;AACxB,qEAAqE;AACrE;AACA;;;;AACA,kEAAkE,GAClE,MAAM,OAAO","ignoreList":[0]}},
    {"offset": {"line": 6018, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/registry/type.mjs"],"sourcesContent":["/** A registry for user defined types */\nconst map = new Map();\n/** Returns the entries in this registry */\nexport function Entries() {\n    return new Map(map);\n}\n/** Clears all user defined types */\nexport function Clear() {\n    return map.clear();\n}\n/** Deletes a registered type */\nexport function Delete(kind) {\n    return map.delete(kind);\n}\n/** Returns true if this registry contains this kind */\nexport function Has(kind) {\n    return map.has(kind);\n}\n/** Sets a validation function for a user defined type */\nexport function Set(kind, func) {\n    map.set(kind, func);\n}\n/** Gets a custom validation function for a user defined type */\nexport function Get(kind) {\n    return map.get(kind);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,sCAAsC,GACtC,MAAM,MAAM,IAAI;AAET,SAAS;IACZ,OAAO,IAAI,IAAI;AACnB;AAEO,SAAS;IACZ,OAAO,IAAI,KAAK;AACpB;AAEO,SAAS,OAAO,IAAI;IACvB,OAAO,IAAI,MAAM,CAAC;AACtB;AAEO,SAAS,IAAI,IAAI;IACpB,OAAO,IAAI,GAAG,CAAC;AACnB;AAEO,SAAS,IAAI,IAAI,EAAE,IAAI;IAC1B,IAAI,GAAG,CAAC,MAAM;AAClB;AAEO,SAAS,IAAI,IAAI;IACpB,OAAO,IAAI,GAAG,CAAC;AACnB","ignoreList":[0]}},
    {"offset": {"line": 6064, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 6085, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/registry/format.mjs"],"sourcesContent":["/** A registry for user defined string formats */\nconst map = new Map();\n/** Returns the entries in this registry */\nexport function Entries() {\n    return new Map(map);\n}\n/** Clears all user defined string formats */\nexport function Clear() {\n    return map.clear();\n}\n/** Deletes a registered format */\nexport function Delete(format) {\n    return map.delete(format);\n}\n/** Returns true if the user defined string format exists */\nexport function Has(format) {\n    return map.has(format);\n}\n/** Sets a validation function for a user defined string format */\nexport function Set(format, func) {\n    map.set(format, func);\n}\n/** Gets a validation function for a user defined string format */\nexport function Get(format) {\n    return map.get(format);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,+CAA+C,GAC/C,MAAM,MAAM,IAAI;AAET,SAAS;IACZ,OAAO,IAAI,IAAI;AACnB;AAEO,SAAS;IACZ,OAAO,IAAI,KAAK;AACpB;AAEO,SAAS,OAAO,MAAM;IACzB,OAAO,IAAI,MAAM,CAAC;AACtB;AAEO,SAAS,IAAI,MAAM;IACtB,OAAO,IAAI,GAAG,CAAC;AACnB;AAEO,SAAS,IAAI,MAAM,EAAE,IAAI;IAC5B,IAAI,GAAG,CAAC,QAAQ;AACpB;AAEO,SAAS,IAAI,MAAM;IACtB,OAAO,IAAI,GAAG,CAAC;AACnB","ignoreList":[0]}},
    {"offset": {"line": 6131, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/extends/extends-undefined.mjs"],"sourcesContent":["import { Kind } from '../symbols/index.mjs';\n/** Fast undefined check used for properties of type undefined */\nfunction Intersect(schema) {\n    return schema.allOf.every((schema) => ExtendsUndefinedCheck(schema));\n}\nfunction Union(schema) {\n    return schema.anyOf.some((schema) => ExtendsUndefinedCheck(schema));\n}\nfunction Not(schema) {\n    return !ExtendsUndefinedCheck(schema.not);\n}\n/** Fast undefined check used for properties of type undefined */\n// prettier-ignore\nexport function ExtendsUndefinedCheck(schema) {\n    return (schema[Kind] === 'Intersect' ? Intersect(schema) :\n        schema[Kind] === 'Union' ? Union(schema) :\n            schema[Kind] === 'Not' ? Not(schema) :\n                schema[Kind] === 'Undefined' ? true :\n                    false);\n}\n"],"names":[],"mappings":";;;;AAAA;;AACA,+DAA+D,GAC/D,SAAS,UAAU,MAAM;IACrB,OAAO,OAAO,KAAK,CAAC,KAAK,CAAC,CAAC,SAAW,sBAAsB;AAChE;AACA,SAAS,MAAM,MAAM;IACjB,OAAO,OAAO,KAAK,CAAC,IAAI,CAAC,CAAC,SAAW,sBAAsB;AAC/D;AACA,SAAS,IAAI,MAAM;IACf,OAAO,CAAC,sBAAsB,OAAO,GAAG;AAC5C;AAGO,SAAS,sBAAsB,MAAM;IACxC,OAAQ,MAAM,CAAC,8LAAI,CAAC,KAAK,cAAc,UAAU,UAC7C,MAAM,CAAC,8LAAI,CAAC,KAAK,UAAU,MAAM,UAC7B,MAAM,CAAC,8LAAI,CAAC,KAAK,QAAQ,IAAI,UACzB,MAAM,CAAC,8LAAI,CAAC,KAAK,cAAc,OAC3B;AACpB","ignoreList":[0]}},
    {"offset": {"line": 6153, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/errors/function.mjs"],"sourcesContent":["import { Kind } from '../type/symbols/index.mjs';\nimport { ValueErrorType } from './errors.mjs';\n/** Creates an error message using en-US as the default locale */\nexport function DefaultErrorFunction(error) {\n    switch (error.errorType) {\n        case ValueErrorType.ArrayContains:\n            return 'Expected array to contain at least one matching value';\n        case ValueErrorType.ArrayMaxContains:\n            return `Expected array to contain no more than ${error.schema.maxContains} matching values`;\n        case ValueErrorType.ArrayMinContains:\n            return `Expected array to contain at least ${error.schema.minContains} matching values`;\n        case ValueErrorType.ArrayMaxItems:\n            return `Expected array length to be less or equal to ${error.schema.maxItems}`;\n        case ValueErrorType.ArrayMinItems:\n            return `Expected array length to be greater or equal to ${error.schema.minItems}`;\n        case ValueErrorType.ArrayUniqueItems:\n            return 'Expected array elements to be unique';\n        case ValueErrorType.Array:\n            return 'Expected array';\n        case ValueErrorType.AsyncIterator:\n            return 'Expected AsyncIterator';\n        case ValueErrorType.BigIntExclusiveMaximum:\n            return `Expected bigint to be less than ${error.schema.exclusiveMaximum}`;\n        case ValueErrorType.BigIntExclusiveMinimum:\n            return `Expected bigint to be greater than ${error.schema.exclusiveMinimum}`;\n        case ValueErrorType.BigIntMaximum:\n            return `Expected bigint to be less or equal to ${error.schema.maximum}`;\n        case ValueErrorType.BigIntMinimum:\n            return `Expected bigint to be greater or equal to ${error.schema.minimum}`;\n        case ValueErrorType.BigIntMultipleOf:\n            return `Expected bigint to be a multiple of ${error.schema.multipleOf}`;\n        case ValueErrorType.BigInt:\n            return 'Expected bigint';\n        case ValueErrorType.Boolean:\n            return 'Expected boolean';\n        case ValueErrorType.DateExclusiveMinimumTimestamp:\n            return `Expected Date timestamp to be greater than ${error.schema.exclusiveMinimumTimestamp}`;\n        case ValueErrorType.DateExclusiveMaximumTimestamp:\n            return `Expected Date timestamp to be less than ${error.schema.exclusiveMaximumTimestamp}`;\n        case ValueErrorType.DateMinimumTimestamp:\n            return `Expected Date timestamp to be greater or equal to ${error.schema.minimumTimestamp}`;\n        case ValueErrorType.DateMaximumTimestamp:\n            return `Expected Date timestamp to be less or equal to ${error.schema.maximumTimestamp}`;\n        case ValueErrorType.DateMultipleOfTimestamp:\n            return `Expected Date timestamp to be a multiple of ${error.schema.multipleOfTimestamp}`;\n        case ValueErrorType.Date:\n            return 'Expected Date';\n        case ValueErrorType.Function:\n            return 'Expected function';\n        case ValueErrorType.IntegerExclusiveMaximum:\n            return `Expected integer to be less than ${error.schema.exclusiveMaximum}`;\n        case ValueErrorType.IntegerExclusiveMinimum:\n            return `Expected integer to be greater than ${error.schema.exclusiveMinimum}`;\n        case ValueErrorType.IntegerMaximum:\n            return `Expected integer to be less or equal to ${error.schema.maximum}`;\n        case ValueErrorType.IntegerMinimum:\n            return `Expected integer to be greater or equal to ${error.schema.minimum}`;\n        case ValueErrorType.IntegerMultipleOf:\n            return `Expected integer to be a multiple of ${error.schema.multipleOf}`;\n        case ValueErrorType.Integer:\n            return 'Expected integer';\n        case ValueErrorType.IntersectUnevaluatedProperties:\n            return 'Unexpected property';\n        case ValueErrorType.Intersect:\n            return 'Expected all values to match';\n        case ValueErrorType.Iterator:\n            return 'Expected Iterator';\n        case ValueErrorType.Literal:\n            return `Expected ${typeof error.schema.const === 'string' ? `'${error.schema.const}'` : error.schema.const}`;\n        case ValueErrorType.Never:\n            return 'Never';\n        case ValueErrorType.Not:\n            return 'Value should not match';\n        case ValueErrorType.Null:\n            return 'Expected null';\n        case ValueErrorType.NumberExclusiveMaximum:\n            return `Expected number to be less than ${error.schema.exclusiveMaximum}`;\n        case ValueErrorType.NumberExclusiveMinimum:\n            return `Expected number to be greater than ${error.schema.exclusiveMinimum}`;\n        case ValueErrorType.NumberMaximum:\n            return `Expected number to be less or equal to ${error.schema.maximum}`;\n        case ValueErrorType.NumberMinimum:\n            return `Expected number to be greater or equal to ${error.schema.minimum}`;\n        case ValueErrorType.NumberMultipleOf:\n            return `Expected number to be a multiple of ${error.schema.multipleOf}`;\n        case ValueErrorType.Number:\n            return 'Expected number';\n        case ValueErrorType.Object:\n            return 'Expected object';\n        case ValueErrorType.ObjectAdditionalProperties:\n            return 'Unexpected property';\n        case ValueErrorType.ObjectMaxProperties:\n            return `Expected object to have no more than ${error.schema.maxProperties} properties`;\n        case ValueErrorType.ObjectMinProperties:\n            return `Expected object to have at least ${error.schema.minProperties} properties`;\n        case ValueErrorType.ObjectRequiredProperty:\n            return 'Expected required property';\n        case ValueErrorType.Promise:\n            return 'Expected Promise';\n        case ValueErrorType.RegExp:\n            return 'Expected string to match regular expression';\n        case ValueErrorType.StringFormatUnknown:\n            return `Unknown format '${error.schema.format}'`;\n        case ValueErrorType.StringFormat:\n            return `Expected string to match '${error.schema.format}' format`;\n        case ValueErrorType.StringMaxLength:\n            return `Expected string length less or equal to ${error.schema.maxLength}`;\n        case ValueErrorType.StringMinLength:\n            return `Expected string length greater or equal to ${error.schema.minLength}`;\n        case ValueErrorType.StringPattern:\n            return `Expected string to match '${error.schema.pattern}'`;\n        case ValueErrorType.String:\n            return 'Expected string';\n        case ValueErrorType.Symbol:\n            return 'Expected symbol';\n        case ValueErrorType.TupleLength:\n            return `Expected tuple to have ${error.schema.maxItems || 0} elements`;\n        case ValueErrorType.Tuple:\n            return 'Expected tuple';\n        case ValueErrorType.Uint8ArrayMaxByteLength:\n            return `Expected byte length less or equal to ${error.schema.maxByteLength}`;\n        case ValueErrorType.Uint8ArrayMinByteLength:\n            return `Expected byte length greater or equal to ${error.schema.minByteLength}`;\n        case ValueErrorType.Uint8Array:\n            return 'Expected Uint8Array';\n        case ValueErrorType.Undefined:\n            return 'Expected undefined';\n        case ValueErrorType.Union:\n            return 'Expected union value';\n        case ValueErrorType.Void:\n            return 'Expected void';\n        case ValueErrorType.Kind:\n            return `Expected kind '${error.schema[Kind]}'`;\n        default:\n            return 'Unknown error type';\n    }\n}\n/** Manages error message providers */\nlet errorFunction = DefaultErrorFunction;\n/** Sets the error function used to generate error messages. */\nexport function SetErrorFunction(callback) {\n    errorFunction = callback;\n}\n/** Gets the error function used to generate error messages */\nexport function GetErrorFunction() {\n    return errorFunction;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6310, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/deref/deref.mjs"],"sourcesContent":["import { TypeBoxError } from '../../type/error/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\nimport { IsString } from '../guard/guard.mjs';\nexport class TypeDereferenceError extends TypeBoxError {\n    constructor(schema) {\n        super(`Unable to dereference schema with $id '${schema.$ref}'`);\n        this.schema = schema;\n    }\n}\nfunction Resolve(schema, references) {\n    const target = references.find((target) => target.$id === schema.$ref);\n    if (target === undefined)\n        throw new TypeDereferenceError(schema);\n    return Deref(target, references);\n}\n/** `[Internal]` Pushes a schema onto references if the schema has an $id and does not exist on references */\nexport function Pushref(schema, references) {\n    if (!IsString(schema.$id) || references.some((target) => target.$id === schema.$id))\n        return references;\n    references.push(schema);\n    return references;\n}\n/** `[Internal]` Dereferences a schema from the references array or throws if not found */\nexport function Deref(schema, references) {\n    // prettier-ignore\n    return (schema[Kind] === 'This' || schema[Kind] === 'Ref')\n        ? Resolve(schema, references)\n        : schema;\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;AACO,MAAM,6BAA6B,kMAAY;IAClD,YAAY,MAAM,CAAE;QAChB,KAAK,CAAC,CAAC,uCAAuC,EAAE,OAAO,IAAI,CAAC,CAAC,CAAC;QAC9D,IAAI,CAAC,MAAM,GAAG;IAClB;AACJ;AACA,SAAS,QAAQ,MAAM,EAAE,UAAU;IAC/B,MAAM,SAAS,WAAW,IAAI,CAAC,CAAC,SAAW,OAAO,GAAG,KAAK,OAAO,IAAI;IACrE,IAAI,WAAW,WACX,MAAM,IAAI,qBAAqB;IACnC,OAAO,MAAM,QAAQ;AACzB;AAEO,SAAS,QAAQ,MAAM,EAAE,UAAU;IACtC,IAAI,CAAC,IAAA,+LAAQ,EAAC,OAAO,GAAG,KAAK,WAAW,IAAI,CAAC,CAAC,SAAW,OAAO,GAAG,KAAK,OAAO,GAAG,GAC9E,OAAO;IACX,WAAW,IAAI,CAAC;IAChB,OAAO;AACX;AAEO,SAAS,MAAM,MAAM,EAAE,UAAU;IACpC,kBAAkB;IAClB,OAAO,AAAC,MAAM,CAAC,8LAAI,CAAC,KAAK,UAAU,MAAM,CAAC,8LAAI,CAAC,KAAK,QAC9C,QAAQ,QAAQ,cAChB;AACV","ignoreList":[0]}},
    {"offset": {"line": 6348, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/hash/hash.mjs"],"sourcesContent":["import { IsArray, IsBoolean, IsBigInt, IsDate, IsNull, IsNumber, IsObject, IsString, IsSymbol, IsUint8Array, IsUndefined } from '../guard/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValueHashError extends TypeBoxError {\n    constructor(value) {\n        super(`Unable to hash value`);\n        this.value = value;\n    }\n}\n// ------------------------------------------------------------------\n// ByteMarker\n// ------------------------------------------------------------------\nvar ByteMarker;\n(function (ByteMarker) {\n    ByteMarker[ByteMarker[\"Undefined\"] = 0] = \"Undefined\";\n    ByteMarker[ByteMarker[\"Null\"] = 1] = \"Null\";\n    ByteMarker[ByteMarker[\"Boolean\"] = 2] = \"Boolean\";\n    ByteMarker[ByteMarker[\"Number\"] = 3] = \"Number\";\n    ByteMarker[ByteMarker[\"String\"] = 4] = \"String\";\n    ByteMarker[ByteMarker[\"Object\"] = 5] = \"Object\";\n    ByteMarker[ByteMarker[\"Array\"] = 6] = \"Array\";\n    ByteMarker[ByteMarker[\"Date\"] = 7] = \"Date\";\n    ByteMarker[ByteMarker[\"Uint8Array\"] = 8] = \"Uint8Array\";\n    ByteMarker[ByteMarker[\"Symbol\"] = 9] = \"Symbol\";\n    ByteMarker[ByteMarker[\"BigInt\"] = 10] = \"BigInt\";\n})(ByteMarker || (ByteMarker = {}));\n// ------------------------------------------------------------------\n// State\n// ------------------------------------------------------------------\nlet Accumulator = BigInt('14695981039346656037');\nconst [Prime, Size] = [BigInt('1099511628211'), BigInt('18446744073709551616' /* 2 ^ 64 */)];\nconst Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));\nconst F64 = new Float64Array(1);\nconst F64In = new DataView(F64.buffer);\nconst F64Out = new Uint8Array(F64.buffer);\n// ------------------------------------------------------------------\n// NumberToBytes\n// ------------------------------------------------------------------\nfunction* NumberToBytes(value) {\n    const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);\n    for (let i = 0; i < byteCount; i++) {\n        yield (value >> (8 * (byteCount - 1 - i))) & 0xff;\n    }\n}\n// ------------------------------------------------------------------\n// Hashing Functions\n// ------------------------------------------------------------------\nfunction ArrayType(value) {\n    FNV1A64(ByteMarker.Array);\n    for (const item of value) {\n        Visit(item);\n    }\n}\nfunction BooleanType(value) {\n    FNV1A64(ByteMarker.Boolean);\n    FNV1A64(value ? 1 : 0);\n}\nfunction BigIntType(value) {\n    FNV1A64(ByteMarker.BigInt);\n    F64In.setBigInt64(0, value);\n    for (const byte of F64Out) {\n        FNV1A64(byte);\n    }\n}\nfunction DateType(value) {\n    FNV1A64(ByteMarker.Date);\n    Visit(value.getTime());\n}\nfunction NullType(value) {\n    FNV1A64(ByteMarker.Null);\n}\nfunction NumberType(value) {\n    FNV1A64(ByteMarker.Number);\n    F64In.setFloat64(0, value);\n    for (const byte of F64Out) {\n        FNV1A64(byte);\n    }\n}\nfunction ObjectType(value) {\n    FNV1A64(ByteMarker.Object);\n    for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {\n        Visit(key);\n        Visit(value[key]);\n    }\n}\nfunction StringType(value) {\n    FNV1A64(ByteMarker.String);\n    for (let i = 0; i < value.length; i++) {\n        for (const byte of NumberToBytes(value.charCodeAt(i))) {\n            FNV1A64(byte);\n        }\n    }\n}\nfunction SymbolType(value) {\n    FNV1A64(ByteMarker.Symbol);\n    Visit(value.description);\n}\nfunction Uint8ArrayType(value) {\n    FNV1A64(ByteMarker.Uint8Array);\n    for (let i = 0; i < value.length; i++) {\n        FNV1A64(value[i]);\n    }\n}\nfunction UndefinedType(value) {\n    return FNV1A64(ByteMarker.Undefined);\n}\nfunction Visit(value) {\n    if (IsArray(value))\n        return ArrayType(value);\n    if (IsBoolean(value))\n        return BooleanType(value);\n    if (IsBigInt(value))\n        return BigIntType(value);\n    if (IsDate(value))\n        return DateType(value);\n    if (IsNull(value))\n        return NullType(value);\n    if (IsNumber(value))\n        return NumberType(value);\n    if (IsObject(value))\n        return ObjectType(value);\n    if (IsString(value))\n        return StringType(value);\n    if (IsSymbol(value))\n        return SymbolType(value);\n    if (IsUint8Array(value))\n        return Uint8ArrayType(value);\n    if (IsUndefined(value))\n        return UndefinedType(value);\n    throw new ValueHashError(value);\n}\nfunction FNV1A64(byte) {\n    Accumulator = Accumulator ^ Bytes[byte];\n    Accumulator = (Accumulator * Prime) % Size;\n}\n// ------------------------------------------------------------------\n// Hash\n// ------------------------------------------------------------------\n/** Creates a FNV1A-64 non cryptographic hash of the given value */\nexport function Hash(value) {\n    Accumulator = BigInt('14695981039346656037');\n    Visit(value);\n    return Accumulator;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6493, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/check/check.mjs"],"sourcesContent":["import { TypeSystemPolicy } from '../../system/index.mjs';\nimport { Deref, Pushref } from '../deref/index.mjs';\nimport { Hash } from '../hash/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\nimport { KeyOfPattern } from '../../type/keyof/index.mjs';\nimport { ExtendsUndefinedCheck } from '../../type/extends/index.mjs';\nimport { TypeRegistry, FormatRegistry } from '../../type/registry/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\nimport { Never } from '../../type/never/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsUint8Array, IsDate, IsPromise, IsFunction, IsAsyncIterator, IsIterator, IsBoolean, IsNumber, IsBigInt, IsString, IsSymbol, IsInteger, IsNull, IsUndefined } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// KindGuard\n// ------------------------------------------------------------------\nimport { IsSchema } from '../../type/guard/kind.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValueCheckUnknownTypeError extends TypeBoxError {\n    constructor(schema) {\n        super(`Unknown type`);\n        this.schema = schema;\n    }\n}\n// ------------------------------------------------------------------\n// TypeGuards\n// ------------------------------------------------------------------\nfunction IsAnyOrUnknown(schema) {\n    return schema[Kind] === 'Any' || schema[Kind] === 'Unknown';\n}\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nfunction IsDefined(value) {\n    return value !== undefined;\n}\n// ------------------------------------------------------------------\n// Types\n// ------------------------------------------------------------------\nfunction FromAny(schema, references, value) {\n    return true;\n}\nfunction FromArgument(schema, references, value) {\n    return true;\n}\nfunction FromArray(schema, references, value) {\n    if (!IsArray(value))\n        return false;\n    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n        return false;\n    }\n    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n        return false;\n    }\n    if (!value.every((value) => Visit(schema.items, references, value))) {\n        return false;\n    }\n    // prettier-ignore\n    if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {\n        const hashed = Hash(element);\n        if (set.has(hashed)) {\n            return false;\n        }\n        else {\n            set.add(hashed);\n        }\n    } return true; })())) {\n        return false;\n    }\n    // contains\n    if (!(IsDefined(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {\n        return true; // exit\n    }\n    const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();\n    const containsCount = value.reduce((acc, value) => (Visit(containsSchema, references, value) ? acc + 1 : acc), 0);\n    if (containsCount === 0) {\n        return false;\n    }\n    if (IsNumber(schema.minContains) && containsCount < schema.minContains) {\n        return false;\n    }\n    if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {\n        return false;\n    }\n    return true;\n}\nfunction FromAsyncIterator(schema, references, value) {\n    return IsAsyncIterator(value);\n}\nfunction FromBigInt(schema, references, value) {\n    if (!IsBigInt(value))\n        return false;\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        return false;\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        return false;\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n        return false;\n    }\n    return true;\n}\nfunction FromBoolean(schema, references, value) {\n    return IsBoolean(value);\n}\nfunction FromConstructor(schema, references, value) {\n    return Visit(schema.returns, references, value.prototype);\n}\nfunction FromDate(schema, references, value) {\n    if (!IsDate(value))\n        return false;\n    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n        return false;\n    }\n    return true;\n}\nfunction FromFunction(schema, references, value) {\n    return IsFunction(value);\n}\nfunction FromImport(schema, references, value) {\n    const definitions = globalThis.Object.values(schema.$defs);\n    const target = schema.$defs[schema.$ref];\n    return Visit(target, [...references, ...definitions], value);\n}\nfunction FromInteger(schema, references, value) {\n    if (!IsInteger(value)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        return false;\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        return false;\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        return false;\n    }\n    return true;\n}\nfunction FromIntersect(schema, references, value) {\n    const check1 = schema.allOf.every((schema) => Visit(schema, references, value));\n    if (schema.unevaluatedProperties === false) {\n        const keyPattern = new RegExp(KeyOfPattern(schema));\n        const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));\n        return check1 && check2;\n    }\n    else if (IsSchema(schema.unevaluatedProperties)) {\n        const keyCheck = new RegExp(KeyOfPattern(schema));\n        const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit(schema.unevaluatedProperties, references, value[key]));\n        return check1 && check2;\n    }\n    else {\n        return check1;\n    }\n}\nfunction FromIterator(schema, references, value) {\n    return IsIterator(value);\n}\nfunction FromLiteral(schema, references, value) {\n    return value === schema.const;\n}\nfunction FromNever(schema, references, value) {\n    return false;\n}\nfunction FromNot(schema, references, value) {\n    return !Visit(schema.not, references, value);\n}\nfunction FromNull(schema, references, value) {\n    return IsNull(value);\n}\nfunction FromNumber(schema, references, value) {\n    if (!TypeSystemPolicy.IsNumberLike(value))\n        return false;\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        return false;\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        return false;\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        return false;\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        return false;\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        return false;\n    }\n    return true;\n}\nfunction FromObject(schema, references, value) {\n    if (!TypeSystemPolicy.IsObjectLike(value))\n        return false;\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        return false;\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        return false;\n    }\n    const knownKeys = Object.getOwnPropertyNames(schema.properties);\n    for (const knownKey of knownKeys) {\n        const property = schema.properties[knownKey];\n        if (schema.required && schema.required.includes(knownKey)) {\n            if (!Visit(property, references, value[knownKey])) {\n                return false;\n            }\n            if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {\n                return false;\n            }\n        }\n        else {\n            if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) {\n                return false;\n            }\n        }\n    }\n    if (schema.additionalProperties === false) {\n        const valueKeys = Object.getOwnPropertyNames(value);\n        // optimization: value is valid if schemaKey length matches the valueKey length\n        if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {\n            return true;\n        }\n        else {\n            return valueKeys.every((valueKey) => knownKeys.includes(valueKey));\n        }\n    }\n    else if (typeof schema.additionalProperties === 'object') {\n        const valueKeys = Object.getOwnPropertyNames(value);\n        return valueKeys.every((key) => knownKeys.includes(key) || Visit(schema.additionalProperties, references, value[key]));\n    }\n    else {\n        return true;\n    }\n}\nfunction FromPromise(schema, references, value) {\n    return IsPromise(value);\n}\nfunction FromRecord(schema, references, value) {\n    if (!TypeSystemPolicy.IsRecordLike(value)) {\n        return false;\n    }\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        return false;\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        return false;\n    }\n    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n    const regex = new RegExp(patternKey);\n    // prettier-ignore\n    const check1 = Object.entries(value).every(([key, value]) => {\n        return (regex.test(key)) ? Visit(patternSchema, references, value) : true;\n    });\n    // prettier-ignore\n    const check2 = typeof schema.additionalProperties === 'object' ? Object.entries(value).every(([key, value]) => {\n        return (!regex.test(key)) ? Visit(schema.additionalProperties, references, value) : true;\n    }) : true;\n    const check3 = schema.additionalProperties === false\n        ? Object.getOwnPropertyNames(value).every((key) => {\n            return regex.test(key);\n        })\n        : true;\n    return check1 && check2 && check3;\n}\nfunction FromRef(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromRegExp(schema, references, value) {\n    const regex = new RegExp(schema.source, schema.flags);\n    if (IsDefined(schema.minLength)) {\n        if (!(value.length >= schema.minLength))\n            return false;\n    }\n    if (IsDefined(schema.maxLength)) {\n        if (!(value.length <= schema.maxLength))\n            return false;\n    }\n    return regex.test(value);\n}\nfunction FromString(schema, references, value) {\n    if (!IsString(value)) {\n        return false;\n    }\n    if (IsDefined(schema.minLength)) {\n        if (!(value.length >= schema.minLength))\n            return false;\n    }\n    if (IsDefined(schema.maxLength)) {\n        if (!(value.length <= schema.maxLength))\n            return false;\n    }\n    if (IsDefined(schema.pattern)) {\n        const regex = new RegExp(schema.pattern);\n        if (!regex.test(value))\n            return false;\n    }\n    if (IsDefined(schema.format)) {\n        if (!FormatRegistry.Has(schema.format))\n            return false;\n        const func = FormatRegistry.Get(schema.format);\n        return func(value);\n    }\n    return true;\n}\nfunction FromSymbol(schema, references, value) {\n    return IsSymbol(value);\n}\nfunction FromTemplateLiteral(schema, references, value) {\n    return IsString(value) && new RegExp(schema.pattern).test(value);\n}\nfunction FromThis(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromTuple(schema, references, value) {\n    if (!IsArray(value)) {\n        return false;\n    }\n    if (schema.items === undefined && !(value.length === 0)) {\n        return false;\n    }\n    if (!(value.length === schema.maxItems)) {\n        return false;\n    }\n    if (!schema.items) {\n        return true;\n    }\n    for (let i = 0; i < schema.items.length; i++) {\n        if (!Visit(schema.items[i], references, value[i]))\n            return false;\n    }\n    return true;\n}\nfunction FromUndefined(schema, references, value) {\n    return IsUndefined(value);\n}\nfunction FromUnion(schema, references, value) {\n    return schema.anyOf.some((inner) => Visit(inner, references, value));\n}\nfunction FromUint8Array(schema, references, value) {\n    if (!IsUint8Array(value)) {\n        return false;\n    }\n    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n        return false;\n    }\n    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n        return false;\n    }\n    return true;\n}\nfunction FromUnknown(schema, references, value) {\n    return true;\n}\nfunction FromVoid(schema, references, value) {\n    return TypeSystemPolicy.IsVoidLike(value);\n}\nfunction FromKind(schema, references, value) {\n    if (!TypeRegistry.Has(schema[Kind]))\n        return false;\n    const func = TypeRegistry.Get(schema[Kind]);\n    return func(schema, value);\n}\nfunction Visit(schema, references, value) {\n    const references_ = IsDefined(schema.$id) ? Pushref(schema, references) : references;\n    const schema_ = schema;\n    switch (schema_[Kind]) {\n        case 'Any':\n            return FromAny(schema_, references_, value);\n        case 'Argument':\n            return FromArgument(schema_, references_, value);\n        case 'Array':\n            return FromArray(schema_, references_, value);\n        case 'AsyncIterator':\n            return FromAsyncIterator(schema_, references_, value);\n        case 'BigInt':\n            return FromBigInt(schema_, references_, value);\n        case 'Boolean':\n            return FromBoolean(schema_, references_, value);\n        case 'Constructor':\n            return FromConstructor(schema_, references_, value);\n        case 'Date':\n            return FromDate(schema_, references_, value);\n        case 'Function':\n            return FromFunction(schema_, references_, value);\n        case 'Import':\n            return FromImport(schema_, references_, value);\n        case 'Integer':\n            return FromInteger(schema_, references_, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, value);\n        case 'Iterator':\n            return FromIterator(schema_, references_, value);\n        case 'Literal':\n            return FromLiteral(schema_, references_, value);\n        case 'Never':\n            return FromNever(schema_, references_, value);\n        case 'Not':\n            return FromNot(schema_, references_, value);\n        case 'Null':\n            return FromNull(schema_, references_, value);\n        case 'Number':\n            return FromNumber(schema_, references_, value);\n        case 'Object':\n            return FromObject(schema_, references_, value);\n        case 'Promise':\n            return FromPromise(schema_, references_, value);\n        case 'Record':\n            return FromRecord(schema_, references_, value);\n        case 'Ref':\n            return FromRef(schema_, references_, value);\n        case 'RegExp':\n            return FromRegExp(schema_, references_, value);\n        case 'String':\n            return FromString(schema_, references_, value);\n        case 'Symbol':\n            return FromSymbol(schema_, references_, value);\n        case 'TemplateLiteral':\n            return FromTemplateLiteral(schema_, references_, value);\n        case 'This':\n            return FromThis(schema_, references_, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, value);\n        case 'Undefined':\n            return FromUndefined(schema_, references_, value);\n        case 'Union':\n            return FromUnion(schema_, references_, value);\n        case 'Uint8Array':\n            return FromUint8Array(schema_, references_, value);\n        case 'Unknown':\n            return FromUnknown(schema_, references_, value);\n        case 'Void':\n            return FromVoid(schema_, references_, value);\n        default:\n            if (!TypeRegistry.Has(schema_[Kind]))\n                throw new ValueCheckUnknownTypeError(schema_);\n            return FromKind(schema_, references_, value);\n    }\n}\n/** Returns true if the value matches the given type. */\nexport function Check(...args) {\n    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6964, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/errors/errors.mjs"],"sourcesContent":["import { TypeSystemPolicy } from '../system/index.mjs';\nimport { KeyOfPattern } from '../type/keyof/index.mjs';\nimport { TypeRegistry, FormatRegistry } from '../type/registry/index.mjs';\nimport { ExtendsUndefinedCheck } from '../type/extends/extends-undefined.mjs';\nimport { GetErrorFunction } from './function.mjs';\nimport { TypeBoxError } from '../type/error/index.mjs';\nimport { Deref } from '../value/deref/index.mjs';\nimport { Hash } from '../value/hash/index.mjs';\nimport { Check } from '../value/check/index.mjs';\nimport { Kind } from '../type/symbols/index.mjs';\nimport { Never } from '../type/never/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { IsArray, IsUint8Array, IsDate, IsPromise, IsFunction, IsAsyncIterator, IsIterator, IsBoolean, IsNumber, IsBigInt, IsString, IsSymbol, IsInteger, IsNull, IsUndefined } from '../value/guard/index.mjs';\n// ------------------------------------------------------------------\n// ValueErrorType\n// ------------------------------------------------------------------\nexport var ValueErrorType;\n(function (ValueErrorType) {\n    ValueErrorType[ValueErrorType[\"ArrayContains\"] = 0] = \"ArrayContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxContains\"] = 1] = \"ArrayMaxContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxItems\"] = 2] = \"ArrayMaxItems\";\n    ValueErrorType[ValueErrorType[\"ArrayMinContains\"] = 3] = \"ArrayMinContains\";\n    ValueErrorType[ValueErrorType[\"ArrayMinItems\"] = 4] = \"ArrayMinItems\";\n    ValueErrorType[ValueErrorType[\"ArrayUniqueItems\"] = 5] = \"ArrayUniqueItems\";\n    ValueErrorType[ValueErrorType[\"Array\"] = 6] = \"Array\";\n    ValueErrorType[ValueErrorType[\"AsyncIterator\"] = 7] = \"AsyncIterator\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMaximum\"] = 8] = \"BigIntExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMinimum\"] = 9] = \"BigIntExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMaximum\"] = 10] = \"BigIntMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntMinimum\"] = 11] = \"BigIntMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMultipleOf\"] = 12] = \"BigIntMultipleOf\";\n    ValueErrorType[ValueErrorType[\"BigInt\"] = 13] = \"BigInt\";\n    ValueErrorType[ValueErrorType[\"Boolean\"] = 14] = \"Boolean\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMaximumTimestamp\"] = 15] = \"DateExclusiveMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMinimumTimestamp\"] = 16] = \"DateExclusiveMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMaximumTimestamp\"] = 17] = \"DateMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMinimumTimestamp\"] = 18] = \"DateMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMultipleOfTimestamp\"] = 19] = \"DateMultipleOfTimestamp\";\n    ValueErrorType[ValueErrorType[\"Date\"] = 20] = \"Date\";\n    ValueErrorType[ValueErrorType[\"Function\"] = 21] = \"Function\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMaximum\"] = 22] = \"IntegerExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMinimum\"] = 23] = \"IntegerExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMaximum\"] = 24] = \"IntegerMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerMinimum\"] = 25] = \"IntegerMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMultipleOf\"] = 26] = \"IntegerMultipleOf\";\n    ValueErrorType[ValueErrorType[\"Integer\"] = 27] = \"Integer\";\n    ValueErrorType[ValueErrorType[\"IntersectUnevaluatedProperties\"] = 28] = \"IntersectUnevaluatedProperties\";\n    ValueErrorType[ValueErrorType[\"Intersect\"] = 29] = \"Intersect\";\n    ValueErrorType[ValueErrorType[\"Iterator\"] = 30] = \"Iterator\";\n    ValueErrorType[ValueErrorType[\"Kind\"] = 31] = \"Kind\";\n    ValueErrorType[ValueErrorType[\"Literal\"] = 32] = \"Literal\";\n    ValueErrorType[ValueErrorType[\"Never\"] = 33] = \"Never\";\n    ValueErrorType[ValueErrorType[\"Not\"] = 34] = \"Not\";\n    ValueErrorType[ValueErrorType[\"Null\"] = 35] = \"Null\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMaximum\"] = 36] = \"NumberExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMinimum\"] = 37] = \"NumberExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMaximum\"] = 38] = \"NumberMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberMinimum\"] = 39] = \"NumberMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMultipleOf\"] = 40] = \"NumberMultipleOf\";\n    ValueErrorType[ValueErrorType[\"Number\"] = 41] = \"Number\";\n    ValueErrorType[ValueErrorType[\"ObjectAdditionalProperties\"] = 42] = \"ObjectAdditionalProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMaxProperties\"] = 43] = \"ObjectMaxProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMinProperties\"] = 44] = \"ObjectMinProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectRequiredProperty\"] = 45] = \"ObjectRequiredProperty\";\n    ValueErrorType[ValueErrorType[\"Object\"] = 46] = \"Object\";\n    ValueErrorType[ValueErrorType[\"Promise\"] = 47] = \"Promise\";\n    ValueErrorType[ValueErrorType[\"RegExp\"] = 48] = \"RegExp\";\n    ValueErrorType[ValueErrorType[\"StringFormatUnknown\"] = 49] = \"StringFormatUnknown\";\n    ValueErrorType[ValueErrorType[\"StringFormat\"] = 50] = \"StringFormat\";\n    ValueErrorType[ValueErrorType[\"StringMaxLength\"] = 51] = \"StringMaxLength\";\n    ValueErrorType[ValueErrorType[\"StringMinLength\"] = 52] = \"StringMinLength\";\n    ValueErrorType[ValueErrorType[\"StringPattern\"] = 53] = \"StringPattern\";\n    ValueErrorType[ValueErrorType[\"String\"] = 54] = \"String\";\n    ValueErrorType[ValueErrorType[\"Symbol\"] = 55] = \"Symbol\";\n    ValueErrorType[ValueErrorType[\"TupleLength\"] = 56] = \"TupleLength\";\n    ValueErrorType[ValueErrorType[\"Tuple\"] = 57] = \"Tuple\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMaxByteLength\"] = 58] = \"Uint8ArrayMaxByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMinByteLength\"] = 59] = \"Uint8ArrayMinByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8Array\"] = 60] = \"Uint8Array\";\n    ValueErrorType[ValueErrorType[\"Undefined\"] = 61] = \"Undefined\";\n    ValueErrorType[ValueErrorType[\"Union\"] = 62] = \"Union\";\n    ValueErrorType[ValueErrorType[\"Void\"] = 63] = \"Void\";\n})(ValueErrorType || (ValueErrorType = {}));\n// ------------------------------------------------------------------\n// ValueErrors\n// ------------------------------------------------------------------\nexport class ValueErrorsUnknownTypeError extends TypeBoxError {\n    constructor(schema) {\n        super('Unknown type');\n        this.schema = schema;\n    }\n}\n// ------------------------------------------------------------------\n// EscapeKey\n// ------------------------------------------------------------------\nfunction EscapeKey(key) {\n    return key.replace(/~/g, '~0').replace(/\\//g, '~1'); // RFC6901 Path\n}\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nfunction IsDefined(value) {\n    return value !== undefined;\n}\n// ------------------------------------------------------------------\n// ValueErrorIterator\n// ------------------------------------------------------------------\nexport class ValueErrorIterator {\n    constructor(iterator) {\n        this.iterator = iterator;\n    }\n    [Symbol.iterator]() {\n        return this.iterator;\n    }\n    /** Returns the first value error or undefined if no errors */\n    First() {\n        const next = this.iterator.next();\n        return next.done ? undefined : next.value;\n    }\n}\n// --------------------------------------------------------------------------\n// Create\n// --------------------------------------------------------------------------\nfunction Create(errorType, schema, path, value, errors = []) {\n    return {\n        type: errorType,\n        schema,\n        path,\n        value,\n        message: GetErrorFunction()({ errorType, path, schema, value, errors }),\n        errors,\n    };\n}\n// --------------------------------------------------------------------------\n// Types\n// --------------------------------------------------------------------------\nfunction* FromAny(schema, references, path, value) { }\nfunction* FromArgument(schema, references, path, value) { }\nfunction* FromArray(schema, references, path, value) {\n    if (!IsArray(value)) {\n        return yield Create(ValueErrorType.Array, schema, path, value);\n    }\n    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n        yield Create(ValueErrorType.ArrayMinItems, schema, path, value);\n    }\n    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n        yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);\n    }\n    for (let i = 0; i < value.length; i++) {\n        yield* Visit(schema.items, references, `${path}/${i}`, value[i]);\n    }\n    // prettier-ignore\n    if (schema.uniqueItems === true && !((function () { const set = new Set(); for (const element of value) {\n        const hashed = Hash(element);\n        if (set.has(hashed)) {\n            return false;\n        }\n        else {\n            set.add(hashed);\n        }\n    } return true; })())) {\n        yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);\n    }\n    // contains\n    if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {\n        return;\n    }\n    const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();\n    const containsCount = value.reduce((acc, value, index) => (Visit(containsSchema, references, `${path}${index}`, value).next().done === true ? acc + 1 : acc), 0);\n    if (containsCount === 0) {\n        yield Create(ValueErrorType.ArrayContains, schema, path, value);\n    }\n    if (IsNumber(schema.minContains) && containsCount < schema.minContains) {\n        yield Create(ValueErrorType.ArrayMinContains, schema, path, value);\n    }\n    if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {\n        yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);\n    }\n}\nfunction* FromAsyncIterator(schema, references, path, value) {\n    if (!IsAsyncIterator(value))\n        yield Create(ValueErrorType.AsyncIterator, schema, path, value);\n}\nfunction* FromBigInt(schema, references, path, value) {\n    if (!IsBigInt(value))\n        return yield Create(ValueErrorType.BigInt, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.BigIntMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.BigIntMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {\n        yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);\n    }\n}\nfunction* FromBoolean(schema, references, path, value) {\n    if (!IsBoolean(value))\n        yield Create(ValueErrorType.Boolean, schema, path, value);\n}\nfunction* FromConstructor(schema, references, path, value) {\n    yield* Visit(schema.returns, references, path, value.prototype);\n}\nfunction* FromDate(schema, references, path, value) {\n    if (!IsDate(value))\n        return yield Create(ValueErrorType.Date, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n        yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n        yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n        yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n        yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {\n        yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);\n    }\n}\nfunction* FromFunction(schema, references, path, value) {\n    if (!IsFunction(value))\n        yield Create(ValueErrorType.Function, schema, path, value);\n}\nfunction* FromImport(schema, references, path, value) {\n    const definitions = globalThis.Object.values(schema.$defs);\n    const target = schema.$defs[schema.$ref];\n    yield* Visit(target, [...references, ...definitions], path, value);\n}\nfunction* FromInteger(schema, references, path, value) {\n    if (!IsInteger(value))\n        return yield Create(ValueErrorType.Integer, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.IntegerMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.IntegerMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);\n    }\n}\nfunction* FromIntersect(schema, references, path, value) {\n    let hasError = false;\n    for (const inner of schema.allOf) {\n        for (const error of Visit(inner, references, path, value)) {\n            hasError = true;\n            yield error;\n        }\n    }\n    if (hasError) {\n        return yield Create(ValueErrorType.Intersect, schema, path, value);\n    }\n    if (schema.unevaluatedProperties === false) {\n        const keyCheck = new RegExp(KeyOfPattern(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);\n            }\n        }\n    }\n    if (typeof schema.unevaluatedProperties === 'object') {\n        const keyCheck = new RegExp(KeyOfPattern(schema));\n        for (const valueKey of Object.getOwnPropertyNames(value)) {\n            if (!keyCheck.test(valueKey)) {\n                const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();\n                if (!next.done)\n                    yield next.value; // yield interior\n            }\n        }\n    }\n}\nfunction* FromIterator(schema, references, path, value) {\n    if (!IsIterator(value))\n        yield Create(ValueErrorType.Iterator, schema, path, value);\n}\nfunction* FromLiteral(schema, references, path, value) {\n    if (!(value === schema.const))\n        yield Create(ValueErrorType.Literal, schema, path, value);\n}\nfunction* FromNever(schema, references, path, value) {\n    yield Create(ValueErrorType.Never, schema, path, value);\n}\nfunction* FromNot(schema, references, path, value) {\n    if (Visit(schema.not, references, path, value).next().done === true)\n        yield Create(ValueErrorType.Not, schema, path, value);\n}\nfunction* FromNull(schema, references, path, value) {\n    if (!IsNull(value))\n        yield Create(ValueErrorType.Null, schema, path, value);\n}\nfunction* FromNumber(schema, references, path, value) {\n    if (!TypeSystemPolicy.IsNumberLike(value))\n        return yield Create(ValueErrorType.Number, schema, path, value);\n    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n        yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n        yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n        yield Create(ValueErrorType.NumberMaximum, schema, path, value);\n    }\n    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n        yield Create(ValueErrorType.NumberMinimum, schema, path, value);\n    }\n    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n        yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);\n    }\n}\nfunction* FromObject(schema, references, path, value) {\n    if (!TypeSystemPolicy.IsObjectLike(value))\n        return yield Create(ValueErrorType.Object, schema, path, value);\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n    }\n    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];\n    const knownKeys = Object.getOwnPropertyNames(schema.properties);\n    const unknownKeys = Object.getOwnPropertyNames(value);\n    for (const requiredKey of requiredKeys) {\n        if (unknownKeys.includes(requiredKey))\n            continue;\n        yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);\n    }\n    if (schema.additionalProperties === false) {\n        for (const valueKey of unknownKeys) {\n            if (!knownKeys.includes(valueKey)) {\n                yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n            }\n        }\n    }\n    if (typeof schema.additionalProperties === 'object') {\n        for (const valueKey of unknownKeys) {\n            if (knownKeys.includes(valueKey))\n                continue;\n            yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);\n        }\n    }\n    for (const knownKey of knownKeys) {\n        const property = schema.properties[knownKey];\n        if (schema.required && schema.required.includes(knownKey)) {\n            yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n            if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {\n                yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);\n            }\n        }\n        else {\n            if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {\n                yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);\n            }\n        }\n    }\n}\nfunction* FromPromise(schema, references, path, value) {\n    if (!IsPromise(value))\n        yield Create(ValueErrorType.Promise, schema, path, value);\n}\nfunction* FromRecord(schema, references, path, value) {\n    if (!TypeSystemPolicy.IsRecordLike(value))\n        return yield Create(ValueErrorType.Object, schema, path, value);\n    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n        yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);\n    }\n    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n        yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);\n    }\n    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n    const regex = new RegExp(patternKey);\n    for (const [propertyKey, propertyValue] of Object.entries(value)) {\n        if (regex.test(propertyKey))\n            yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n    }\n    if (typeof schema.additionalProperties === 'object') {\n        for (const [propertyKey, propertyValue] of Object.entries(value)) {\n            if (!regex.test(propertyKey))\n                yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n        }\n    }\n    if (schema.additionalProperties === false) {\n        for (const [propertyKey, propertyValue] of Object.entries(value)) {\n            if (regex.test(propertyKey))\n                continue;\n            return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);\n        }\n    }\n}\nfunction* FromRef(schema, references, path, value) {\n    yield* Visit(Deref(schema, references), references, path, value);\n}\nfunction* FromRegExp(schema, references, path, value) {\n    if (!IsString(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n        yield Create(ValueErrorType.StringMinLength, schema, path, value);\n    }\n    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n        yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n    }\n    const regex = new RegExp(schema.source, schema.flags);\n    if (!regex.test(value)) {\n        return yield Create(ValueErrorType.RegExp, schema, path, value);\n    }\n}\nfunction* FromString(schema, references, path, value) {\n    if (!IsString(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n        yield Create(ValueErrorType.StringMinLength, schema, path, value);\n    }\n    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n        yield Create(ValueErrorType.StringMaxLength, schema, path, value);\n    }\n    if (IsString(schema.pattern)) {\n        const regex = new RegExp(schema.pattern);\n        if (!regex.test(value)) {\n            yield Create(ValueErrorType.StringPattern, schema, path, value);\n        }\n    }\n    if (IsString(schema.format)) {\n        if (!FormatRegistry.Has(schema.format)) {\n            yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);\n        }\n        else {\n            const format = FormatRegistry.Get(schema.format);\n            if (!format(value)) {\n                yield Create(ValueErrorType.StringFormat, schema, path, value);\n            }\n        }\n    }\n}\nfunction* FromSymbol(schema, references, path, value) {\n    if (!IsSymbol(value))\n        yield Create(ValueErrorType.Symbol, schema, path, value);\n}\nfunction* FromTemplateLiteral(schema, references, path, value) {\n    if (!IsString(value))\n        return yield Create(ValueErrorType.String, schema, path, value);\n    const regex = new RegExp(schema.pattern);\n    if (!regex.test(value)) {\n        yield Create(ValueErrorType.StringPattern, schema, path, value);\n    }\n}\nfunction* FromThis(schema, references, path, value) {\n    yield* Visit(Deref(schema, references), references, path, value);\n}\nfunction* FromTuple(schema, references, path, value) {\n    if (!IsArray(value))\n        return yield Create(ValueErrorType.Tuple, schema, path, value);\n    if (schema.items === undefined && !(value.length === 0)) {\n        return yield Create(ValueErrorType.TupleLength, schema, path, value);\n    }\n    if (!(value.length === schema.maxItems)) {\n        return yield Create(ValueErrorType.TupleLength, schema, path, value);\n    }\n    if (!schema.items) {\n        return;\n    }\n    for (let i = 0; i < schema.items.length; i++) {\n        yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);\n    }\n}\nfunction* FromUndefined(schema, references, path, value) {\n    if (!IsUndefined(value))\n        yield Create(ValueErrorType.Undefined, schema, path, value);\n}\nfunction* FromUnion(schema, references, path, value) {\n    if (Check(schema, references, value))\n        return;\n    const errors = schema.anyOf.map((variant) => new ValueErrorIterator(Visit(variant, references, path, value)));\n    yield Create(ValueErrorType.Union, schema, path, value, errors);\n}\nfunction* FromUint8Array(schema, references, path, value) {\n    if (!IsUint8Array(value))\n        return yield Create(ValueErrorType.Uint8Array, schema, path, value);\n    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n        yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);\n    }\n    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n        yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);\n    }\n}\nfunction* FromUnknown(schema, references, path, value) { }\nfunction* FromVoid(schema, references, path, value) {\n    if (!TypeSystemPolicy.IsVoidLike(value))\n        yield Create(ValueErrorType.Void, schema, path, value);\n}\nfunction* FromKind(schema, references, path, value) {\n    const check = TypeRegistry.Get(schema[Kind]);\n    if (!check(schema, value))\n        yield Create(ValueErrorType.Kind, schema, path, value);\n}\nfunction* Visit(schema, references, path, value) {\n    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;\n    const schema_ = schema;\n    switch (schema_[Kind]) {\n        case 'Any':\n            return yield* FromAny(schema_, references_, path, value);\n        case 'Argument':\n            return yield* FromArgument(schema_, references_, path, value);\n        case 'Array':\n            return yield* FromArray(schema_, references_, path, value);\n        case 'AsyncIterator':\n            return yield* FromAsyncIterator(schema_, references_, path, value);\n        case 'BigInt':\n            return yield* FromBigInt(schema_, references_, path, value);\n        case 'Boolean':\n            return yield* FromBoolean(schema_, references_, path, value);\n        case 'Constructor':\n            return yield* FromConstructor(schema_, references_, path, value);\n        case 'Date':\n            return yield* FromDate(schema_, references_, path, value);\n        case 'Function':\n            return yield* FromFunction(schema_, references_, path, value);\n        case 'Import':\n            return yield* FromImport(schema_, references_, path, value);\n        case 'Integer':\n            return yield* FromInteger(schema_, references_, path, value);\n        case 'Intersect':\n            return yield* FromIntersect(schema_, references_, path, value);\n        case 'Iterator':\n            return yield* FromIterator(schema_, references_, path, value);\n        case 'Literal':\n            return yield* FromLiteral(schema_, references_, path, value);\n        case 'Never':\n            return yield* FromNever(schema_, references_, path, value);\n        case 'Not':\n            return yield* FromNot(schema_, references_, path, value);\n        case 'Null':\n            return yield* FromNull(schema_, references_, path, value);\n        case 'Number':\n            return yield* FromNumber(schema_, references_, path, value);\n        case 'Object':\n            return yield* FromObject(schema_, references_, path, value);\n        case 'Promise':\n            return yield* FromPromise(schema_, references_, path, value);\n        case 'Record':\n            return yield* FromRecord(schema_, references_, path, value);\n        case 'Ref':\n            return yield* FromRef(schema_, references_, path, value);\n        case 'RegExp':\n            return yield* FromRegExp(schema_, references_, path, value);\n        case 'String':\n            return yield* FromString(schema_, references_, path, value);\n        case 'Symbol':\n            return yield* FromSymbol(schema_, references_, path, value);\n        case 'TemplateLiteral':\n            return yield* FromTemplateLiteral(schema_, references_, path, value);\n        case 'This':\n            return yield* FromThis(schema_, references_, path, value);\n        case 'Tuple':\n            return yield* FromTuple(schema_, references_, path, value);\n        case 'Undefined':\n            return yield* FromUndefined(schema_, references_, path, value);\n        case 'Union':\n            return yield* FromUnion(schema_, references_, path, value);\n        case 'Uint8Array':\n            return yield* FromUint8Array(schema_, references_, path, value);\n        case 'Unknown':\n            return yield* FromUnknown(schema_, references_, path, value);\n        case 'Void':\n            return yield* FromVoid(schema_, references_, path, value);\n        default:\n            if (!TypeRegistry.Has(schema_[Kind]))\n                throw new ValueErrorsUnknownTypeError(schema);\n            return yield* FromKind(schema_, references_, path, value);\n    }\n}\n/** Returns an iterator for each error in this value. */\nexport function Errors(...args) {\n    const iterator = args.length === 3 ? Visit(args[0], args[1], '', args[2]) : Visit(args[0], [], '', args[1]);\n    return new ValueErrorIterator(iterator);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7554, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/assert/assert.mjs"],"sourcesContent":["var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AssertError_instances, _AssertError_iterator, _AssertError_Iterator;\nimport { Errors, ValueErrorIterator } from '../../errors/index.mjs';\nimport { TypeBoxError } from '../../type/error/error.mjs';\nimport { Check } from '../check/check.mjs';\n// ------------------------------------------------------------------\n// AssertError\n// ------------------------------------------------------------------\nexport class AssertError extends TypeBoxError {\n    constructor(iterator) {\n        const error = iterator.First();\n        super(error === undefined ? 'Invalid Value' : error.message);\n        _AssertError_instances.add(this);\n        _AssertError_iterator.set(this, void 0);\n        __classPrivateFieldSet(this, _AssertError_iterator, iterator, \"f\");\n        this.error = error;\n    }\n    /** Returns an iterator for each error in this value. */\n    Errors() {\n        return new ValueErrorIterator(__classPrivateFieldGet(this, _AssertError_instances, \"m\", _AssertError_Iterator).call(this));\n    }\n}\n_AssertError_iterator = new WeakMap(), _AssertError_instances = new WeakSet(), _AssertError_Iterator = function* _AssertError_Iterator() {\n    if (this.error)\n        yield this.error;\n    yield* __classPrivateFieldGet(this, _AssertError_iterator, \"f\");\n};\n// ------------------------------------------------------------------\n// AssertValue\n// ------------------------------------------------------------------\nfunction AssertValue(schema, references, value) {\n    if (Check(schema, references, value))\n        return;\n    throw new AssertError(Errors(schema, references, value));\n}\n/** Asserts a value matches the given type or throws an `AssertError` if invalid */\nexport function Assert(...args) {\n    return args.length === 3 ? AssertValue(args[0], args[1], args[2]) : AssertValue(args[0], [], args[1]);\n}\n"],"names":[],"mappings":";;;;;;AAYA;AACA;AACA;AAdA,IAAI,yBAAyB,4CAAS,yCAAK,sBAAsB,IAAK,SAAU,QAAQ,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC;IAC3G,IAAI,SAAS,KAAK,MAAM,IAAI,UAAU;IACtC,IAAI,SAAS,OAAO,CAAC,GAAG,MAAM,IAAI,UAAU;IAC5C,IAAI,OAAO,UAAU,aAAa,aAAa,SAAS,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,WAAW,MAAM,IAAI,UAAU;IACvG,OAAO,AAAC,SAAS,MAAM,EAAE,IAAI,CAAC,UAAU,SAAS,IAAI,EAAE,KAAK,GAAG,QAAQ,MAAM,GAAG,CAAC,UAAU,QAAS;AACxG;AACA,IAAI,yBAAyB,4CAAS,yCAAK,sBAAsB,IAAK,SAAU,QAAQ,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC;IACpG,IAAI,SAAS,OAAO,CAAC,GAAG,MAAM,IAAI,UAAU;IAC5C,IAAI,OAAO,UAAU,aAAa,aAAa,SAAS,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,WAAW,MAAM,IAAI,UAAU;IACvG,OAAO,SAAS,MAAM,IAAI,SAAS,MAAM,EAAE,IAAI,CAAC,YAAY,IAAI,EAAE,KAAK,GAAG,MAAM,GAAG,CAAC;AACxF;AACA,IAAI,wBAAwB,uBAAuB;;;;AAO5C,MAAM,oBAAoB,kMAAY;IACzC,YAAY,QAAQ,CAAE;QAClB,MAAM,QAAQ,SAAS,KAAK;QAC5B,KAAK,CAAC,UAAU,YAAY,kBAAkB,MAAM,OAAO;QAC3D,uBAAuB,GAAG,CAAC,IAAI;QAC/B,sBAAsB,GAAG,CAAC,IAAI,EAAE,KAAK;QACrC,uBAAuB,IAAI,EAAE,uBAAuB,UAAU;QAC9D,IAAI,CAAC,KAAK,GAAG;IACjB;IACA,sDAAsD,GACtD,SAAS;QACL,OAAO,IAAI,kMAAkB,CAAC,uBAAuB,IAAI,EAAE,wBAAwB,KAAK,uBAAuB,IAAI,CAAC,IAAI;IAC5H;AACJ;AACA,wBAAwB,IAAI,WAAW,yBAAyB,IAAI,WAAW,wBAAwB,UAAU;IAC7G,IAAI,IAAI,CAAC,KAAK,EACV,MAAM,IAAI,CAAC,KAAK;IACpB,OAAO,uBAAuB,IAAI,EAAE,uBAAuB;AAC/D;AACA,qEAAqE;AACrE,cAAc;AACd,qEAAqE;AACrE,SAAS,YAAY,MAAM,EAAE,UAAU,EAAE,KAAK;IAC1C,IAAI,IAAA,4LAAK,EAAC,QAAQ,YAAY,QAC1B;IACJ,MAAM,IAAI,YAAY,IAAA,sLAAM,EAAC,QAAQ,YAAY;AACrD;AAEO,SAAS,OAAO,GAAG,IAAI;IAC1B,OAAO,KAAK,MAAM,KAAK,IAAI,YAAY,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,IAAI,YAAY,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,IAAI,CAAC,EAAE;AACxG","ignoreList":[0]}},
    {"offset": {"line": 7609, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/clone/clone.mjs"],"sourcesContent":["// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsDate, IsMap, IsSet, IsObject, IsTypedArray, IsValueType } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// Clonable\n// ------------------------------------------------------------------\nfunction FromObject(value) {\n    const Acc = {};\n    for (const key of Object.getOwnPropertyNames(value)) {\n        Acc[key] = Clone(value[key]);\n    }\n    for (const key of Object.getOwnPropertySymbols(value)) {\n        Acc[key] = Clone(value[key]);\n    }\n    return Acc;\n}\nfunction FromArray(value) {\n    return value.map((element) => Clone(element));\n}\nfunction FromTypedArray(value) {\n    return value.slice();\n}\nfunction FromMap(value) {\n    return new Map(Clone([...value.entries()]));\n}\nfunction FromSet(value) {\n    return new Set(Clone([...value.entries()]));\n}\nfunction FromDate(value) {\n    return new Date(value.toISOString());\n}\nfunction FromValue(value) {\n    return value;\n}\n// ------------------------------------------------------------------\n// Clone\n// ------------------------------------------------------------------\n/** Returns a clone of the given value */\nexport function Clone(value) {\n    if (IsArray(value))\n        return FromArray(value);\n    if (IsDate(value))\n        return FromDate(value);\n    if (IsTypedArray(value))\n        return FromTypedArray(value);\n    if (IsMap(value))\n        return FromMap(value);\n    if (IsSet(value))\n        return FromSet(value);\n    if (IsObject(value))\n        return FromObject(value);\n    if (IsValueType(value))\n        return FromValue(value);\n    throw new Error('ValueClone: Unable to clone value');\n}\n"],"names":[],"mappings":";;;;AAAA,qEAAqE;AACrE,aAAa;AACb,qEAAqE;AACrE;;AACA,qEAAqE;AACrE,WAAW;AACX,qEAAqE;AACrE,SAAS,WAAW,KAAK;IACrB,MAAM,MAAM,CAAC;IACb,KAAK,MAAM,OAAO,OAAO,mBAAmB,CAAC,OAAQ;QACjD,GAAG,CAAC,IAAI,GAAG,MAAM,KAAK,CAAC,IAAI;IAC/B;IACA,KAAK,MAAM,OAAO,OAAO,qBAAqB,CAAC,OAAQ;QACnD,GAAG,CAAC,IAAI,GAAG,MAAM,KAAK,CAAC,IAAI;IAC/B;IACA,OAAO;AACX;AACA,SAAS,UAAU,KAAK;IACpB,OAAO,MAAM,GAAG,CAAC,CAAC,UAAY,MAAM;AACxC;AACA,SAAS,eAAe,KAAK;IACzB,OAAO,MAAM,KAAK;AACtB;AACA,SAAS,QAAQ,KAAK;IAClB,OAAO,IAAI,IAAI,MAAM;WAAI,MAAM,OAAO;KAAG;AAC7C;AACA,SAAS,QAAQ,KAAK;IAClB,OAAO,IAAI,IAAI,MAAM;WAAI,MAAM,OAAO;KAAG;AAC7C;AACA,SAAS,SAAS,KAAK;IACnB,OAAO,IAAI,KAAK,MAAM,WAAW;AACrC;AACA,SAAS,UAAU,KAAK;IACpB,OAAO;AACX;AAKO,SAAS,MAAM,KAAK;IACvB,IAAI,IAAA,8LAAO,EAAC,QACR,OAAO,UAAU;IACrB,IAAI,IAAA,6LAAM,EAAC,QACP,OAAO,SAAS;IACpB,IAAI,IAAA,mMAAY,EAAC,QACb,OAAO,eAAe;IAC1B,IAAI,IAAA,4LAAK,EAAC,QACN,OAAO,QAAQ;IACnB,IAAI,IAAA,4LAAK,EAAC,QACN,OAAO,QAAQ;IACnB,IAAI,IAAA,+LAAQ,EAAC,QACT,OAAO,WAAW;IACtB,IAAI,IAAA,kMAAW,EAAC,QACZ,OAAO,UAAU;IACrB,MAAM,IAAI,MAAM;AACpB","ignoreList":[0]}},
    {"offset": {"line": 7667, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/create/create.mjs"],"sourcesContent":["import { HasPropertyKey } from '../guard/index.mjs';\nimport { Check } from '../check/index.mjs';\nimport { Clone } from '../clone/index.mjs';\nimport { Deref, Pushref } from '../deref/index.mjs';\nimport { TemplateLiteralGenerate, IsTemplateLiteralFinite } from '../../type/template-literal/index.mjs';\nimport { TypeRegistry } from '../../type/registry/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\nimport { IsFunction } from '../guard/guard.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValueCreateError extends TypeBoxError {\n    constructor(schema, message) {\n        super(message);\n        this.schema = schema;\n    }\n}\n// ------------------------------------------------------------------\n// Default\n// ------------------------------------------------------------------\nfunction FromDefault(value) {\n    return IsFunction(value) ? value() : Clone(value);\n}\n// ------------------------------------------------------------------\n// Create\n// ------------------------------------------------------------------\nfunction FromAny(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return {};\n    }\n}\nfunction FromArgument(schema, references) {\n    return {};\n}\nfunction FromArray(schema, references) {\n    if (schema.uniqueItems === true && !HasPropertyKey(schema, 'default')) {\n        throw new ValueCreateError(schema, 'Array with the uniqueItems constraint requires a default value');\n    }\n    else if ('contains' in schema && !HasPropertyKey(schema, 'default')) {\n        throw new ValueCreateError(schema, 'Array with the contains constraint requires a default value');\n    }\n    else if ('default' in schema) {\n        return FromDefault(schema.default);\n    }\n    else if (schema.minItems !== undefined) {\n        return Array.from({ length: schema.minItems }).map((item) => {\n            return Visit(schema.items, references);\n        });\n    }\n    else {\n        return [];\n    }\n}\nfunction FromAsyncIterator(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return (async function* () { })();\n    }\n}\nfunction FromBigInt(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return BigInt(0);\n    }\n}\nfunction FromBoolean(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return false;\n    }\n}\nfunction FromConstructor(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        const value = Visit(schema.returns, references);\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            return class {\n                constructor() {\n                    for (const [key, val] of Object.entries(value)) {\n                        const self = this;\n                        self[key] = val;\n                    }\n                }\n            };\n        }\n        else {\n            return class {\n            };\n        }\n    }\n}\nfunction FromDate(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else if (schema.minimumTimestamp !== undefined) {\n        return new Date(schema.minimumTimestamp);\n    }\n    else {\n        return new Date();\n    }\n}\nfunction FromFunction(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return () => Visit(schema.returns, references);\n    }\n}\nfunction FromImport(schema, references) {\n    const definitions = globalThis.Object.values(schema.$defs);\n    const target = schema.$defs[schema.$ref];\n    return Visit(target, [...references, ...definitions]);\n}\nfunction FromInteger(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else if (schema.minimum !== undefined) {\n        return schema.minimum;\n    }\n    else {\n        return 0;\n    }\n}\nfunction FromIntersect(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        // --------------------------------------------------------------\n        // Note: The best we can do here is attempt to instance each\n        // sub type and apply through object assign. For non-object\n        // sub types, we just escape the assignment and just return\n        // the value. In the latter case, this is typically going to\n        // be a consequence of an illogical intersection.\n        // --------------------------------------------------------------\n        const value = schema.allOf.reduce((acc, schema) => {\n            const next = Visit(schema, references);\n            return typeof next === 'object' ? { ...acc, ...next } : next;\n        }, {});\n        if (!Check(schema, references, value))\n            throw new ValueCreateError(schema, 'Intersect produced invalid value. Consider using a default value.');\n        return value;\n    }\n}\nfunction FromIterator(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return (function* () { })();\n    }\n}\nfunction FromLiteral(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return schema.const;\n    }\n}\nfunction FromNever(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        throw new ValueCreateError(schema, 'Never types cannot be created. Consider using a default value.');\n    }\n}\nfunction FromNot(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        throw new ValueCreateError(schema, 'Not types must have a default value');\n    }\n}\nfunction FromNull(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return null;\n    }\n}\nfunction FromNumber(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else if (schema.minimum !== undefined) {\n        return schema.minimum;\n    }\n    else {\n        return 0;\n    }\n}\nfunction FromObject(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        const required = new Set(schema.required);\n        const Acc = {};\n        for (const [key, subschema] of Object.entries(schema.properties)) {\n            if (!required.has(key))\n                continue;\n            Acc[key] = Visit(subschema, references);\n        }\n        return Acc;\n    }\n}\nfunction FromPromise(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return Promise.resolve(Visit(schema.item, references));\n    }\n}\nfunction FromRecord(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return {};\n    }\n}\nfunction FromRef(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return Visit(Deref(schema, references), references);\n    }\n}\nfunction FromRegExp(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        throw new ValueCreateError(schema, 'RegExp types cannot be created. Consider using a default value.');\n    }\n}\nfunction FromString(schema, references) {\n    if (schema.pattern !== undefined) {\n        if (!HasPropertyKey(schema, 'default')) {\n            throw new ValueCreateError(schema, 'String types with patterns must specify a default value');\n        }\n        else {\n            return FromDefault(schema.default);\n        }\n    }\n    else if (schema.format !== undefined) {\n        if (!HasPropertyKey(schema, 'default')) {\n            throw new ValueCreateError(schema, 'String types with formats must specify a default value');\n        }\n        else {\n            return FromDefault(schema.default);\n        }\n    }\n    else {\n        if (HasPropertyKey(schema, 'default')) {\n            return FromDefault(schema.default);\n        }\n        else if (schema.minLength !== undefined) {\n            // prettier-ignore\n            return Array.from({ length: schema.minLength }).map(() => ' ').join('');\n        }\n        else {\n            return '';\n        }\n    }\n}\nfunction FromSymbol(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else if ('value' in schema) {\n        return Symbol.for(schema.value);\n    }\n    else {\n        return Symbol();\n    }\n}\nfunction FromTemplateLiteral(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    if (!IsTemplateLiteralFinite(schema))\n        throw new ValueCreateError(schema, 'Can only create template literals that produce a finite variants. Consider using a default value.');\n    const generated = TemplateLiteralGenerate(schema);\n    return generated[0];\n}\nfunction FromThis(schema, references) {\n    if (recursiveDepth++ > recursiveMaxDepth)\n        throw new ValueCreateError(schema, 'Cannot create recursive type as it appears possibly infinite. Consider using a default.');\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return Visit(Deref(schema, references), references);\n    }\n}\nfunction FromTuple(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    if (schema.items === undefined) {\n        return [];\n    }\n    else {\n        return Array.from({ length: schema.minItems }).map((_, index) => Visit(schema.items[index], references));\n    }\n}\nfunction FromUndefined(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return undefined;\n    }\n}\nfunction FromUnion(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else if (schema.anyOf.length === 0) {\n        throw new Error('ValueCreate.Union: Cannot create Union with zero variants');\n    }\n    else {\n        return Visit(schema.anyOf[0], references);\n    }\n}\nfunction FromUint8Array(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else if (schema.minByteLength !== undefined) {\n        return new Uint8Array(schema.minByteLength);\n    }\n    else {\n        return new Uint8Array(0);\n    }\n}\nfunction FromUnknown(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return {};\n    }\n}\nfunction FromVoid(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        return void 0;\n    }\n}\nfunction FromKind(schema, references) {\n    if (HasPropertyKey(schema, 'default')) {\n        return FromDefault(schema.default);\n    }\n    else {\n        throw new Error('User defined types must specify a default value');\n    }\n}\nfunction Visit(schema, references) {\n    const references_ = Pushref(schema, references);\n    const schema_ = schema;\n    switch (schema_[Kind]) {\n        case 'Any':\n            return FromAny(schema_, references_);\n        case 'Argument':\n            return FromArgument(schema_, references_);\n        case 'Array':\n            return FromArray(schema_, references_);\n        case 'AsyncIterator':\n            return FromAsyncIterator(schema_, references_);\n        case 'BigInt':\n            return FromBigInt(schema_, references_);\n        case 'Boolean':\n            return FromBoolean(schema_, references_);\n        case 'Constructor':\n            return FromConstructor(schema_, references_);\n        case 'Date':\n            return FromDate(schema_, references_);\n        case 'Function':\n            return FromFunction(schema_, references_);\n        case 'Import':\n            return FromImport(schema_, references_);\n        case 'Integer':\n            return FromInteger(schema_, references_);\n        case 'Intersect':\n            return FromIntersect(schema_, references_);\n        case 'Iterator':\n            return FromIterator(schema_, references_);\n        case 'Literal':\n            return FromLiteral(schema_, references_);\n        case 'Never':\n            return FromNever(schema_, references_);\n        case 'Not':\n            return FromNot(schema_, references_);\n        case 'Null':\n            return FromNull(schema_, references_);\n        case 'Number':\n            return FromNumber(schema_, references_);\n        case 'Object':\n            return FromObject(schema_, references_);\n        case 'Promise':\n            return FromPromise(schema_, references_);\n        case 'Record':\n            return FromRecord(schema_, references_);\n        case 'Ref':\n            return FromRef(schema_, references_);\n        case 'RegExp':\n            return FromRegExp(schema_, references_);\n        case 'String':\n            return FromString(schema_, references_);\n        case 'Symbol':\n            return FromSymbol(schema_, references_);\n        case 'TemplateLiteral':\n            return FromTemplateLiteral(schema_, references_);\n        case 'This':\n            return FromThis(schema_, references_);\n        case 'Tuple':\n            return FromTuple(schema_, references_);\n        case 'Undefined':\n            return FromUndefined(schema_, references_);\n        case 'Union':\n            return FromUnion(schema_, references_);\n        case 'Uint8Array':\n            return FromUint8Array(schema_, references_);\n        case 'Unknown':\n            return FromUnknown(schema_, references_);\n        case 'Void':\n            return FromVoid(schema_, references_);\n        default:\n            if (!TypeRegistry.Has(schema_[Kind]))\n                throw new ValueCreateError(schema_, 'Unknown type');\n            return FromKind(schema_, references_);\n    }\n}\n// ------------------------------------------------------------------\n// State\n// ------------------------------------------------------------------\nconst recursiveMaxDepth = 512;\nlet recursiveDepth = 0;\n/** Creates a value from the given schema */\nexport function Create(...args) {\n    recursiveDepth = 0;\n    return args.length === 2 ? Visit(args[0], args[1]) : Visit(args[0], []);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8111, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/cast/cast.mjs"],"sourcesContent":["import { IsObject, IsArray, IsString, IsNumber, IsNull } from '../guard/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\nimport { Create } from '../create/index.mjs';\nimport { Check } from '../check/index.mjs';\nimport { Clone } from '../clone/index.mjs';\nimport { Deref, Pushref } from '../deref/index.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValueCastError extends TypeBoxError {\n    constructor(schema, message) {\n        super(message);\n        this.schema = schema;\n    }\n}\n// ------------------------------------------------------------------\n// The following logic assigns a score to a schema based on how well\n// it matches a given value. For object types, the score is calculated\n// by evaluating each property of the value against the schema's\n// properties. To avoid bias towards objects with many properties,\n// each property contributes equally to the total score. Properties\n// that exactly match literal values receive the highest possible\n// score, as literals are often used as discriminators in union types.\n// ------------------------------------------------------------------\nfunction ScoreUnion(schema, references, value) {\n    if (schema[Kind] === 'Object' && typeof value === 'object' && !IsNull(value)) {\n        const object = schema;\n        const keys = Object.getOwnPropertyNames(value);\n        const entries = Object.entries(object.properties);\n        return entries.reduce((acc, [key, schema]) => {\n            const literal = schema[Kind] === 'Literal' && schema.const === value[key] ? 100 : 0;\n            const checks = Check(schema, references, value[key]) ? 10 : 0;\n            const exists = keys.includes(key) ? 1 : 0;\n            return acc + (literal + checks + exists);\n        }, 0);\n    }\n    else if (schema[Kind] === 'Union') {\n        const schemas = schema.anyOf.map((schema) => Deref(schema, references));\n        const scores = schemas.map((schema) => ScoreUnion(schema, references, value));\n        return Math.max(...scores);\n    }\n    else {\n        return Check(schema, references, value) ? 1 : 0;\n    }\n}\nfunction SelectUnion(union, references, value) {\n    const schemas = union.anyOf.map((schema) => Deref(schema, references));\n    let [select, best] = [schemas[0], 0];\n    for (const schema of schemas) {\n        const score = ScoreUnion(schema, references, value);\n        if (score > best) {\n            select = schema;\n            best = score;\n        }\n    }\n    return select;\n}\nfunction CastUnion(union, references, value) {\n    if ('default' in union) {\n        return typeof value === 'function' ? union.default : Clone(union.default);\n    }\n    else {\n        const schema = SelectUnion(union, references, value);\n        return Cast(schema, references, value);\n    }\n}\n// ------------------------------------------------------------------\n// Default\n// ------------------------------------------------------------------\nfunction DefaultClone(schema, references, value) {\n    return Check(schema, references, value) ? Clone(value) : Create(schema, references);\n}\nfunction Default(schema, references, value) {\n    return Check(schema, references, value) ? value : Create(schema, references);\n}\n// ------------------------------------------------------------------\n// Cast\n// ------------------------------------------------------------------\nfunction FromArray(schema, references, value) {\n    if (Check(schema, references, value))\n        return Clone(value);\n    const created = IsArray(value) ? Clone(value) : Create(schema, references);\n    const minimum = IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;\n    const maximum = IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;\n    const casted = maximum.map((value) => Visit(schema.items, references, value));\n    if (schema.uniqueItems !== true)\n        return casted;\n    const unique = [...new Set(casted)];\n    if (!Check(schema, references, unique))\n        throw new ValueCastError(schema, 'Array cast produced invalid data due to uniqueItems constraint');\n    return unique;\n}\nfunction FromConstructor(schema, references, value) {\n    if (Check(schema, references, value))\n        return Create(schema, references);\n    const required = new Set(schema.returns.required || []);\n    const result = function () { };\n    for (const [key, property] of Object.entries(schema.returns.properties)) {\n        if (!required.has(key) && value.prototype[key] === undefined)\n            continue;\n        result.prototype[key] = Visit(property, references, value.prototype[key]);\n    }\n    return result;\n}\nfunction FromImport(schema, references, value) {\n    const definitions = globalThis.Object.values(schema.$defs);\n    const target = schema.$defs[schema.$ref];\n    return Visit(target, [...references, ...definitions], value);\n}\n// ------------------------------------------------------------------\n// Intersect\n// ------------------------------------------------------------------\nfunction IntersectAssign(correct, value) {\n    // trust correct on mismatch | value on non-object\n    if ((IsObject(correct) && !IsObject(value)) || (!IsObject(correct) && IsObject(value)))\n        return correct;\n    if (!IsObject(correct) || !IsObject(value))\n        return value;\n    return globalThis.Object.getOwnPropertyNames(correct).reduce((result, key) => {\n        const property = key in value ? IntersectAssign(correct[key], value[key]) : correct[key];\n        return { ...result, [key]: property };\n    }, {});\n}\nfunction FromIntersect(schema, references, value) {\n    if (Check(schema, references, value))\n        return value;\n    const correct = Create(schema, references);\n    const assigned = IntersectAssign(correct, value);\n    return Check(schema, references, assigned) ? assigned : correct;\n}\nfunction FromNever(schema, references, value) {\n    throw new ValueCastError(schema, 'Never types cannot be cast');\n}\nfunction FromObject(schema, references, value) {\n    if (Check(schema, references, value))\n        return value;\n    if (value === null || typeof value !== 'object')\n        return Create(schema, references);\n    const required = new Set(schema.required || []);\n    const result = {};\n    for (const [key, property] of Object.entries(schema.properties)) {\n        if (!required.has(key) && value[key] === undefined)\n            continue;\n        result[key] = Visit(property, references, value[key]);\n    }\n    // additional schema properties\n    if (typeof schema.additionalProperties === 'object') {\n        const propertyNames = Object.getOwnPropertyNames(schema.properties);\n        for (const propertyName of Object.getOwnPropertyNames(value)) {\n            if (propertyNames.includes(propertyName))\n                continue;\n            result[propertyName] = Visit(schema.additionalProperties, references, value[propertyName]);\n        }\n    }\n    return result;\n}\nfunction FromRecord(schema, references, value) {\n    if (Check(schema, references, value))\n        return Clone(value);\n    if (value === null || typeof value !== 'object' || Array.isArray(value) || value instanceof Date)\n        return Create(schema, references);\n    const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];\n    const subschema = schema.patternProperties[subschemaPropertyName];\n    const result = {};\n    for (const [propKey, propValue] of Object.entries(value)) {\n        result[propKey] = Visit(subschema, references, propValue);\n    }\n    return result;\n}\nfunction FromRef(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromThis(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromTuple(schema, references, value) {\n    if (Check(schema, references, value))\n        return Clone(value);\n    if (!IsArray(value))\n        return Create(schema, references);\n    if (schema.items === undefined)\n        return [];\n    return schema.items.map((schema, index) => Visit(schema, references, value[index]));\n}\nfunction FromUnion(schema, references, value) {\n    return Check(schema, references, value) ? Clone(value) : CastUnion(schema, references, value);\n}\nfunction Visit(schema, references, value) {\n    const references_ = IsString(schema.$id) ? Pushref(schema, references) : references;\n    const schema_ = schema;\n    switch (schema[Kind]) {\n        // --------------------------------------------------------------\n        // Structural\n        // --------------------------------------------------------------\n        case 'Array':\n            return FromArray(schema_, references_, value);\n        case 'Constructor':\n            return FromConstructor(schema_, references_, value);\n        case 'Import':\n            return FromImport(schema_, references_, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, value);\n        case 'Never':\n            return FromNever(schema_, references_, value);\n        case 'Object':\n            return FromObject(schema_, references_, value);\n        case 'Record':\n            return FromRecord(schema_, references_, value);\n        case 'Ref':\n            return FromRef(schema_, references_, value);\n        case 'This':\n            return FromThis(schema_, references_, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, value);\n        case 'Union':\n            return FromUnion(schema_, references_, value);\n        // --------------------------------------------------------------\n        // DefaultClone\n        // --------------------------------------------------------------\n        case 'Date':\n        case 'Symbol':\n        case 'Uint8Array':\n            return DefaultClone(schema, references, value);\n        // --------------------------------------------------------------\n        // Default\n        // --------------------------------------------------------------\n        default:\n            return Default(schema_, references_, value);\n    }\n}\n/** Casts a value into a given type. The return value will retain as much information of the original value as possible. */\nexport function Cast(...args) {\n    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8355, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/clean/clean.mjs"],"sourcesContent":["import { KeyOfPropertyKeys } from '../../type/keyof/index.mjs';\nimport { Check } from '../check/index.mjs';\nimport { Clone } from '../clone/index.mjs';\nimport { Deref, Pushref } from '../deref/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { HasPropertyKey, IsString, IsObject, IsArray, IsUndefined } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\n// prettier-ignore\nimport { IsKind } from '../../type/guard/kind.mjs';\n// ------------------------------------------------------------------\n// IsCheckable\n// ------------------------------------------------------------------\nfunction IsCheckable(schema) {\n    return IsKind(schema) && schema[Kind] !== 'Unsafe';\n}\n// ------------------------------------------------------------------\n// Types\n// ------------------------------------------------------------------\nfunction FromArray(schema, references, value) {\n    if (!IsArray(value))\n        return value;\n    return value.map((value) => Visit(schema.items, references, value));\n}\nfunction FromImport(schema, references, value) {\n    const definitions = globalThis.Object.values(schema.$defs);\n    const target = schema.$defs[schema.$ref];\n    return Visit(target, [...references, ...definitions], value);\n}\nfunction FromIntersect(schema, references, value) {\n    const unevaluatedProperties = schema.unevaluatedProperties;\n    const intersections = schema.allOf.map((schema) => Visit(schema, references, Clone(value)));\n    const composite = intersections.reduce((acc, value) => (IsObject(value) ? { ...acc, ...value } : value), {});\n    if (!IsObject(value) || !IsObject(composite) || !IsKind(unevaluatedProperties))\n        return composite;\n    const knownkeys = KeyOfPropertyKeys(schema);\n    for (const key of Object.getOwnPropertyNames(value)) {\n        if (knownkeys.includes(key))\n            continue;\n        if (Check(unevaluatedProperties, references, value[key])) {\n            composite[key] = Visit(unevaluatedProperties, references, value[key]);\n        }\n    }\n    return composite;\n}\nfunction FromObject(schema, references, value) {\n    if (!IsObject(value) || IsArray(value))\n        return value; // Check IsArray for AllowArrayObject configuration\n    const additionalProperties = schema.additionalProperties;\n    for (const key of Object.getOwnPropertyNames(value)) {\n        if (HasPropertyKey(schema.properties, key)) {\n            value[key] = Visit(schema.properties[key], references, value[key]);\n            continue;\n        }\n        if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {\n            value[key] = Visit(additionalProperties, references, value[key]);\n            continue;\n        }\n        delete value[key];\n    }\n    return value;\n}\nfunction FromRecord(schema, references, value) {\n    if (!IsObject(value))\n        return value;\n    const additionalProperties = schema.additionalProperties;\n    const propertyKeys = Object.getOwnPropertyNames(value);\n    const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];\n    const propertyKeyTest = new RegExp(propertyKey);\n    for (const key of propertyKeys) {\n        if (propertyKeyTest.test(key)) {\n            value[key] = Visit(propertySchema, references, value[key]);\n            continue;\n        }\n        if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {\n            value[key] = Visit(additionalProperties, references, value[key]);\n            continue;\n        }\n        delete value[key];\n    }\n    return value;\n}\nfunction FromRef(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromThis(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromTuple(schema, references, value) {\n    if (!IsArray(value))\n        return value;\n    if (IsUndefined(schema.items))\n        return [];\n    const length = Math.min(value.length, schema.items.length);\n    for (let i = 0; i < length; i++) {\n        value[i] = Visit(schema.items[i], references, value[i]);\n    }\n    // prettier-ignore\n    return value.length > length\n        ? value.slice(0, length)\n        : value;\n}\nfunction FromUnion(schema, references, value) {\n    for (const inner of schema.anyOf) {\n        if (IsCheckable(inner) && Check(inner, references, value)) {\n            return Visit(inner, references, value);\n        }\n    }\n    return value;\n}\nfunction Visit(schema, references, value) {\n    const references_ = IsString(schema.$id) ? Pushref(schema, references) : references;\n    const schema_ = schema;\n    switch (schema_[Kind]) {\n        case 'Array':\n            return FromArray(schema_, references_, value);\n        case 'Import':\n            return FromImport(schema_, references_, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, value);\n        case 'Object':\n            return FromObject(schema_, references_, value);\n        case 'Record':\n            return FromRecord(schema_, references_, value);\n        case 'Ref':\n            return FromRef(schema_, references_, value);\n        case 'This':\n            return FromThis(schema_, references_, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, value);\n        case 'Union':\n            return FromUnion(schema_, references_, value);\n        default:\n            return value;\n    }\n}\n/** `[Mutable]` Removes excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first. */\nexport function Clean(...args) {\n    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8511, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/convert/convert.mjs"],"sourcesContent":["import { Clone } from '../clone/index.mjs';\nimport { Check } from '../check/index.mjs';\nimport { Deref, Pushref } from '../deref/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsObject, IsDate, IsUndefined, IsString, IsNumber, IsBoolean, IsBigInt, IsSymbol, HasPropertyKey } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// Conversions\n// ------------------------------------------------------------------\nfunction IsStringNumeric(value) {\n    return IsString(value) && !isNaN(value) && !isNaN(parseFloat(value));\n}\nfunction IsValueToString(value) {\n    return IsBigInt(value) || IsBoolean(value) || IsNumber(value);\n}\nfunction IsValueTrue(value) {\n    return value === true || (IsNumber(value) && value === 1) || (IsBigInt(value) && value === BigInt('1')) || (IsString(value) && (value.toLowerCase() === 'true' || value === '1'));\n}\nfunction IsValueFalse(value) {\n    return value === false || (IsNumber(value) && (value === 0 || Object.is(value, -0))) || (IsBigInt(value) && value === BigInt('0')) || (IsString(value) && (value.toLowerCase() === 'false' || value === '0' || value === '-0'));\n}\nfunction IsTimeStringWithTimeZone(value) {\n    return IsString(value) && /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i.test(value);\n}\nfunction IsTimeStringWithoutTimeZone(value) {\n    return IsString(value) && /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)?$/i.test(value);\n}\nfunction IsDateTimeStringWithTimeZone(value) {\n    return IsString(value) && /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\dt(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i.test(value);\n}\nfunction IsDateTimeStringWithoutTimeZone(value) {\n    return IsString(value) && /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\dt(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)?$/i.test(value);\n}\nfunction IsDateString(value) {\n    return IsString(value) && /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/i.test(value);\n}\n// ------------------------------------------------------------------\n// Convert\n// ------------------------------------------------------------------\nfunction TryConvertLiteralString(value, target) {\n    const conversion = TryConvertString(value);\n    return conversion === target ? conversion : value;\n}\nfunction TryConvertLiteralNumber(value, target) {\n    const conversion = TryConvertNumber(value);\n    return conversion === target ? conversion : value;\n}\nfunction TryConvertLiteralBoolean(value, target) {\n    const conversion = TryConvertBoolean(value);\n    return conversion === target ? conversion : value;\n}\n// prettier-ignore\nfunction TryConvertLiteral(schema, value) {\n    return (IsString(schema.const) ? TryConvertLiteralString(value, schema.const) :\n        IsNumber(schema.const) ? TryConvertLiteralNumber(value, schema.const) :\n            IsBoolean(schema.const) ? TryConvertLiteralBoolean(value, schema.const) :\n                value);\n}\nfunction TryConvertBoolean(value) {\n    return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;\n}\nfunction TryConvertBigInt(value) {\n    const truncateInteger = (value) => value.split('.')[0];\n    return IsStringNumeric(value) ? BigInt(truncateInteger(value)) : IsNumber(value) ? BigInt(Math.trunc(value)) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;\n}\nfunction TryConvertString(value) {\n    return IsSymbol(value) && value.description !== undefined ? value.description.toString() : IsValueToString(value) ? value.toString() : value;\n}\nfunction TryConvertNumber(value) {\n    return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;\n}\nfunction TryConvertInteger(value) {\n    return IsStringNumeric(value) ? parseInt(value) : IsNumber(value) ? Math.trunc(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;\n}\nfunction TryConvertNull(value) {\n    return IsString(value) && value.toLowerCase() === 'null' ? null : value;\n}\nfunction TryConvertUndefined(value) {\n    return IsString(value) && value === 'undefined' ? undefined : value;\n}\n// ------------------------------------------------------------------\n// note: this function may return an invalid dates for the regex\n// tests above. Invalid dates will however be checked during the\n// casting function and will return a epoch date if invalid.\n// Consider better string parsing for the iso dates in future\n// revisions.\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction TryConvertDate(value) {\n    return (IsDate(value) ? value :\n        IsNumber(value) ? new Date(value) :\n            IsValueTrue(value) ? new Date(1) :\n                IsValueFalse(value) ? new Date(0) :\n                    IsStringNumeric(value) ? new Date(parseInt(value)) :\n                        IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) :\n                            IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) :\n                                IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) :\n                                    IsDateTimeStringWithTimeZone(value) ? new Date(value) :\n                                        IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) :\n                                            value);\n}\n// ------------------------------------------------------------------\n// Default\n// ------------------------------------------------------------------\nfunction Default(value) {\n    return value;\n}\n// ------------------------------------------------------------------\n// Convert\n// ------------------------------------------------------------------\nfunction FromArray(schema, references, value) {\n    const elements = IsArray(value) ? value : [value];\n    return elements.map((element) => Visit(schema.items, references, element));\n}\nfunction FromBigInt(schema, references, value) {\n    return TryConvertBigInt(value);\n}\nfunction FromBoolean(schema, references, value) {\n    return TryConvertBoolean(value);\n}\nfunction FromDate(schema, references, value) {\n    return TryConvertDate(value);\n}\nfunction FromImport(schema, references, value) {\n    const definitions = globalThis.Object.values(schema.$defs);\n    const target = schema.$defs[schema.$ref];\n    return Visit(target, [...references, ...definitions], value);\n}\nfunction FromInteger(schema, references, value) {\n    return TryConvertInteger(value);\n}\nfunction FromIntersect(schema, references, value) {\n    return schema.allOf.reduce((value, schema) => Visit(schema, references, value), value);\n}\nfunction FromLiteral(schema, references, value) {\n    return TryConvertLiteral(schema, value);\n}\nfunction FromNull(schema, references, value) {\n    return TryConvertNull(value);\n}\nfunction FromNumber(schema, references, value) {\n    return TryConvertNumber(value);\n}\n// prettier-ignore\nfunction FromObject(schema, references, value) {\n    if (!IsObject(value) || IsArray(value))\n        return value;\n    for (const propertyKey of Object.getOwnPropertyNames(schema.properties)) {\n        if (!HasPropertyKey(value, propertyKey))\n            continue;\n        value[propertyKey] = Visit(schema.properties[propertyKey], references, value[propertyKey]);\n    }\n    return value;\n}\nfunction FromRecord(schema, references, value) {\n    const isConvertable = IsObject(value) && !IsArray(value);\n    if (!isConvertable)\n        return value;\n    const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];\n    const property = schema.patternProperties[propertyKey];\n    for (const [propKey, propValue] of Object.entries(value)) {\n        value[propKey] = Visit(property, references, propValue);\n    }\n    return value;\n}\nfunction FromRef(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromString(schema, references, value) {\n    return TryConvertString(value);\n}\nfunction FromSymbol(schema, references, value) {\n    return IsString(value) || IsNumber(value) ? Symbol(value) : value;\n}\nfunction FromThis(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\n// prettier-ignore\nfunction FromTuple(schema, references, value) {\n    const isConvertable = IsArray(value) && !IsUndefined(schema.items);\n    if (!isConvertable)\n        return value;\n    return value.map((value, index) => {\n        return (index < schema.items.length)\n            ? Visit(schema.items[index], references, value)\n            : value;\n    });\n}\nfunction FromUndefined(schema, references, value) {\n    return TryConvertUndefined(value);\n}\nfunction FromUnion(schema, references, value) {\n    // Check if original value already matches one of the union variants\n    for (const subschema of schema.anyOf) {\n        if (Check(subschema, references, value)) {\n            return value;\n        }\n    }\n    // Attempt conversion for each variant\n    for (const subschema of schema.anyOf) {\n        const converted = Visit(subschema, references, Clone(value));\n        if (!Check(subschema, references, converted))\n            continue;\n        return converted;\n    }\n    return value;\n}\nfunction Visit(schema, references, value) {\n    const references_ = Pushref(schema, references);\n    const schema_ = schema;\n    switch (schema[Kind]) {\n        case 'Array':\n            return FromArray(schema_, references_, value);\n        case 'BigInt':\n            return FromBigInt(schema_, references_, value);\n        case 'Boolean':\n            return FromBoolean(schema_, references_, value);\n        case 'Date':\n            return FromDate(schema_, references_, value);\n        case 'Import':\n            return FromImport(schema_, references_, value);\n        case 'Integer':\n            return FromInteger(schema_, references_, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, value);\n        case 'Literal':\n            return FromLiteral(schema_, references_, value);\n        case 'Null':\n            return FromNull(schema_, references_, value);\n        case 'Number':\n            return FromNumber(schema_, references_, value);\n        case 'Object':\n            return FromObject(schema_, references_, value);\n        case 'Record':\n            return FromRecord(schema_, references_, value);\n        case 'Ref':\n            return FromRef(schema_, references_, value);\n        case 'String':\n            return FromString(schema_, references_, value);\n        case 'Symbol':\n            return FromSymbol(schema_, references_, value);\n        case 'This':\n            return FromThis(schema_, references_, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, value);\n        case 'Undefined':\n            return FromUndefined(schema_, references_, value);\n        case 'Union':\n            return FromUnion(schema_, references_, value);\n        default:\n            return Default(value);\n    }\n}\n/** `[Mutable]` Converts any type mismatched values to their target type if a reasonable conversion is possible. */\n// prettier-ignore\nexport function Convert(...args) {\n    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8767, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/transform/has.mjs"],"sourcesContent":["import { Deref, Pushref } from '../deref/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\n// ------------------------------------------------------------------\n// KindGuard\n// ------------------------------------------------------------------\nimport { IsTransform, IsSchema } from '../../type/guard/kind.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsUndefined } from '../guard/index.mjs';\n// prettier-ignore\nfunction FromArray(schema, references) {\n    return IsTransform(schema) || Visit(schema.items, references);\n}\n// prettier-ignore\nfunction FromAsyncIterator(schema, references) {\n    return IsTransform(schema) || Visit(schema.items, references);\n}\n// prettier-ignore\nfunction FromConstructor(schema, references) {\n    return IsTransform(schema) || Visit(schema.returns, references) || schema.parameters.some((schema) => Visit(schema, references));\n}\n// prettier-ignore\nfunction FromFunction(schema, references) {\n    return IsTransform(schema) || Visit(schema.returns, references) || schema.parameters.some((schema) => Visit(schema, references));\n}\n// prettier-ignore\nfunction FromIntersect(schema, references) {\n    return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema) => Visit(schema, references));\n}\n// prettier-ignore\nfunction FromImport(schema, references) {\n    const additional = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => [...result, schema.$defs[key]], []);\n    const target = schema.$defs[schema.$ref];\n    return IsTransform(schema) || Visit(target, [...additional, ...references]);\n}\n// prettier-ignore\nfunction FromIterator(schema, references) {\n    return IsTransform(schema) || Visit(schema.items, references);\n}\n// prettier-ignore\nfunction FromNot(schema, references) {\n    return IsTransform(schema) || Visit(schema.not, references);\n}\n// prettier-ignore\nfunction FromObject(schema, references) {\n    return (IsTransform(schema) ||\n        Object.values(schema.properties).some((schema) => Visit(schema, references)) ||\n        (IsSchema(schema.additionalProperties) && Visit(schema.additionalProperties, references)));\n}\n// prettier-ignore\nfunction FromPromise(schema, references) {\n    return IsTransform(schema) || Visit(schema.item, references);\n}\n// prettier-ignore\nfunction FromRecord(schema, references) {\n    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n    const property = schema.patternProperties[pattern];\n    return IsTransform(schema) || Visit(property, references) || (IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties));\n}\n// prettier-ignore\nfunction FromRef(schema, references) {\n    if (IsTransform(schema))\n        return true;\n    return Visit(Deref(schema, references), references);\n}\n// prettier-ignore\nfunction FromThis(schema, references) {\n    if (IsTransform(schema))\n        return true;\n    return Visit(Deref(schema, references), references);\n}\n// prettier-ignore\nfunction FromTuple(schema, references) {\n    return IsTransform(schema) || (!IsUndefined(schema.items) && schema.items.some((schema) => Visit(schema, references)));\n}\n// prettier-ignore\nfunction FromUnion(schema, references) {\n    return IsTransform(schema) || schema.anyOf.some((schema) => Visit(schema, references));\n}\n// prettier-ignore\nfunction Visit(schema, references) {\n    const references_ = Pushref(schema, references);\n    const schema_ = schema;\n    if (schema.$id && visited.has(schema.$id))\n        return false;\n    if (schema.$id)\n        visited.add(schema.$id);\n    switch (schema[Kind]) {\n        case 'Array':\n            return FromArray(schema_, references_);\n        case 'AsyncIterator':\n            return FromAsyncIterator(schema_, references_);\n        case 'Constructor':\n            return FromConstructor(schema_, references_);\n        case 'Function':\n            return FromFunction(schema_, references_);\n        case 'Import':\n            return FromImport(schema_, references_);\n        case 'Intersect':\n            return FromIntersect(schema_, references_);\n        case 'Iterator':\n            return FromIterator(schema_, references_);\n        case 'Not':\n            return FromNot(schema_, references_);\n        case 'Object':\n            return FromObject(schema_, references_);\n        case 'Promise':\n            return FromPromise(schema_, references_);\n        case 'Record':\n            return FromRecord(schema_, references_);\n        case 'Ref':\n            return FromRef(schema_, references_);\n        case 'This':\n            return FromThis(schema_, references_);\n        case 'Tuple':\n            return FromTuple(schema_, references_);\n        case 'Union':\n            return FromUnion(schema_, references_);\n        default:\n            return IsTransform(schema);\n    }\n}\nconst visited = new Set();\n/** Returns true if this schema contains a transform codec */\nexport function HasTransform(schema, references) {\n    visited.clear();\n    return Visit(schema, references);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8907, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs"],"sourcesContent":["import { IndexFromPropertyKeys } from '../indexed/indexed.mjs';\nimport { KeyOfPropertyKeys } from './keyof-property-keys.mjs';\n/**\n * `[Utility]` Resolves an array of keys and schemas from the given schema. This method is faster\n * than obtaining the keys and resolving each individually via indexing. This method was written\n * accellerate Intersect and Union encoding.\n */\nexport function KeyOfPropertyEntries(schema) {\n    const keys = KeyOfPropertyKeys(schema);\n    const schemas = IndexFromPropertyKeys(schema, keys);\n    return keys.map((_, index) => [keys[index], schemas[index]]);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAMO,SAAS,qBAAqB,MAAM;IACvC,MAAM,OAAO,IAAA,2NAAiB,EAAC;IAC/B,MAAM,UAAU,IAAA,+MAAqB,EAAC,QAAQ;IAC9C,OAAO,KAAK,GAAG,CAAC,CAAC,GAAG,QAAU;YAAC,IAAI,CAAC,MAAM;YAAE,OAAO,CAAC,MAAM;SAAC;AAC/D","ignoreList":[0]}},
    {"offset": {"line": 8927, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/transform/decode.mjs"],"sourcesContent":["import { TypeSystemPolicy } from '../../system/policy.mjs';\nimport { Kind, TransformKind } from '../../type/symbols/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\nimport { KeyOfPropertyKeys, KeyOfPropertyEntries } from '../../type/keyof/index.mjs';\nimport { Deref, Pushref } from '../deref/index.mjs';\nimport { Check } from '../check/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { HasPropertyKey, IsObject, IsArray, IsValueType, IsUndefined as IsUndefinedValue } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// KindGuard\n// ------------------------------------------------------------------\nimport { IsTransform, IsSchema, IsUndefined } from '../../type/guard/kind.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\n// thrown externally\n// prettier-ignore\nexport class TransformDecodeCheckError extends TypeBoxError {\n    constructor(schema, value, error) {\n        super(`Unable to decode value as it does not match the expected schema`);\n        this.schema = schema;\n        this.value = value;\n        this.error = error;\n    }\n}\n// prettier-ignore\nexport class TransformDecodeError extends TypeBoxError {\n    constructor(schema, path, value, error) {\n        super(error instanceof Error ? error.message : 'Unknown error');\n        this.schema = schema;\n        this.path = path;\n        this.value = value;\n        this.error = error;\n    }\n}\n// ------------------------------------------------------------------\n// Decode\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction Default(schema, path, value) {\n    try {\n        return IsTransform(schema) ? schema[TransformKind].Decode(value) : value;\n    }\n    catch (error) {\n        throw new TransformDecodeError(schema, path, value, error);\n    }\n}\n// prettier-ignore\nfunction FromArray(schema, references, path, value) {\n    return (IsArray(value))\n        ? Default(schema, path, value.map((value, index) => Visit(schema.items, references, `${path}/${index}`, value)))\n        : Default(schema, path, value);\n}\n// prettier-ignore\nfunction FromIntersect(schema, references, path, value) {\n    if (!IsObject(value) || IsValueType(value))\n        return Default(schema, path, value);\n    const knownEntries = KeyOfPropertyEntries(schema);\n    const knownKeys = knownEntries.map(entry => entry[0]);\n    const knownProperties = { ...value };\n    for (const [knownKey, knownSchema] of knownEntries)\n        if (knownKey in knownProperties) {\n            knownProperties[knownKey] = Visit(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);\n        }\n    if (!IsTransform(schema.unevaluatedProperties)) {\n        return Default(schema, path, knownProperties);\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const unevaluatedProperties = schema.unevaluatedProperties;\n    const unknownProperties = { ...knownProperties };\n    for (const key of unknownKeys)\n        if (!knownKeys.includes(key)) {\n            unknownProperties[key] = Default(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);\n        }\n    return Default(schema, path, unknownProperties);\n}\n// prettier-ignore\nfunction FromImport(schema, references, path, value) {\n    const additional = globalThis.Object.values(schema.$defs);\n    const target = schema.$defs[schema.$ref];\n    const result = Visit(target, [...references, ...additional], path, value);\n    return Default(schema, path, result);\n}\nfunction FromNot(schema, references, path, value) {\n    return Default(schema, path, Visit(schema.not, references, path, value));\n}\n// prettier-ignore\nfunction FromObject(schema, references, path, value) {\n    if (!IsObject(value))\n        return Default(schema, path, value);\n    const knownKeys = KeyOfPropertyKeys(schema);\n    const knownProperties = { ...value };\n    for (const key of knownKeys) {\n        if (!HasPropertyKey(knownProperties, key))\n            continue;\n        // if the property value is undefined, but the target is not, nor does it satisfy exact optional \n        // property policy, then we need to continue. This is a special case for optional property handling \n        // where a transforms wrapped in a optional modifiers should not run.\n        if (IsUndefinedValue(knownProperties[key]) && (!IsUndefined(schema.properties[key]) ||\n            TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))\n            continue;\n        // decode property\n        knownProperties[key] = Visit(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);\n    }\n    if (!IsSchema(schema.additionalProperties)) {\n        return Default(schema, path, knownProperties);\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const additionalProperties = schema.additionalProperties;\n    const unknownProperties = { ...knownProperties };\n    for (const key of unknownKeys)\n        if (!knownKeys.includes(key)) {\n            unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);\n        }\n    return Default(schema, path, unknownProperties);\n}\n// prettier-ignore\nfunction FromRecord(schema, references, path, value) {\n    if (!IsObject(value))\n        return Default(schema, path, value);\n    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n    const knownKeys = new RegExp(pattern);\n    const knownProperties = { ...value };\n    for (const key of Object.getOwnPropertyNames(value))\n        if (knownKeys.test(key)) {\n            knownProperties[key] = Visit(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);\n        }\n    if (!IsSchema(schema.additionalProperties)) {\n        return Default(schema, path, knownProperties);\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const additionalProperties = schema.additionalProperties;\n    const unknownProperties = { ...knownProperties };\n    for (const key of unknownKeys)\n        if (!knownKeys.test(key)) {\n            unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);\n        }\n    return Default(schema, path, unknownProperties);\n}\n// prettier-ignore\nfunction FromRef(schema, references, path, value) {\n    const target = Deref(schema, references);\n    return Default(schema, path, Visit(target, references, path, value));\n}\n// prettier-ignore\nfunction FromThis(schema, references, path, value) {\n    const target = Deref(schema, references);\n    return Default(schema, path, Visit(target, references, path, value));\n}\n// prettier-ignore\nfunction FromTuple(schema, references, path, value) {\n    return (IsArray(value) && IsArray(schema.items))\n        ? Default(schema, path, schema.items.map((schema, index) => Visit(schema, references, `${path}/${index}`, value[index])))\n        : Default(schema, path, value);\n}\n// prettier-ignore\nfunction FromUnion(schema, references, path, value) {\n    for (const subschema of schema.anyOf) {\n        if (!Check(subschema, references, value))\n            continue;\n        // note: ensure interior is decoded first\n        const decoded = Visit(subschema, references, path, value);\n        return Default(schema, path, decoded);\n    }\n    return Default(schema, path, value);\n}\n// prettier-ignore\nfunction Visit(schema, references, path, value) {\n    const references_ = Pushref(schema, references);\n    const schema_ = schema;\n    switch (schema[Kind]) {\n        case 'Array':\n            return FromArray(schema_, references_, path, value);\n        case 'Import':\n            return FromImport(schema_, references_, path, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, path, value);\n        case 'Not':\n            return FromNot(schema_, references_, path, value);\n        case 'Object':\n            return FromObject(schema_, references_, path, value);\n        case 'Record':\n            return FromRecord(schema_, references_, path, value);\n        case 'Ref':\n            return FromRef(schema_, references_, path, value);\n        case 'Symbol':\n            return Default(schema_, path, value);\n        case 'This':\n            return FromThis(schema_, references_, path, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, path, value);\n        case 'Union':\n            return FromUnion(schema_, references_, path, value);\n        default:\n            return Default(schema_, path, value);\n    }\n}\n/**\n * `[Internal]` Decodes the value and returns the result. This function requires that\n * the caller `Check` the value before use. Passing unchecked values may result in\n * undefined behavior. Refer to the `Value.Decode()` for implementation details.\n */\nexport function TransformDecode(schema, references, value) {\n    return Visit(schema, references, '', value);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9142, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/decode/decode.mjs"],"sourcesContent":["import { HasTransform, TransformDecode, TransformDecodeCheckError } from '../transform/index.mjs';\nimport { Check } from '../check/index.mjs';\nimport { Errors } from '../../errors/index.mjs';\n/** Decodes a value or throws if error */\nexport function Decode(...args) {\n    const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];\n    if (!Check(schema, references, value))\n        throw new TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());\n    return HasTransform(schema, references) ? TransformDecode(schema, references, value) : value;\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AACA;;;;AAEO,SAAS,OAAO,GAAG,IAAI;IAC1B,MAAM,CAAC,QAAQ,YAAY,MAAM,GAAG,KAAK,MAAM,KAAK,IAAI;QAAC,IAAI,CAAC,EAAE;QAAE,IAAI,CAAC,EAAE;QAAE,IAAI,CAAC,EAAE;KAAC,GAAG;QAAC,IAAI,CAAC,EAAE;QAAE,EAAE;QAAE,IAAI,CAAC,EAAE;KAAC;IAC5G,IAAI,CAAC,IAAA,4LAAK,EAAC,QAAQ,YAAY,QAC3B,MAAM,IAAI,qNAAyB,CAAC,QAAQ,OAAO,IAAA,sLAAM,EAAC,QAAQ,YAAY,OAAO,KAAK;IAC9F,OAAO,IAAA,qMAAY,EAAC,QAAQ,cAAc,IAAA,2MAAe,EAAC,QAAQ,YAAY,SAAS;AAC3F","ignoreList":[0]}},
    {"offset": {"line": 9170, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/default/default.mjs"],"sourcesContent":["import { Check } from '../check/index.mjs';\nimport { Clone } from '../clone/index.mjs';\nimport { Deref, Pushref } from '../deref/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsDate, IsFunction, IsObject, IsUndefined, HasPropertyKey } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsKind } from '../../type/guard/kind.mjs';\n// ------------------------------------------------------------------\n// ValueOrDefault\n// ------------------------------------------------------------------\nfunction ValueOrDefault(schema, value) {\n    const defaultValue = HasPropertyKey(schema, 'default') ? schema.default : undefined;\n    const clone = IsFunction(defaultValue) ? defaultValue() : Clone(defaultValue);\n    return IsUndefined(value) ? clone : IsObject(value) && IsObject(clone) ? Object.assign(clone, value) : value;\n}\n// ------------------------------------------------------------------\n// HasDefaultProperty\n// ------------------------------------------------------------------\nfunction HasDefaultProperty(schema) {\n    return IsKind(schema) && 'default' in schema;\n}\n// ------------------------------------------------------------------\n// Types\n// ------------------------------------------------------------------\nfunction FromArray(schema, references, value) {\n    // if the value is an array, we attempt to initialize it's elements\n    if (IsArray(value)) {\n        for (let i = 0; i < value.length; i++) {\n            value[i] = Visit(schema.items, references, value[i]);\n        }\n        return value;\n    }\n    // ... otherwise use default initialization\n    const defaulted = ValueOrDefault(schema, value);\n    if (!IsArray(defaulted))\n        return defaulted;\n    for (let i = 0; i < defaulted.length; i++) {\n        defaulted[i] = Visit(schema.items, references, defaulted[i]);\n    }\n    return defaulted;\n}\nfunction FromDate(schema, references, value) {\n    // special case intercept for dates\n    return IsDate(value) ? value : ValueOrDefault(schema, value);\n}\nfunction FromImport(schema, references, value) {\n    const definitions = globalThis.Object.values(schema.$defs);\n    const target = schema.$defs[schema.$ref];\n    return Visit(target, [...references, ...definitions], value);\n}\nfunction FromIntersect(schema, references, value) {\n    const defaulted = ValueOrDefault(schema, value);\n    return schema.allOf.reduce((acc, schema) => {\n        const next = Visit(schema, references, defaulted);\n        return IsObject(next) ? { ...acc, ...next } : next;\n    }, {});\n}\nfunction FromObject(schema, references, value) {\n    const defaulted = ValueOrDefault(schema, value);\n    // return defaulted\n    if (!IsObject(defaulted))\n        return defaulted;\n    const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);\n    // properties\n    for (const key of knownPropertyKeys) {\n        // note: we need to traverse into the object and test if the return value\n        // yielded a non undefined result. Here we interpret an undefined result as\n        // a non assignable property and continue.\n        const propertyValue = Visit(schema.properties[key], references, defaulted[key]);\n        if (IsUndefined(propertyValue))\n            continue;\n        defaulted[key] = Visit(schema.properties[key], references, defaulted[key]);\n    }\n    // return if not additional properties\n    if (!HasDefaultProperty(schema.additionalProperties))\n        return defaulted;\n    // additional properties\n    for (const key of Object.getOwnPropertyNames(defaulted)) {\n        if (knownPropertyKeys.includes(key))\n            continue;\n        defaulted[key] = Visit(schema.additionalProperties, references, defaulted[key]);\n    }\n    return defaulted;\n}\nfunction FromRecord(schema, references, value) {\n    const defaulted = ValueOrDefault(schema, value);\n    if (!IsObject(defaulted))\n        return defaulted;\n    const additionalPropertiesSchema = schema.additionalProperties;\n    const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];\n    const knownPropertyKey = new RegExp(propertyKeyPattern);\n    // properties\n    for (const key of Object.getOwnPropertyNames(defaulted)) {\n        if (!(knownPropertyKey.test(key) && HasDefaultProperty(propertySchema)))\n            continue;\n        defaulted[key] = Visit(propertySchema, references, defaulted[key]);\n    }\n    // return if not additional properties\n    if (!HasDefaultProperty(additionalPropertiesSchema))\n        return defaulted;\n    // additional properties\n    for (const key of Object.getOwnPropertyNames(defaulted)) {\n        if (knownPropertyKey.test(key))\n            continue;\n        defaulted[key] = Visit(additionalPropertiesSchema, references, defaulted[key]);\n    }\n    return defaulted;\n}\nfunction FromRef(schema, references, value) {\n    return Visit(Deref(schema, references), references, ValueOrDefault(schema, value));\n}\nfunction FromThis(schema, references, value) {\n    return Visit(Deref(schema, references), references, value);\n}\nfunction FromTuple(schema, references, value) {\n    const defaulted = ValueOrDefault(schema, value);\n    if (!IsArray(defaulted) || IsUndefined(schema.items))\n        return defaulted;\n    const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];\n    for (let i = 0; i < max; i++) {\n        if (i < items.length)\n            defaulted[i] = Visit(items[i], references, defaulted[i]);\n    }\n    return defaulted;\n}\nfunction FromUnion(schema, references, value) {\n    const defaulted = ValueOrDefault(schema, value);\n    for (const inner of schema.anyOf) {\n        const result = Visit(inner, references, Clone(defaulted));\n        if (Check(inner, references, result)) {\n            return result;\n        }\n    }\n    return defaulted;\n}\nfunction Visit(schema, references, value) {\n    const references_ = Pushref(schema, references);\n    const schema_ = schema;\n    switch (schema_[Kind]) {\n        case 'Array':\n            return FromArray(schema_, references_, value);\n        case 'Date':\n            return FromDate(schema_, references_, value);\n        case 'Import':\n            return FromImport(schema_, references_, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, value);\n        case 'Object':\n            return FromObject(schema_, references_, value);\n        case 'Record':\n            return FromRecord(schema_, references_, value);\n        case 'Ref':\n            return FromRef(schema_, references_, value);\n        case 'This':\n            return FromThis(schema_, references_, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, value);\n        case 'Union':\n            return FromUnion(schema_, references_, value);\n        default:\n            return ValueOrDefault(schema_, value);\n    }\n}\n/** `[Mutable]` Generates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first. */\nexport function Default(...args) {\n    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,aAAa;AACb,qEAAqE;AACrE;AACA,qEAAqE;AACrE,YAAY;AACZ,qEAAqE;AACrE;;;;;;;AACA,qEAAqE;AACrE,iBAAiB;AACjB,qEAAqE;AACrE,SAAS,eAAe,MAAM,EAAE,KAAK;IACjC,MAAM,eAAe,IAAA,qMAAc,EAAC,QAAQ,aAAa,OAAO,OAAO,GAAG;IAC1E,MAAM,QAAQ,IAAA,iMAAU,EAAC,gBAAgB,iBAAiB,IAAA,4LAAK,EAAC;IAChE,OAAO,IAAA,kMAAW,EAAC,SAAS,QAAQ,IAAA,+LAAQ,EAAC,UAAU,IAAA,+LAAQ,EAAC,SAAS,OAAO,MAAM,CAAC,OAAO,SAAS;AAC3G;AACA,qEAAqE;AACrE,qBAAqB;AACrB,qEAAqE;AACrE,SAAS,mBAAmB,MAAM;IAC9B,OAAO,IAAA,2LAAM,EAAC,WAAW,aAAa;AAC1C;AACA,qEAAqE;AACrE,QAAQ;AACR,qEAAqE;AACrE,SAAS,UAAU,MAAM,EAAE,UAAU,EAAE,KAAK;IACxC,mEAAmE;IACnE,IAAI,IAAA,8LAAO,EAAC,QAAQ;QAChB,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAK;YACnC,KAAK,CAAC,EAAE,GAAG,MAAM,OAAO,KAAK,EAAE,YAAY,KAAK,CAAC,EAAE;QACvD;QACA,OAAO;IACX;IACA,2CAA2C;IAC3C,MAAM,YAAY,eAAe,QAAQ;IACzC,IAAI,CAAC,IAAA,8LAAO,EAAC,YACT,OAAO;IACX,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAK;QACvC,SAAS,CAAC,EAAE,GAAG,MAAM,OAAO,KAAK,EAAE,YAAY,SAAS,CAAC,EAAE;IAC/D;IACA,OAAO;AACX;AACA,SAAS,SAAS,MAAM,EAAE,UAAU,EAAE,KAAK;IACvC,mCAAmC;IACnC,OAAO,IAAA,6LAAM,EAAC,SAAS,QAAQ,eAAe,QAAQ;AAC1D;AACA,SAAS,WAAW,MAAM,EAAE,UAAU,EAAE,KAAK;IACzC,MAAM,cAAc,WAAW,MAAM,CAAC,MAAM,CAAC,OAAO,KAAK;IACzD,MAAM,SAAS,OAAO,KAAK,CAAC,OAAO,IAAI,CAAC;IACxC,OAAO,MAAM,QAAQ;WAAI;WAAe;KAAY,EAAE;AAC1D;AACA,SAAS,cAAc,MAAM,EAAE,UAAU,EAAE,KAAK;IAC5C,MAAM,YAAY,eAAe,QAAQ;IACzC,OAAO,OAAO,KAAK,CAAC,MAAM,CAAC,CAAC,KAAK;QAC7B,MAAM,OAAO,MAAM,QAAQ,YAAY;QACvC,OAAO,IAAA,+LAAQ,EAAC,QAAQ;YAAE,GAAG,GAAG;YAAE,GAAG,IAAI;QAAC,IAAI;IAClD,GAAG,CAAC;AACR;AACA,SAAS,WAAW,MAAM,EAAE,UAAU,EAAE,KAAK;IACzC,MAAM,YAAY,eAAe,QAAQ;IACzC,mBAAmB;IACnB,IAAI,CAAC,IAAA,+LAAQ,EAAC,YACV,OAAO;IACX,MAAM,oBAAoB,OAAO,mBAAmB,CAAC,OAAO,UAAU;IACtE,aAAa;IACb,KAAK,MAAM,OAAO,kBAAmB;QACjC,yEAAyE;QACzE,2EAA2E;QAC3E,0CAA0C;QAC1C,MAAM,gBAAgB,MAAM,OAAO,UAAU,CAAC,IAAI,EAAE,YAAY,SAAS,CAAC,IAAI;QAC9E,IAAI,IAAA,kMAAW,EAAC,gBACZ;QACJ,SAAS,CAAC,IAAI,GAAG,MAAM,OAAO,UAAU,CAAC,IAAI,EAAE,YAAY,SAAS,CAAC,IAAI;IAC7E;IACA,sCAAsC;IACtC,IAAI,CAAC,mBAAmB,OAAO,oBAAoB,GAC/C,OAAO;IACX,wBAAwB;IACxB,KAAK,MAAM,OAAO,OAAO,mBAAmB,CAAC,WAAY;QACrD,IAAI,kBAAkB,QAAQ,CAAC,MAC3B;QACJ,SAAS,CAAC,IAAI,GAAG,MAAM,OAAO,oBAAoB,EAAE,YAAY,SAAS,CAAC,IAAI;IAClF;IACA,OAAO;AACX;AACA,SAAS,WAAW,MAAM,EAAE,UAAU,EAAE,KAAK;IACzC,MAAM,YAAY,eAAe,QAAQ;IACzC,IAAI,CAAC,IAAA,+LAAQ,EAAC,YACV,OAAO;IACX,MAAM,6BAA6B,OAAO,oBAAoB;IAC9D,MAAM,CAAC,oBAAoB,eAAe,GAAG,OAAO,OAAO,CAAC,OAAO,iBAAiB,CAAC,CAAC,EAAE;IACxF,MAAM,mBAAmB,IAAI,OAAO;IACpC,aAAa;IACb,KAAK,MAAM,OAAO,OAAO,mBAAmB,CAAC,WAAY;QACrD,IAAI,CAAC,CAAC,iBAAiB,IAAI,CAAC,QAAQ,mBAAmB,eAAe,GAClE;QACJ,SAAS,CAAC,IAAI,GAAG,MAAM,gBAAgB,YAAY,SAAS,CAAC,IAAI;IACrE;IACA,sCAAsC;IACtC,IAAI,CAAC,mBAAmB,6BACpB,OAAO;IACX,wBAAwB;IACxB,KAAK,MAAM,OAAO,OAAO,mBAAmB,CAAC,WAAY;QACrD,IAAI,iBAAiB,IAAI,CAAC,MACtB;QACJ,SAAS,CAAC,IAAI,GAAG,MAAM,4BAA4B,YAAY,SAAS,CAAC,IAAI;IACjF;IACA,OAAO;AACX;AACA,SAAS,QAAQ,MAAM,EAAE,UAAU,EAAE,KAAK;IACtC,OAAO,MAAM,IAAA,4LAAK,EAAC,QAAQ,aAAa,YAAY,eAAe,QAAQ;AAC/E;AACA,SAAS,SAAS,MAAM,EAAE,UAAU,EAAE,KAAK;IACvC,OAAO,MAAM,IAAA,4LAAK,EAAC,QAAQ,aAAa,YAAY;AACxD;AACA,SAAS,UAAU,MAAM,EAAE,UAAU,EAAE,KAAK;IACxC,MAAM,YAAY,eAAe,QAAQ;IACzC,IAAI,CAAC,IAAA,8LAAO,EAAC,cAAc,IAAA,kMAAW,EAAC,OAAO,KAAK,GAC/C,OAAO;IACX,MAAM,CAAC,OAAO,IAAI,GAAG;QAAC,OAAO,KAAK;QAAE,KAAK,GAAG,CAAC,OAAO,KAAK,CAAC,MAAM,EAAE,UAAU,MAAM;KAAE;IACpF,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,IAAK;QAC1B,IAAI,IAAI,MAAM,MAAM,EAChB,SAAS,CAAC,EAAE,GAAG,MAAM,KAAK,CAAC,EAAE,EAAE,YAAY,SAAS,CAAC,EAAE;IAC/D;IACA,OAAO;AACX;AACA,SAAS,UAAU,MAAM,EAAE,UAAU,EAAE,KAAK;IACxC,MAAM,YAAY,eAAe,QAAQ;IACzC,KAAK,MAAM,SAAS,OAAO,KAAK,CAAE;QAC9B,MAAM,SAAS,MAAM,OAAO,YAAY,IAAA,4LAAK,EAAC;QAC9C,IAAI,IAAA,4LAAK,EAAC,OAAO,YAAY,SAAS;YAClC,OAAO;QACX;IACJ;IACA,OAAO;AACX;AACA,SAAS,MAAM,MAAM,EAAE,UAAU,EAAE,KAAK;IACpC,MAAM,cAAc,IAAA,8LAAO,EAAC,QAAQ;IACpC,MAAM,UAAU;IAChB,OAAQ,OAAO,CAAC,8LAAI,CAAC;QACjB,KAAK;YACD,OAAO,UAAU,SAAS,aAAa;QAC3C,KAAK;YACD,OAAO,SAAS,SAAS,aAAa;QAC1C,KAAK;YACD,OAAO,WAAW,SAAS,aAAa;QAC5C,KAAK;YACD,OAAO,cAAc,SAAS,aAAa;QAC/C,KAAK;YACD,OAAO,WAAW,SAAS,aAAa;QAC5C,KAAK;YACD,OAAO,WAAW,SAAS,aAAa;QAC5C,KAAK;YACD,OAAO,QAAQ,SAAS,aAAa;QACzC,KAAK;YACD,OAAO,SAAS,SAAS,aAAa;QAC1C,KAAK;YACD,OAAO,UAAU,SAAS,aAAa;QAC3C,KAAK;YACD,OAAO,UAAU,SAAS,aAAa;QAC3C;YACI,OAAO,eAAe,SAAS;IACvC;AACJ;AAEO,SAAS,QAAQ,GAAG,IAAI;IAC3B,OAAO,KAAK,MAAM,KAAK,IAAI,MAAM,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,IAAI,MAAM,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,IAAI,CAAC,EAAE;AAC5F","ignoreList":[0]}},
    {"offset": {"line": 9353, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/pointer/pointer.mjs"],"sourcesContent":["import { TypeBoxError } from '../../type/error/index.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValuePointerRootSetError extends TypeBoxError {\n    constructor(value, path, update) {\n        super('Cannot set root value');\n        this.value = value;\n        this.path = path;\n        this.update = update;\n    }\n}\nexport class ValuePointerRootDeleteError extends TypeBoxError {\n    constructor(value, path) {\n        super('Cannot delete root value');\n        this.value = value;\n        this.path = path;\n    }\n}\n// ------------------------------------------------------------------\n// ValuePointer\n// ------------------------------------------------------------------\n/** Provides functionality to update values through RFC6901 string pointers */\n// prettier-ignore\nfunction Escape(component) {\n    return component.indexOf('~') === -1 ? component : component.replace(/~1/g, '/').replace(/~0/g, '~');\n}\n/** Formats the given pointer into navigable key components */\n// prettier-ignore\nexport function* Format(pointer) {\n    if (pointer === '')\n        return;\n    let [start, end] = [0, 0];\n    for (let i = 0; i < pointer.length; i++) {\n        const char = pointer.charAt(i);\n        if (char === '/') {\n            if (i === 0) {\n                start = i + 1;\n            }\n            else {\n                end = i;\n                yield Escape(pointer.slice(start, end));\n                start = i + 1;\n            }\n        }\n        else {\n            end = i;\n        }\n    }\n    yield Escape(pointer.slice(start));\n}\n/** Sets the value at the given pointer. If the value at the pointer does not exist it is created */\n// prettier-ignore\nexport function Set(value, pointer, update) {\n    if (pointer === '')\n        throw new ValuePointerRootSetError(value, pointer, update);\n    let [owner, next, key] = [null, value, ''];\n    for (const component of Format(pointer)) {\n        if (next[component] === undefined)\n            next[component] = {};\n        owner = next;\n        next = next[component];\n        key = component;\n    }\n    owner[key] = update;\n}\n/** Deletes a value at the given pointer */\n// prettier-ignore\nexport function Delete(value, pointer) {\n    if (pointer === '')\n        throw new ValuePointerRootDeleteError(value, pointer);\n    let [owner, next, key] = [null, value, ''];\n    for (const component of Format(pointer)) {\n        if (next[component] === undefined || next[component] === null)\n            return;\n        owner = next;\n        next = next[component];\n        key = component;\n    }\n    if (Array.isArray(owner)) {\n        const index = parseInt(key);\n        owner.splice(index, 1);\n    }\n    else {\n        delete owner[key];\n    }\n}\n/** Returns true if a value exists at the given pointer */\n// prettier-ignore\nexport function Has(value, pointer) {\n    if (pointer === '')\n        return true;\n    let [owner, next, key] = [null, value, ''];\n    for (const component of Format(pointer)) {\n        if (next[component] === undefined)\n            return false;\n        owner = next;\n        next = next[component];\n        key = component;\n    }\n    return Object.getOwnPropertyNames(owner).includes(key);\n}\n/** Gets the value at the given pointer */\n// prettier-ignore\nexport function Get(value, pointer) {\n    if (pointer === '')\n        return value;\n    let current = value;\n    for (const component of Format(pointer)) {\n        if (current[component] === undefined)\n            return undefined;\n        current = current[component];\n    }\n    return current;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9487, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/equal/equal.mjs"],"sourcesContent":["import { IsObject, IsDate, IsArray, IsTypedArray, IsValueType } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// Equality Checks\n// ------------------------------------------------------------------\nfunction ObjectType(left, right) {\n    if (!IsObject(right))\n        return false;\n    const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];\n    const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];\n    if (leftKeys.length !== rightKeys.length)\n        return false;\n    return leftKeys.every((key) => Equal(left[key], right[key]));\n}\nfunction DateType(left, right) {\n    return IsDate(right) && left.getTime() === right.getTime();\n}\nfunction ArrayType(left, right) {\n    if (!IsArray(right) || left.length !== right.length)\n        return false;\n    return left.every((value, index) => Equal(value, right[index]));\n}\nfunction TypedArrayType(left, right) {\n    if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)\n        return false;\n    return left.every((value, index) => Equal(value, right[index]));\n}\nfunction ValueType(left, right) {\n    return left === right;\n}\n// ------------------------------------------------------------------\n// Equal\n// ------------------------------------------------------------------\n/** Returns true if the left value deep-equals the right */\nexport function Equal(left, right) {\n    if (IsDate(left))\n        return DateType(left, right);\n    if (IsTypedArray(left))\n        return TypedArrayType(left, right);\n    if (IsArray(left))\n        return ArrayType(left, right);\n    if (IsObject(left))\n        return ObjectType(left, right);\n    if (IsValueType(left))\n        return ValueType(left, right);\n    throw new Error('ValueEquals: Unable to compare value');\n}\n"],"names":[],"mappings":";;;;AAAA;;AACA,qEAAqE;AACrE,kBAAkB;AAClB,qEAAqE;AACrE,SAAS,WAAW,IAAI,EAAE,KAAK;IAC3B,IAAI,CAAC,IAAA,+LAAQ,EAAC,QACV,OAAO;IACX,MAAM,WAAW;WAAI,OAAO,IAAI,CAAC;WAAU,OAAO,qBAAqB,CAAC;KAAM;IAC9E,MAAM,YAAY;WAAI,OAAO,IAAI,CAAC;WAAW,OAAO,qBAAqB,CAAC;KAAO;IACjF,IAAI,SAAS,MAAM,KAAK,UAAU,MAAM,EACpC,OAAO;IACX,OAAO,SAAS,KAAK,CAAC,CAAC,MAAQ,MAAM,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI;AAC9D;AACA,SAAS,SAAS,IAAI,EAAE,KAAK;IACzB,OAAO,IAAA,6LAAM,EAAC,UAAU,KAAK,OAAO,OAAO,MAAM,OAAO;AAC5D;AACA,SAAS,UAAU,IAAI,EAAE,KAAK;IAC1B,IAAI,CAAC,IAAA,8LAAO,EAAC,UAAU,KAAK,MAAM,KAAK,MAAM,MAAM,EAC/C,OAAO;IACX,OAAO,KAAK,KAAK,CAAC,CAAC,OAAO,QAAU,MAAM,OAAO,KAAK,CAAC,MAAM;AACjE;AACA,SAAS,eAAe,IAAI,EAAE,KAAK;IAC/B,IAAI,CAAC,IAAA,mMAAY,EAAC,UAAU,KAAK,MAAM,KAAK,MAAM,MAAM,IAAI,OAAO,cAAc,CAAC,MAAM,WAAW,CAAC,IAAI,KAAK,OAAO,cAAc,CAAC,OAAO,WAAW,CAAC,IAAI,EACtJ,OAAO;IACX,OAAO,KAAK,KAAK,CAAC,CAAC,OAAO,QAAU,MAAM,OAAO,KAAK,CAAC,MAAM;AACjE;AACA,SAAS,UAAU,IAAI,EAAE,KAAK;IAC1B,OAAO,SAAS;AACpB;AAKO,SAAS,MAAM,IAAI,EAAE,KAAK;IAC7B,IAAI,IAAA,6LAAM,EAAC,OACP,OAAO,SAAS,MAAM;IAC1B,IAAI,IAAA,mMAAY,EAAC,OACb,OAAO,eAAe,MAAM;IAChC,IAAI,IAAA,8LAAO,EAAC,OACR,OAAO,UAAU,MAAM;IAC3B,IAAI,IAAA,+LAAQ,EAAC,OACT,OAAO,WAAW,MAAM;IAC5B,IAAI,IAAA,kMAAW,EAAC,OACZ,OAAO,UAAU,MAAM;IAC3B,MAAM,IAAI,MAAM;AACpB","ignoreList":[0]}},
    {"offset": {"line": 9535, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/delta/delta.mjs"],"sourcesContent":["import { HasPropertyKey, IsStandardObject, IsArray, IsTypedArray, IsValueType } from '../guard/index.mjs';\nimport { ValuePointer } from '../pointer/index.mjs';\nimport { Clone } from '../clone/index.mjs';\nimport { Equal } from '../equal/equal.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\nimport { Literal } from '../../type/literal/index.mjs';\nimport { Object } from '../../type/object/index.mjs';\nimport { String } from '../../type/string/index.mjs';\nimport { Unknown } from '../../type/unknown/index.mjs';\nimport { Union } from '../../type/union/index.mjs';\nexport const Insert = Object({\n    type: Literal('insert'),\n    path: String(),\n    value: Unknown(),\n});\nexport const Update = Object({\n    type: Literal('update'),\n    path: String(),\n    value: Unknown(),\n});\nexport const Delete = Object({\n    type: Literal('delete'),\n    path: String(),\n});\nexport const Edit = Union([Insert, Update, Delete]);\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValueDiffError extends TypeBoxError {\n    constructor(value, message) {\n        super(message);\n        this.value = value;\n    }\n}\n// ------------------------------------------------------------------\n// Command Factory\n// ------------------------------------------------------------------\nfunction CreateUpdate(path, value) {\n    return { type: 'update', path, value };\n}\nfunction CreateInsert(path, value) {\n    return { type: 'insert', path, value };\n}\nfunction CreateDelete(path) {\n    return { type: 'delete', path };\n}\n// ------------------------------------------------------------------\n// AssertDiffable\n// ------------------------------------------------------------------\nfunction AssertDiffable(value) {\n    if (globalThis.Object.getOwnPropertySymbols(value).length > 0)\n        throw new ValueDiffError(value, 'Cannot diff objects with symbols');\n}\n// ------------------------------------------------------------------\n// Diffing Generators\n// ------------------------------------------------------------------\nfunction* ObjectType(path, current, next) {\n    AssertDiffable(current);\n    AssertDiffable(next);\n    if (!IsStandardObject(next))\n        return yield CreateUpdate(path, next);\n    const currentKeys = globalThis.Object.getOwnPropertyNames(current);\n    const nextKeys = globalThis.Object.getOwnPropertyNames(next);\n    // ----------------------------------------------------------------\n    // inserts\n    // ----------------------------------------------------------------\n    for (const key of nextKeys) {\n        if (HasPropertyKey(current, key))\n            continue;\n        yield CreateInsert(`${path}/${key}`, next[key]);\n    }\n    // ----------------------------------------------------------------\n    // updates\n    // ----------------------------------------------------------------\n    for (const key of currentKeys) {\n        if (!HasPropertyKey(next, key))\n            continue;\n        if (Equal(current, next))\n            continue;\n        yield* Visit(`${path}/${key}`, current[key], next[key]);\n    }\n    // ----------------------------------------------------------------\n    // deletes\n    // ----------------------------------------------------------------\n    for (const key of currentKeys) {\n        if (HasPropertyKey(next, key))\n            continue;\n        yield CreateDelete(`${path}/${key}`);\n    }\n}\nfunction* ArrayType(path, current, next) {\n    if (!IsArray(next))\n        return yield CreateUpdate(path, next);\n    for (let i = 0; i < Math.min(current.length, next.length); i++) {\n        yield* Visit(`${path}/${i}`, current[i], next[i]);\n    }\n    for (let i = 0; i < next.length; i++) {\n        if (i < current.length)\n            continue;\n        yield CreateInsert(`${path}/${i}`, next[i]);\n    }\n    for (let i = current.length - 1; i >= 0; i--) {\n        if (i < next.length)\n            continue;\n        yield CreateDelete(`${path}/${i}`);\n    }\n}\nfunction* TypedArrayType(path, current, next) {\n    if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)\n        return yield CreateUpdate(path, next);\n    for (let i = 0; i < Math.min(current.length, next.length); i++) {\n        yield* Visit(`${path}/${i}`, current[i], next[i]);\n    }\n}\nfunction* ValueType(path, current, next) {\n    if (current === next)\n        return;\n    yield CreateUpdate(path, next);\n}\nfunction* Visit(path, current, next) {\n    if (IsStandardObject(current))\n        return yield* ObjectType(path, current, next);\n    if (IsArray(current))\n        return yield* ArrayType(path, current, next);\n    if (IsTypedArray(current))\n        return yield* TypedArrayType(path, current, next);\n    if (IsValueType(current))\n        return yield* ValueType(path, current, next);\n    throw new ValueDiffError(current, 'Unable to diff value');\n}\n// ------------------------------------------------------------------\n// Diff\n// ------------------------------------------------------------------\nexport function Diff(current, next) {\n    return [...Visit('', current, next)];\n}\n// ------------------------------------------------------------------\n// Patch\n// ------------------------------------------------------------------\nfunction IsRootUpdate(edits) {\n    return edits.length > 0 && edits[0].path === '' && edits[0].type === 'update';\n}\nfunction IsIdentity(edits) {\n    return edits.length === 0;\n}\nexport function Patch(current, edits) {\n    if (IsRootUpdate(edits)) {\n        return Clone(edits[0].value);\n    }\n    if (IsIdentity(edits)) {\n        return Clone(current);\n    }\n    const clone = Clone(current);\n    for (const edit of edits) {\n        switch (edit.type) {\n            case 'insert': {\n                ValuePointer.Set(clone, edit.path, edit.value);\n                break;\n            }\n            case 'update': {\n                ValuePointer.Set(clone, edit.path, edit.value);\n                break;\n            }\n            case 'delete': {\n                ValuePointer.Delete(clone, edit.path);\n                break;\n            }\n        }\n    }\n    return clone;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9735, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/transform/encode.mjs"],"sourcesContent":["import { TypeSystemPolicy } from '../../system/policy.mjs';\nimport { Kind, TransformKind } from '../../type/symbols/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\nimport { KeyOfPropertyKeys, KeyOfPropertyEntries } from '../../type/keyof/index.mjs';\nimport { Deref, Pushref } from '../deref/index.mjs';\nimport { Check } from '../check/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { HasPropertyKey, IsObject, IsArray, IsValueType, IsUndefined as IsUndefinedValue } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// KindGuard\n// ------------------------------------------------------------------\nimport { IsTransform, IsSchema, IsUndefined } from '../../type/guard/kind.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\n// prettier-ignore\nexport class TransformEncodeCheckError extends TypeBoxError {\n    constructor(schema, value, error) {\n        super(`The encoded value does not match the expected schema`);\n        this.schema = schema;\n        this.value = value;\n        this.error = error;\n    }\n}\n// prettier-ignore\nexport class TransformEncodeError extends TypeBoxError {\n    constructor(schema, path, value, error) {\n        super(`${error instanceof Error ? error.message : 'Unknown error'}`);\n        this.schema = schema;\n        this.path = path;\n        this.value = value;\n        this.error = error;\n    }\n}\n// ------------------------------------------------------------------\n// Encode\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction Default(schema, path, value) {\n    try {\n        return IsTransform(schema) ? schema[TransformKind].Encode(value) : value;\n    }\n    catch (error) {\n        throw new TransformEncodeError(schema, path, value, error);\n    }\n}\n// prettier-ignore\nfunction FromArray(schema, references, path, value) {\n    const defaulted = Default(schema, path, value);\n    return IsArray(defaulted)\n        ? defaulted.map((value, index) => Visit(schema.items, references, `${path}/${index}`, value))\n        : defaulted;\n}\n// prettier-ignore\nfunction FromImport(schema, references, path, value) {\n    const additional = globalThis.Object.values(schema.$defs);\n    const target = schema.$defs[schema.$ref];\n    const result = Default(schema, path, value);\n    return Visit(target, [...references, ...additional], path, result);\n}\n// prettier-ignore\nfunction FromIntersect(schema, references, path, value) {\n    const defaulted = Default(schema, path, value);\n    if (!IsObject(value) || IsValueType(value))\n        return defaulted;\n    const knownEntries = KeyOfPropertyEntries(schema);\n    const knownKeys = knownEntries.map(entry => entry[0]);\n    const knownProperties = { ...defaulted };\n    for (const [knownKey, knownSchema] of knownEntries)\n        if (knownKey in knownProperties) {\n            knownProperties[knownKey] = Visit(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);\n        }\n    if (!IsTransform(schema.unevaluatedProperties)) {\n        return knownProperties;\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const unevaluatedProperties = schema.unevaluatedProperties;\n    const properties = { ...knownProperties };\n    for (const key of unknownKeys)\n        if (!knownKeys.includes(key)) {\n            properties[key] = Default(unevaluatedProperties, `${path}/${key}`, properties[key]);\n        }\n    return properties;\n}\n// prettier-ignore\nfunction FromNot(schema, references, path, value) {\n    return Default(schema.not, path, Default(schema, path, value));\n}\n// prettier-ignore\nfunction FromObject(schema, references, path, value) {\n    const defaulted = Default(schema, path, value);\n    if (!IsObject(defaulted))\n        return defaulted;\n    const knownKeys = KeyOfPropertyKeys(schema);\n    const knownProperties = { ...defaulted };\n    for (const key of knownKeys) {\n        if (!HasPropertyKey(knownProperties, key))\n            continue;\n        // if the property value is undefined, but the target is not, nor does it satisfy exact optional \n        // property policy, then we need to continue. This is a special case for optional property handling \n        // where a transforms wrapped in a optional modifiers should not run.\n        if (IsUndefinedValue(knownProperties[key]) && (!IsUndefined(schema.properties[key]) ||\n            TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))\n            continue;\n        // encode property\n        knownProperties[key] = Visit(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);\n    }\n    if (!IsSchema(schema.additionalProperties)) {\n        return knownProperties;\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const additionalProperties = schema.additionalProperties;\n    const properties = { ...knownProperties };\n    for (const key of unknownKeys)\n        if (!knownKeys.includes(key)) {\n            properties[key] = Default(additionalProperties, `${path}/${key}`, properties[key]);\n        }\n    return properties;\n}\n// prettier-ignore\nfunction FromRecord(schema, references, path, value) {\n    const defaulted = Default(schema, path, value);\n    if (!IsObject(value))\n        return defaulted;\n    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n    const knownKeys = new RegExp(pattern);\n    const knownProperties = { ...defaulted };\n    for (const key of Object.getOwnPropertyNames(value))\n        if (knownKeys.test(key)) {\n            knownProperties[key] = Visit(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);\n        }\n    if (!IsSchema(schema.additionalProperties)) {\n        return knownProperties;\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const additionalProperties = schema.additionalProperties;\n    const properties = { ...knownProperties };\n    for (const key of unknownKeys)\n        if (!knownKeys.test(key)) {\n            properties[key] = Default(additionalProperties, `${path}/${key}`, properties[key]);\n        }\n    return properties;\n}\n// prettier-ignore\nfunction FromRef(schema, references, path, value) {\n    const target = Deref(schema, references);\n    const resolved = Visit(target, references, path, value);\n    return Default(schema, path, resolved);\n}\n// prettier-ignore\nfunction FromThis(schema, references, path, value) {\n    const target = Deref(schema, references);\n    const resolved = Visit(target, references, path, value);\n    return Default(schema, path, resolved);\n}\n// prettier-ignore\nfunction FromTuple(schema, references, path, value) {\n    const value1 = Default(schema, path, value);\n    return IsArray(schema.items) ? schema.items.map((schema, index) => Visit(schema, references, `${path}/${index}`, value1[index])) : [];\n}\n// prettier-ignore\nfunction FromUnion(schema, references, path, value) {\n    // test value against union variants\n    for (const subschema of schema.anyOf) {\n        if (!Check(subschema, references, value))\n            continue;\n        const value1 = Visit(subschema, references, path, value);\n        return Default(schema, path, value1);\n    }\n    // test transformed value against union variants\n    for (const subschema of schema.anyOf) {\n        const value1 = Visit(subschema, references, path, value);\n        if (!Check(schema, references, value1))\n            continue;\n        return Default(schema, path, value1);\n    }\n    return Default(schema, path, value);\n}\n// prettier-ignore\nfunction Visit(schema, references, path, value) {\n    const references_ = Pushref(schema, references);\n    const schema_ = schema;\n    switch (schema[Kind]) {\n        case 'Array':\n            return FromArray(schema_, references_, path, value);\n        case 'Import':\n            return FromImport(schema_, references_, path, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, path, value);\n        case 'Not':\n            return FromNot(schema_, references_, path, value);\n        case 'Object':\n            return FromObject(schema_, references_, path, value);\n        case 'Record':\n            return FromRecord(schema_, references_, path, value);\n        case 'Ref':\n            return FromRef(schema_, references_, path, value);\n        case 'This':\n            return FromThis(schema_, references_, path, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, path, value);\n        case 'Union':\n            return FromUnion(schema_, references_, path, value);\n        default:\n            return Default(schema_, path, value);\n    }\n}\n/**\n * `[Internal]` Encodes the value and returns the result. This function expects the\n * caller to pass a statically checked value. This function does not check the encoded\n * result, meaning the result should be passed to `Check` before use. Refer to the\n * `Value.Encode()` function for implementation details.\n */\nexport function TransformEncode(schema, references, value) {\n    return Visit(schema, references, '', value);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9962, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/encode/encode.mjs"],"sourcesContent":["import { HasTransform, TransformEncode, TransformEncodeCheckError } from '../transform/index.mjs';\nimport { Check } from '../check/index.mjs';\nimport { Errors } from '../../errors/index.mjs';\n/** Encodes a value or throws if error */\nexport function Encode(...args) {\n    const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];\n    const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value) : value;\n    if (!Check(schema, references, encoded))\n        throw new TransformEncodeCheckError(schema, encoded, Errors(schema, references, encoded).First());\n    return encoded;\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AACA;;;;AAEO,SAAS,OAAO,GAAG,IAAI;IAC1B,MAAM,CAAC,QAAQ,YAAY,MAAM,GAAG,KAAK,MAAM,KAAK,IAAI;QAAC,IAAI,CAAC,EAAE;QAAE,IAAI,CAAC,EAAE;QAAE,IAAI,CAAC,EAAE;KAAC,GAAG;QAAC,IAAI,CAAC,EAAE;QAAE,EAAE;QAAE,IAAI,CAAC,EAAE;KAAC;IAC5G,MAAM,UAAU,IAAA,qMAAY,EAAC,QAAQ,cAAc,IAAA,2MAAe,EAAC,QAAQ,YAAY,SAAS;IAChG,IAAI,CAAC,IAAA,4LAAK,EAAC,QAAQ,YAAY,UAC3B,MAAM,IAAI,qNAAyB,CAAC,QAAQ,SAAS,IAAA,sLAAM,EAAC,QAAQ,YAAY,SAAS,KAAK;IAClG,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 9991, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/mutate/mutate.mjs"],"sourcesContent":["import { IsObject, IsArray, IsTypedArray, IsValueType } from '../guard/index.mjs';\nimport { ValuePointer } from '../pointer/index.mjs';\nimport { Clone } from '../clone/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\n// ------------------------------------------------------------------\n// IsStandardObject\n// ------------------------------------------------------------------\nfunction IsStandardObject(value) {\n    return IsObject(value) && !IsArray(value);\n}\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class ValueMutateError extends TypeBoxError {\n    constructor(message) {\n        super(message);\n    }\n}\nfunction ObjectType(root, path, current, next) {\n    if (!IsStandardObject(current)) {\n        ValuePointer.Set(root, path, Clone(next));\n    }\n    else {\n        const currentKeys = Object.getOwnPropertyNames(current);\n        const nextKeys = Object.getOwnPropertyNames(next);\n        for (const currentKey of currentKeys) {\n            if (!nextKeys.includes(currentKey)) {\n                delete current[currentKey];\n            }\n        }\n        for (const nextKey of nextKeys) {\n            if (!currentKeys.includes(nextKey)) {\n                current[nextKey] = null;\n            }\n        }\n        for (const nextKey of nextKeys) {\n            Visit(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);\n        }\n    }\n}\nfunction ArrayType(root, path, current, next) {\n    if (!IsArray(current)) {\n        ValuePointer.Set(root, path, Clone(next));\n    }\n    else {\n        for (let index = 0; index < next.length; index++) {\n            Visit(root, `${path}/${index}`, current[index], next[index]);\n        }\n        current.splice(next.length);\n    }\n}\nfunction TypedArrayType(root, path, current, next) {\n    if (IsTypedArray(current) && current.length === next.length) {\n        for (let i = 0; i < current.length; i++) {\n            current[i] = next[i];\n        }\n    }\n    else {\n        ValuePointer.Set(root, path, Clone(next));\n    }\n}\nfunction ValueType(root, path, current, next) {\n    if (current === next)\n        return;\n    ValuePointer.Set(root, path, next);\n}\nfunction Visit(root, path, current, next) {\n    if (IsArray(next))\n        return ArrayType(root, path, current, next);\n    if (IsTypedArray(next))\n        return TypedArrayType(root, path, current, next);\n    if (IsStandardObject(next))\n        return ObjectType(root, path, current, next);\n    if (IsValueType(next))\n        return ValueType(root, path, current, next);\n}\n// ------------------------------------------------------------------\n// IsNonMutableValue\n// ------------------------------------------------------------------\nfunction IsNonMutableValue(value) {\n    return IsTypedArray(value) || IsValueType(value);\n}\nfunction IsMismatchedValue(current, next) {\n    // prettier-ignore\n    return ((IsStandardObject(current) && IsArray(next)) ||\n        (IsArray(current) && IsStandardObject(next)));\n}\n// ------------------------------------------------------------------\n// Mutate\n// ------------------------------------------------------------------\n/** `[Mutable]` Performs a deep mutable value assignment while retaining internal references */\nexport function Mutate(current, next) {\n    if (IsNonMutableValue(current) || IsNonMutableValue(next))\n        throw new ValueMutateError('Only object and array types can be mutated at the root level');\n    if (IsMismatchedValue(current, next))\n        throw new ValueMutateError('Cannot assign due type mismatch of assignable values');\n    Visit(current, '', current, next);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10085, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/value/parse/parse.mjs"],"sourcesContent":["import { TypeBoxError } from '../../type/error/index.mjs';\nimport { TransformDecode, TransformEncode, HasTransform } from '../transform/index.mjs';\nimport { Assert } from '../assert/index.mjs';\nimport { Cast } from '../cast/index.mjs';\nimport { Clean } from '../clean/index.mjs';\nimport { Clone } from '../clone/index.mjs';\nimport { Convert } from '../convert/index.mjs';\nimport { Default } from '../default/index.mjs';\n// ------------------------------------------------------------------\n// Guards\n// ------------------------------------------------------------------\nimport { IsArray, IsUndefined } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// Error\n// ------------------------------------------------------------------\nexport class ParseError extends TypeBoxError {\n    constructor(message) {\n        super(message);\n    }\n}\n// prettier-ignore\nexport var ParseRegistry;\n(function (ParseRegistry) {\n    const registry = new Map([\n        ['Assert', (type, references, value) => { Assert(type, references, value); return value; }],\n        ['Cast', (type, references, value) => Cast(type, references, value)],\n        ['Clean', (type, references, value) => Clean(type, references, value)],\n        ['Clone', (_type, _references, value) => Clone(value)],\n        ['Convert', (type, references, value) => Convert(type, references, value)],\n        ['Decode', (type, references, value) => (HasTransform(type, references) ? TransformDecode(type, references, value) : value)],\n        ['Default', (type, references, value) => Default(type, references, value)],\n        ['Encode', (type, references, value) => (HasTransform(type, references) ? TransformEncode(type, references, value) : value)],\n    ]);\n    // Deletes an entry from the registry\n    function Delete(key) {\n        registry.delete(key);\n    }\n    ParseRegistry.Delete = Delete;\n    // Sets an entry in the registry\n    function Set(key, callback) {\n        registry.set(key, callback);\n    }\n    ParseRegistry.Set = Set;\n    // Gets an entry in the registry\n    function Get(key) {\n        return registry.get(key);\n    }\n    ParseRegistry.Get = Get;\n})(ParseRegistry || (ParseRegistry = {}));\n// ------------------------------------------------------------------\n// Default Parse Pipeline\n// ------------------------------------------------------------------\n// prettier-ignore\nexport const ParseDefault = [\n    'Clone',\n    'Clean',\n    'Default',\n    'Convert',\n    'Assert',\n    'Decode'\n];\n// ------------------------------------------------------------------\n// ParseValue\n// ------------------------------------------------------------------\nfunction ParseValue(operations, type, references, value) {\n    return operations.reduce((value, operationKey) => {\n        const operation = ParseRegistry.Get(operationKey);\n        if (IsUndefined(operation))\n            throw new ParseError(`Unable to find Parse operation '${operationKey}'`);\n        return operation(type, references, value);\n    }, value);\n}\n/** Parses a value */\nexport function Parse(...args) {\n    // prettier-ignore\n    const [operations, schema, references, value] = (args.length === 4 ? [args[0], args[1], args[2], args[3]] :\n        args.length === 3 ? IsArray(args[0]) ? [args[0], args[1], [], args[2]] : [ParseDefault, args[0], args[1], args[2]] :\n            args.length === 2 ? [ParseDefault, args[0], [], args[1]] :\n                (() => { throw new ParseError('Invalid Arguments'); })());\n    return ParseValue(operations, schema, references, value);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10297, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/compiler/compiler.mjs"],"sourcesContent":["import { TransformEncode, TransformDecode, HasTransform, TransformDecodeCheckError, TransformEncodeCheckError } from '../value/transform/index.mjs';\nimport { Errors } from '../errors/index.mjs';\nimport { TypeSystemPolicy } from '../system/index.mjs';\nimport { TypeBoxError } from '../type/error/index.mjs';\nimport { Deref } from '../value/deref/index.mjs';\nimport { Hash } from '../value/hash/index.mjs';\nimport { Kind } from '../type/symbols/index.mjs';\nimport { TypeRegistry, FormatRegistry } from '../type/registry/index.mjs';\nimport { KeyOfPattern } from '../type/keyof/index.mjs';\nimport { ExtendsUndefinedCheck } from '../type/extends/extends-undefined.mjs';\nimport { Never } from '../type/never/index.mjs';\nimport { Ref } from '../type/ref/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsString, IsNumber, IsBigInt } from '../value/guard/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsSchema } from '../type/guard/type.mjs';\n// ------------------------------------------------------------------\n// TypeCheck\n// ------------------------------------------------------------------\nexport class TypeCheck {\n    constructor(schema, references, checkFunc, code) {\n        this.schema = schema;\n        this.references = references;\n        this.checkFunc = checkFunc;\n        this.code = code;\n        this.hasTransform = HasTransform(schema, references);\n    }\n    /** Returns the generated assertion code used to validate this type. */\n    Code() {\n        return this.code;\n    }\n    /** Returns the schema type used to validate */\n    Schema() {\n        return this.schema;\n    }\n    /** Returns reference types used to validate */\n    References() {\n        return this.references;\n    }\n    /** Returns an iterator for each error in this value. */\n    Errors(value) {\n        return Errors(this.schema, this.references, value);\n    }\n    /** Returns true if the value matches the compiled type. */\n    Check(value) {\n        return this.checkFunc(value);\n    }\n    /** Decodes a value or throws if error */\n    Decode(value) {\n        if (!this.checkFunc(value))\n            throw new TransformDecodeCheckError(this.schema, value, this.Errors(value).First());\n        return (this.hasTransform ? TransformDecode(this.schema, this.references, value) : value);\n    }\n    /** Encodes a value or throws if error */\n    Encode(value) {\n        const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value) : value;\n        if (!this.checkFunc(encoded))\n            throw new TransformEncodeCheckError(this.schema, value, this.Errors(value).First());\n        return encoded;\n    }\n}\n// ------------------------------------------------------------------\n// Character\n// ------------------------------------------------------------------\nvar Character;\n(function (Character) {\n    function DollarSign(code) {\n        return code === 36;\n    }\n    Character.DollarSign = DollarSign;\n    function IsUnderscore(code) {\n        return code === 95;\n    }\n    Character.IsUnderscore = IsUnderscore;\n    function IsAlpha(code) {\n        return (code >= 65 && code <= 90) || (code >= 97 && code <= 122);\n    }\n    Character.IsAlpha = IsAlpha;\n    function IsNumeric(code) {\n        return code >= 48 && code <= 57;\n    }\n    Character.IsNumeric = IsNumeric;\n})(Character || (Character = {}));\n// ------------------------------------------------------------------\n// MemberExpression\n// ------------------------------------------------------------------\nvar MemberExpression;\n(function (MemberExpression) {\n    function IsFirstCharacterNumeric(value) {\n        if (value.length === 0)\n            return false;\n        return Character.IsNumeric(value.charCodeAt(0));\n    }\n    function IsAccessor(value) {\n        if (IsFirstCharacterNumeric(value))\n            return false;\n        for (let i = 0; i < value.length; i++) {\n            const code = value.charCodeAt(i);\n            const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);\n            if (!check)\n                return false;\n        }\n        return true;\n    }\n    function EscapeHyphen(key) {\n        return key.replace(/'/g, \"\\\\'\");\n    }\n    function Encode(object, key) {\n        return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;\n    }\n    MemberExpression.Encode = Encode;\n})(MemberExpression || (MemberExpression = {}));\n// ------------------------------------------------------------------\n// Identifier\n// ------------------------------------------------------------------\nvar Identifier;\n(function (Identifier) {\n    function Encode($id) {\n        const buffer = [];\n        for (let i = 0; i < $id.length; i++) {\n            const code = $id.charCodeAt(i);\n            if (Character.IsNumeric(code) || Character.IsAlpha(code)) {\n                buffer.push($id.charAt(i));\n            }\n            else {\n                buffer.push(`_${code}_`);\n            }\n        }\n        return buffer.join('').replace(/__/g, '_');\n    }\n    Identifier.Encode = Encode;\n})(Identifier || (Identifier = {}));\n// ------------------------------------------------------------------\n// LiteralString\n// ------------------------------------------------------------------\nvar LiteralString;\n(function (LiteralString) {\n    function Escape(content) {\n        return content.replace(/'/g, \"\\\\'\");\n    }\n    LiteralString.Escape = Escape;\n})(LiteralString || (LiteralString = {}));\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class TypeCompilerUnknownTypeError extends TypeBoxError {\n    constructor(schema) {\n        super('Unknown type');\n        this.schema = schema;\n    }\n}\nexport class TypeCompilerTypeGuardError extends TypeBoxError {\n    constructor(schema) {\n        super('Preflight validation check failed to guard for the given schema');\n        this.schema = schema;\n    }\n}\n// ------------------------------------------------------------------\n// Policy\n// ------------------------------------------------------------------\nexport var Policy;\n(function (Policy) {\n    function IsExactOptionalProperty(value, key, expression) {\n        return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;\n    }\n    Policy.IsExactOptionalProperty = IsExactOptionalProperty;\n    function IsObjectLike(value) {\n        return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;\n    }\n    Policy.IsObjectLike = IsObjectLike;\n    function IsRecordLike(value) {\n        return !TypeSystemPolicy.AllowArrayObject\n            ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`\n            : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;\n    }\n    Policy.IsRecordLike = IsRecordLike;\n    function IsNumberLike(value) {\n        return TypeSystemPolicy.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;\n    }\n    Policy.IsNumberLike = IsNumberLike;\n    function IsVoidLike(value) {\n        return TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;\n    }\n    Policy.IsVoidLike = IsVoidLike;\n})(Policy || (Policy = {}));\n/** Compiles Types for Runtime Type Checking */\nexport var TypeCompiler;\n(function (TypeCompiler) {\n    // ----------------------------------------------------------------\n    // Guards\n    // ----------------------------------------------------------------\n    function IsAnyOrUnknown(schema) {\n        return schema[Kind] === 'Any' || schema[Kind] === 'Unknown';\n    }\n    // ----------------------------------------------------------------\n    // Types\n    // ----------------------------------------------------------------\n    function* FromAny(schema, references, value) {\n        yield 'true';\n    }\n    function* FromArgument(schema, references, value) {\n        yield 'true';\n    }\n    function* FromArray(schema, references, value) {\n        yield `Array.isArray(${value})`;\n        const [parameter, accumulator] = [CreateParameter('value', 'any'), CreateParameter('acc', 'number')];\n        if (IsNumber(schema.maxItems))\n            yield `${value}.length <= ${schema.maxItems}`;\n        if (IsNumber(schema.minItems))\n            yield `${value}.length >= ${schema.minItems}`;\n        const elementExpression = CreateExpression(schema.items, references, 'value');\n        yield `${value}.every((${parameter}) => ${elementExpression})`;\n        if (IsSchema(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains)) {\n            const containsSchema = IsSchema(schema.contains) ? schema.contains : Never();\n            const checkExpression = CreateExpression(containsSchema, references, 'value');\n            const checkMinContains = IsNumber(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];\n            const checkMaxContains = IsNumber(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];\n            const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;\n            const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(' && ');\n            yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;\n        }\n        if (schema.uniqueItems === true) {\n            const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;\n            const block = `const set = new Set(); for(const element of value) { ${check} }`;\n            yield `((${parameter}) => { ${block} )(${value})`;\n        }\n    }\n    function* FromAsyncIterator(schema, references, value) {\n        yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;\n    }\n    function* FromBigInt(schema, references, value) {\n        yield `(typeof ${value} === 'bigint')`;\n        if (IsBigInt(schema.exclusiveMaximum))\n            yield `${value} < BigInt(${schema.exclusiveMaximum})`;\n        if (IsBigInt(schema.exclusiveMinimum))\n            yield `${value} > BigInt(${schema.exclusiveMinimum})`;\n        if (IsBigInt(schema.maximum))\n            yield `${value} <= BigInt(${schema.maximum})`;\n        if (IsBigInt(schema.minimum))\n            yield `${value} >= BigInt(${schema.minimum})`;\n        if (IsBigInt(schema.multipleOf))\n            yield `(${value} % BigInt(${schema.multipleOf})) === 0`;\n    }\n    function* FromBoolean(schema, references, value) {\n        yield `(typeof ${value} === 'boolean')`;\n    }\n    function* FromConstructor(schema, references, value) {\n        yield* Visit(schema.returns, references, `${value}.prototype`);\n    }\n    function* FromDate(schema, references, value) {\n        yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;\n        if (IsNumber(schema.exclusiveMaximumTimestamp))\n            yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;\n        if (IsNumber(schema.exclusiveMinimumTimestamp))\n            yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;\n        if (IsNumber(schema.maximumTimestamp))\n            yield `${value}.getTime() <= ${schema.maximumTimestamp}`;\n        if (IsNumber(schema.minimumTimestamp))\n            yield `${value}.getTime() >= ${schema.minimumTimestamp}`;\n        if (IsNumber(schema.multipleOfTimestamp))\n            yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;\n    }\n    function* FromFunction(schema, references, value) {\n        yield `(typeof ${value} === 'function')`;\n    }\n    function* FromImport(schema, references, value) {\n        const members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => {\n            return [...result, schema.$defs[key]];\n        }, []);\n        yield* Visit(Ref(schema.$ref), [...references, ...members], value);\n    }\n    function* FromInteger(schema, references, value) {\n        yield `Number.isInteger(${value})`;\n        if (IsNumber(schema.exclusiveMaximum))\n            yield `${value} < ${schema.exclusiveMaximum}`;\n        if (IsNumber(schema.exclusiveMinimum))\n            yield `${value} > ${schema.exclusiveMinimum}`;\n        if (IsNumber(schema.maximum))\n            yield `${value} <= ${schema.maximum}`;\n        if (IsNumber(schema.minimum))\n            yield `${value} >= ${schema.minimum}`;\n        if (IsNumber(schema.multipleOf))\n            yield `(${value} % ${schema.multipleOf}) === 0`;\n    }\n    function* FromIntersect(schema, references, value) {\n        const check1 = schema.allOf.map((schema) => CreateExpression(schema, references, value)).join(' && ');\n        if (schema.unevaluatedProperties === false) {\n            const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);\n            const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;\n            yield `(${check1} && ${check2})`;\n        }\n        else if (IsSchema(schema.unevaluatedProperties)) {\n            const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);\n            const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;\n            yield `(${check1} && ${check2})`;\n        }\n        else {\n            yield `(${check1})`;\n        }\n    }\n    function* FromIterator(schema, references, value) {\n        yield `(typeof value === 'object' && Symbol.iterator in ${value})`;\n    }\n    function* FromLiteral(schema, references, value) {\n        if (typeof schema.const === 'number' || typeof schema.const === 'boolean') {\n            yield `(${value} === ${schema.const})`;\n        }\n        else {\n            yield `(${value} === '${LiteralString.Escape(schema.const)}')`;\n        }\n    }\n    function* FromNever(schema, references, value) {\n        yield `false`;\n    }\n    function* FromNot(schema, references, value) {\n        const expression = CreateExpression(schema.not, references, value);\n        yield `(!${expression})`;\n    }\n    function* FromNull(schema, references, value) {\n        yield `(${value} === null)`;\n    }\n    function* FromNumber(schema, references, value) {\n        yield Policy.IsNumberLike(value);\n        if (IsNumber(schema.exclusiveMaximum))\n            yield `${value} < ${schema.exclusiveMaximum}`;\n        if (IsNumber(schema.exclusiveMinimum))\n            yield `${value} > ${schema.exclusiveMinimum}`;\n        if (IsNumber(schema.maximum))\n            yield `${value} <= ${schema.maximum}`;\n        if (IsNumber(schema.minimum))\n            yield `${value} >= ${schema.minimum}`;\n        if (IsNumber(schema.multipleOf))\n            yield `(${value} % ${schema.multipleOf}) === 0`;\n    }\n    function* FromObject(schema, references, value) {\n        yield Policy.IsObjectLike(value);\n        if (IsNumber(schema.minProperties))\n            yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;\n        if (IsNumber(schema.maxProperties))\n            yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;\n        const knownKeys = Object.getOwnPropertyNames(schema.properties);\n        for (const knownKey of knownKeys) {\n            const memberExpression = MemberExpression.Encode(value, knownKey);\n            const property = schema.properties[knownKey];\n            if (schema.required && schema.required.includes(knownKey)) {\n                yield* Visit(property, references, memberExpression);\n                if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property))\n                    yield `('${knownKey}' in ${value})`;\n            }\n            else {\n                const expression = CreateExpression(property, references, memberExpression);\n                yield Policy.IsExactOptionalProperty(value, knownKey, expression);\n            }\n        }\n        if (schema.additionalProperties === false) {\n            if (schema.required && schema.required.length === knownKeys.length) {\n                yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;\n            }\n            else {\n                const keys = `[${knownKeys.map((key) => `'${key}'`).join(', ')}]`;\n                yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;\n            }\n        }\n        if (typeof schema.additionalProperties === 'object') {\n            const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);\n            const keys = `[${knownKeys.map((key) => `'${key}'`).join(', ')}]`;\n            yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;\n        }\n    }\n    function* FromPromise(schema, references, value) {\n        yield `${value} instanceof Promise`;\n    }\n    function* FromRecord(schema, references, value) {\n        yield Policy.IsRecordLike(value);\n        if (IsNumber(schema.minProperties))\n            yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;\n        if (IsNumber(schema.maxProperties))\n            yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;\n        const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n        const variable = CreateVariable(`${new RegExp(patternKey)}`);\n        const check1 = CreateExpression(patternSchema, references, 'value');\n        const check2 = IsSchema(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? 'false' : 'true';\n        const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;\n        yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;\n    }\n    function* FromRef(schema, references, value) {\n        const target = Deref(schema, references);\n        // Reference: If we have seen this reference before we can just yield and return the function call.\n        // If this isn't the case we defer to visit to generate and set the function for subsequent passes.\n        if (state.functions.has(schema.$ref))\n            return yield `${CreateFunctionName(schema.$ref)}(${value})`;\n        yield* Visit(target, references, value);\n    }\n    function* FromRegExp(schema, references, value) {\n        const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);\n        yield `(typeof ${value} === 'string')`;\n        if (IsNumber(schema.maxLength))\n            yield `${value}.length <= ${schema.maxLength}`;\n        if (IsNumber(schema.minLength))\n            yield `${value}.length >= ${schema.minLength}`;\n        yield `${variable}.test(${value})`;\n    }\n    function* FromString(schema, references, value) {\n        yield `(typeof ${value} === 'string')`;\n        if (IsNumber(schema.maxLength))\n            yield `${value}.length <= ${schema.maxLength}`;\n        if (IsNumber(schema.minLength))\n            yield `${value}.length >= ${schema.minLength}`;\n        if (schema.pattern !== undefined) {\n            const variable = CreateVariable(`${new RegExp(schema.pattern)};`);\n            yield `${variable}.test(${value})`;\n        }\n        if (schema.format !== undefined) {\n            yield `format('${schema.format}', ${value})`;\n        }\n    }\n    function* FromSymbol(schema, references, value) {\n        yield `(typeof ${value} === 'symbol')`;\n    }\n    function* FromTemplateLiteral(schema, references, value) {\n        yield `(typeof ${value} === 'string')`;\n        const variable = CreateVariable(`${new RegExp(schema.pattern)};`);\n        yield `${variable}.test(${value})`;\n    }\n    function* FromThis(schema, references, value) {\n        // Note: This types are assured to be hoisted prior to this call. Just yield the function.\n        yield `${CreateFunctionName(schema.$ref)}(${value})`;\n    }\n    function* FromTuple(schema, references, value) {\n        yield `Array.isArray(${value})`;\n        if (schema.items === undefined)\n            return yield `${value}.length === 0`;\n        yield `(${value}.length === ${schema.maxItems})`;\n        for (let i = 0; i < schema.items.length; i++) {\n            const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);\n            yield `${expression}`;\n        }\n    }\n    function* FromUndefined(schema, references, value) {\n        yield `${value} === undefined`;\n    }\n    function* FromUnion(schema, references, value) {\n        const expressions = schema.anyOf.map((schema) => CreateExpression(schema, references, value));\n        yield `(${expressions.join(' || ')})`;\n    }\n    function* FromUint8Array(schema, references, value) {\n        yield `${value} instanceof Uint8Array`;\n        if (IsNumber(schema.maxByteLength))\n            yield `(${value}.length <= ${schema.maxByteLength})`;\n        if (IsNumber(schema.minByteLength))\n            yield `(${value}.length >= ${schema.minByteLength})`;\n    }\n    function* FromUnknown(schema, references, value) {\n        yield 'true';\n    }\n    function* FromVoid(schema, references, value) {\n        yield Policy.IsVoidLike(value);\n    }\n    function* FromKind(schema, references, value) {\n        const instance = state.instances.size;\n        state.instances.set(instance, schema);\n        yield `kind('${schema[Kind]}', ${instance}, ${value})`;\n    }\n    function* Visit(schema, references, value, useHoisting = true) {\n        const references_ = IsString(schema.$id) ? [...references, schema] : references;\n        const schema_ = schema;\n        // --------------------------------------------------------------\n        // Hoisting\n        // --------------------------------------------------------------\n        if (useHoisting && IsString(schema.$id)) {\n            const functionName = CreateFunctionName(schema.$id);\n            if (state.functions.has(functionName)) {\n                return yield `${functionName}(${value})`;\n            }\n            else {\n                // Note: In the case of cyclic types, we need to create a 'functions' record\n                // to prevent infinitely re-visiting the CreateFunction. Subsequent attempts\n                // to visit will be caught by the above condition.\n                state.functions.set(functionName, '<deferred>');\n                const functionCode = CreateFunction(functionName, schema, references, 'value', false);\n                state.functions.set(functionName, functionCode);\n                return yield `${functionName}(${value})`;\n            }\n        }\n        switch (schema_[Kind]) {\n            case 'Any':\n                return yield* FromAny(schema_, references_, value);\n            case 'Argument':\n                return yield* FromArgument(schema_, references_, value);\n            case 'Array':\n                return yield* FromArray(schema_, references_, value);\n            case 'AsyncIterator':\n                return yield* FromAsyncIterator(schema_, references_, value);\n            case 'BigInt':\n                return yield* FromBigInt(schema_, references_, value);\n            case 'Boolean':\n                return yield* FromBoolean(schema_, references_, value);\n            case 'Constructor':\n                return yield* FromConstructor(schema_, references_, value);\n            case 'Date':\n                return yield* FromDate(schema_, references_, value);\n            case 'Function':\n                return yield* FromFunction(schema_, references_, value);\n            case 'Import':\n                return yield* FromImport(schema_, references_, value);\n            case 'Integer':\n                return yield* FromInteger(schema_, references_, value);\n            case 'Intersect':\n                return yield* FromIntersect(schema_, references_, value);\n            case 'Iterator':\n                return yield* FromIterator(schema_, references_, value);\n            case 'Literal':\n                return yield* FromLiteral(schema_, references_, value);\n            case 'Never':\n                return yield* FromNever(schema_, references_, value);\n            case 'Not':\n                return yield* FromNot(schema_, references_, value);\n            case 'Null':\n                return yield* FromNull(schema_, references_, value);\n            case 'Number':\n                return yield* FromNumber(schema_, references_, value);\n            case 'Object':\n                return yield* FromObject(schema_, references_, value);\n            case 'Promise':\n                return yield* FromPromise(schema_, references_, value);\n            case 'Record':\n                return yield* FromRecord(schema_, references_, value);\n            case 'Ref':\n                return yield* FromRef(schema_, references_, value);\n            case 'RegExp':\n                return yield* FromRegExp(schema_, references_, value);\n            case 'String':\n                return yield* FromString(schema_, references_, value);\n            case 'Symbol':\n                return yield* FromSymbol(schema_, references_, value);\n            case 'TemplateLiteral':\n                return yield* FromTemplateLiteral(schema_, references_, value);\n            case 'This':\n                return yield* FromThis(schema_, references_, value);\n            case 'Tuple':\n                return yield* FromTuple(schema_, references_, value);\n            case 'Undefined':\n                return yield* FromUndefined(schema_, references_, value);\n            case 'Union':\n                return yield* FromUnion(schema_, references_, value);\n            case 'Uint8Array':\n                return yield* FromUint8Array(schema_, references_, value);\n            case 'Unknown':\n                return yield* FromUnknown(schema_, references_, value);\n            case 'Void':\n                return yield* FromVoid(schema_, references_, value);\n            default:\n                if (!TypeRegistry.Has(schema_[Kind]))\n                    throw new TypeCompilerUnknownTypeError(schema);\n                return yield* FromKind(schema_, references_, value);\n        }\n    }\n    // ----------------------------------------------------------------\n    // Compiler State\n    // ----------------------------------------------------------------\n    // prettier-ignore\n    const state = {\n        language: 'javascript', // target language\n        functions: new Map(), // local functions\n        variables: new Map(), // local variables\n        instances: new Map() // exterior kind instances\n    };\n    // ----------------------------------------------------------------\n    // Compiler Factory\n    // ----------------------------------------------------------------\n    function CreateExpression(schema, references, value, useHoisting = true) {\n        return `(${[...Visit(schema, references, value, useHoisting)].join(' && ')})`;\n    }\n    function CreateFunctionName($id) {\n        return `check_${Identifier.Encode($id)}`;\n    }\n    function CreateVariable(expression) {\n        const variableName = `local_${state.variables.size}`;\n        state.variables.set(variableName, `const ${variableName} = ${expression}`);\n        return variableName;\n    }\n    function CreateFunction(name, schema, references, value, useHoisting = true) {\n        const [newline, pad] = ['\\n', (length) => ''.padStart(length, ' ')];\n        const parameter = CreateParameter('value', 'any');\n        const returns = CreateReturns('boolean');\n        const expression = [...Visit(schema, references, value, useHoisting)].map((expression) => `${pad(4)}${expression}`).join(` &&${newline}`);\n        return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\\n}`;\n    }\n    function CreateParameter(name, type) {\n        const annotation = state.language === 'typescript' ? `: ${type}` : '';\n        return `${name}${annotation}`;\n    }\n    function CreateReturns(type) {\n        return state.language === 'typescript' ? `: ${type}` : '';\n    }\n    // ----------------------------------------------------------------\n    // Compile\n    // ----------------------------------------------------------------\n    function Build(schema, references, options) {\n        const functionCode = CreateFunction('check', schema, references, 'value'); // will populate functions and variables\n        const parameter = CreateParameter('value', 'any');\n        const returns = CreateReturns('boolean');\n        const functions = [...state.functions.values()];\n        const variables = [...state.variables.values()];\n        // prettier-ignore\n        const checkFunction = IsString(schema.$id) // ensure top level schemas with $id's are hoisted\n            ? `return function check(${parameter})${returns} {\\n  return ${CreateFunctionName(schema.$id)}(value)\\n}`\n            : `return ${functionCode}`;\n        return [...variables, ...functions, checkFunction].join('\\n');\n    }\n    /** Generates the code used to assert this type and returns it as a string */\n    function Code(...args) {\n        const defaults = { language: 'javascript' };\n        // prettier-ignore\n        const [schema, references, options] = (args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] :\n            args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] :\n                args.length === 3 ? [args[0], args[1], args[2]] :\n                    args.length === 1 ? [args[0], [], defaults] :\n                        [null, [], defaults]);\n        // compiler-reset\n        state.language = options.language;\n        state.variables.clear();\n        state.functions.clear();\n        state.instances.clear();\n        if (!IsSchema(schema))\n            throw new TypeCompilerTypeGuardError(schema);\n        for (const schema of references)\n            if (!IsSchema(schema))\n                throw new TypeCompilerTypeGuardError(schema);\n        return Build(schema, references, options);\n    }\n    TypeCompiler.Code = Code;\n    /** Compiles a TypeBox type for optimal runtime type checking. Types must be valid TypeBox types of TSchema */\n    function Compile(schema, references = []) {\n        const generatedCode = Code(schema, references, { language: 'javascript' });\n        const compiledFunction = globalThis.Function('kind', 'format', 'hash', generatedCode);\n        const instances = new Map(state.instances);\n        function typeRegistryFunction(kind, instance, value) {\n            if (!TypeRegistry.Has(kind) || !instances.has(instance))\n                return false;\n            const checkFunc = TypeRegistry.Get(kind);\n            const schema = instances.get(instance);\n            return checkFunc(schema, value);\n        }\n        function formatRegistryFunction(format, value) {\n            if (!FormatRegistry.Has(format))\n                return false;\n            const checkFunc = FormatRegistry.Get(format);\n            return checkFunc(value);\n        }\n        function hashFunction(value) {\n            return Hash(value);\n        }\n        const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);\n        return new TypeCheck(schema, references, checkFunction, generatedCode);\n    }\n    TypeCompiler.Compile = Compile;\n})(TypeCompiler || (TypeCompiler = {}));\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10972, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mateo/Documents/GitHub/aevum_web/node_modules/%40sinclair/typebox/build/esm/system/system.mjs"],"sourcesContent":["import { TypeRegistry, FormatRegistry } from '../type/registry/index.mjs';\nimport { Unsafe } from '../type/unsafe/index.mjs';\nimport { Kind } from '../type/symbols/index.mjs';\nimport { TypeBoxError } from '../type/error/index.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class TypeSystemDuplicateTypeKind extends TypeBoxError {\n    constructor(kind) {\n        super(`Duplicate type kind '${kind}' detected`);\n    }\n}\nexport class TypeSystemDuplicateFormat extends TypeBoxError {\n    constructor(kind) {\n        super(`Duplicate string format '${kind}' detected`);\n    }\n}\n/** Creates user defined types and formats and provides overrides for value checking behaviours */\nexport var TypeSystem;\n(function (TypeSystem) {\n    /** Creates a new type */\n    function Type(kind, check) {\n        if (TypeRegistry.Has(kind))\n            throw new TypeSystemDuplicateTypeKind(kind);\n        TypeRegistry.Set(kind, check);\n        return (options = {}) => Unsafe({ ...options, [Kind]: kind });\n    }\n    TypeSystem.Type = Type;\n    /** Creates a new string format */\n    function Format(format, check) {\n        if (FormatRegistry.Has(format))\n            throw new TypeSystemDuplicateFormat(format);\n        FormatRegistry.Set(format, check);\n        return format;\n    }\n    TypeSystem.Format = Format;\n})(TypeSystem || (TypeSystem = {}));\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AACA;AACA;AACA;;;;;AAIO,MAAM,oCAAoC,kMAAY;IACzD,YAAY,IAAI,CAAE;QACd,KAAK,CAAC,CAAC,qBAAqB,EAAE,KAAK,UAAU,CAAC;IAClD;AACJ;AACO,MAAM,kCAAkC,kMAAY;IACvD,YAAY,IAAI,CAAE;QACd,KAAK,CAAC,CAAC,yBAAyB,EAAE,KAAK,UAAU,CAAC;IACtD;AACJ;AAEO,IAAI;AACX,CAAC,SAAU,UAAU;IACjB,uBAAuB,GACvB,SAAS,KAAK,IAAI,EAAE,KAAK;QACrB,IAAI,4OAAY,CAAC,GAAG,CAAC,OACjB,MAAM,IAAI,4BAA4B;QAC1C,4OAAY,CAAC,GAAG,CAAC,MAAM;QACvB,OAAO,CAAC,UAAU,CAAC,CAAC,GAAK,IAAA,8LAAM,EAAC;gBAAE,GAAG,OAAO;gBAAE,CAAC,8LAAI,CAAC,EAAE;YAAK;IAC/D;IACA,WAAW,IAAI,GAAG;IAClB,gCAAgC,GAChC,SAAS,OAAO,MAAM,EAAE,KAAK;QACzB,IAAI,kPAAc,CAAC,GAAG,CAAC,SACnB,MAAM,IAAI,0BAA0B;QACxC,kPAAc,CAAC,GAAG,CAAC,QAAQ;QAC3B,OAAO;IACX;IACA,WAAW,MAAM,GAAG;AACxB,CAAC,EAAE,cAAc,CAAC,aAAa,CAAC,CAAC","ignoreList":[0]}}]
}